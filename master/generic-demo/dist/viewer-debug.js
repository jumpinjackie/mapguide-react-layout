var MapGuide;
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./stdassets/images/icons/PoweredBy_en.png":
/*!*************************************************!*\
  !*** ./stdassets/images/icons/PoweredBy_en.png ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/PoweredBy_en.png");

/***/ }),

/***/ "./stdassets/images/icons/about.png":
/*!******************************************!*\
  !*** ./stdassets/images/icons/about.png ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/about.png");

/***/ }),

/***/ "./stdassets/images/icons/application-browser.png":
/*!********************************************************!*\
  !*** ./stdassets/images/icons/application-browser.png ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/application-browser.png");

/***/ }),

/***/ "./stdassets/images/icons/back.png":
/*!*****************************************!*\
  !*** ./stdassets/images/icons/back.png ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/back.png");

/***/ }),

/***/ "./stdassets/images/icons/buffer.png":
/*!*******************************************!*\
  !*** ./stdassets/images/icons/buffer.png ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/buffer.png");

/***/ }),

/***/ "./stdassets/images/icons/control-180.png":
/*!************************************************!*\
  !*** ./stdassets/images/icons/control-180.png ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/control-180.png");

/***/ }),

/***/ "./stdassets/images/icons/control-stop-180.png":
/*!*****************************************************!*\
  !*** ./stdassets/images/icons/control-stop-180.png ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/control-stop-180.png");

/***/ }),

/***/ "./stdassets/images/icons/control-stop.png":
/*!*************************************************!*\
  !*** ./stdassets/images/icons/control-stop.png ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/control-stop.png");

/***/ }),

/***/ "./stdassets/images/icons/control.png":
/*!********************************************!*\
  !*** ./stdassets/images/icons/control.png ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/control.png");

/***/ }),

/***/ "./stdassets/images/icons/coordinate-tracker.png":
/*!*******************************************************!*\
  !*** ./stdassets/images/icons/coordinate-tracker.png ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/coordinate-tracker.png");

/***/ }),

/***/ "./stdassets/images/icons/edit-copy.png":
/*!**********************************************!*\
  !*** ./stdassets/images/icons/edit-copy.png ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/edit-copy.png");

/***/ }),

/***/ "./stdassets/images/icons/edit-cut.png":
/*!*********************************************!*\
  !*** ./stdassets/images/icons/edit-cut.png ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/edit-cut.png");

/***/ }),

/***/ "./stdassets/images/icons/edit-duplicate.png":
/*!***************************************************!*\
  !*** ./stdassets/images/icons/edit-duplicate.png ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/edit-duplicate.png");

/***/ }),

/***/ "./stdassets/images/icons/edit-paste.png":
/*!***********************************************!*\
  !*** ./stdassets/images/icons/edit-paste.png ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/edit-paste.png");

/***/ }),

/***/ "./stdassets/images/icons/edit-xml.png":
/*!*********************************************!*\
  !*** ./stdassets/images/icons/edit-xml.png ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/edit-xml.png");

/***/ }),

/***/ "./stdassets/images/icons/feature-info.png":
/*!*************************************************!*\
  !*** ./stdassets/images/icons/feature-info.png ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/feature-info.png");

/***/ }),

/***/ "./stdassets/images/icons/file-print.png":
/*!***********************************************!*\
  !*** ./stdassets/images/icons/file-print.png ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/file-print.png");

/***/ }),

/***/ "./stdassets/images/icons/file-save.png":
/*!**********************************************!*\
  !*** ./stdassets/images/icons/file-save.png ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/file-save.png");

/***/ }),

/***/ "./stdassets/images/icons/folder-horizontal-open.png":
/*!***********************************************************!*\
  !*** ./stdassets/images/icons/folder-horizontal-open.png ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/folder-horizontal-open.png");

/***/ }),

/***/ "./stdassets/images/icons/folder-horizontal.png":
/*!******************************************************!*\
  !*** ./stdassets/images/icons/folder-horizontal.png ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/folder-horizontal.png");

/***/ }),

/***/ "./stdassets/images/icons/forward.png":
/*!********************************************!*\
  !*** ./stdassets/images/icons/forward.png ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/forward.png");

/***/ }),

/***/ "./stdassets/images/icons/geolocation.png":
/*!************************************************!*\
  !*** ./stdassets/images/icons/geolocation.png ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/geolocation.png");

/***/ }),

/***/ "./stdassets/images/icons/globe-share.png":
/*!************************************************!*\
  !*** ./stdassets/images/icons/globe-share.png ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/globe-share.png");

/***/ }),

/***/ "./stdassets/images/icons/globe_add.png":
/*!**********************************************!*\
  !*** ./stdassets/images/icons/globe_add.png ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/globe_add.png");

/***/ }),

/***/ "./stdassets/images/icons/help.png":
/*!*****************************************!*\
  !*** ./stdassets/images/icons/help.png ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/help.png");

/***/ }),

/***/ "./stdassets/images/icons/iconNavigator.png":
/*!**************************************************!*\
  !*** ./stdassets/images/icons/iconNavigator.png ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/iconNavigator.png");

/***/ }),

/***/ "./stdassets/images/icons/icon_home.png":
/*!**********************************************!*\
  !*** ./stdassets/images/icons/icon_home.png ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/icon_home.png");

/***/ }),

/***/ "./stdassets/images/icons/icon_menuarrow.png":
/*!***************************************************!*\
  !*** ./stdassets/images/icons/icon_menuarrow.png ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/icon_menuarrow.png");

/***/ }),

/***/ "./stdassets/images/icons/icon_menuarrow_disabled.png":
/*!************************************************************!*\
  !*** ./stdassets/images/icons/icon_menuarrow_disabled.png ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/icon_menuarrow_disabled.png");

/***/ }),

/***/ "./stdassets/images/icons/icon_menuarrowup.png":
/*!*****************************************************!*\
  !*** ./stdassets/images/icons/icon_menuarrowup.png ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/icon_menuarrowup.png");

/***/ }),

/***/ "./stdassets/images/icons/icon_menuarrowup_disabled.png":
/*!**************************************************************!*\
  !*** ./stdassets/images/icons/icon_menuarrowup_disabled.png ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/icon_menuarrowup_disabled.png");

/***/ }),

/***/ "./stdassets/images/icons/icon_refreshmap.png":
/*!****************************************************!*\
  !*** ./stdassets/images/icons/icon_refreshmap.png ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/icon_refreshmap.png");

/***/ }),

/***/ "./stdassets/images/icons/icon_warning.png":
/*!*************************************************!*\
  !*** ./stdassets/images/icons/icon_warning.png ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/icon_warning.png");

/***/ }),

/***/ "./stdassets/images/icons/icon_zoomselect.png":
/*!****************************************************!*\
  !*** ./stdassets/images/icons/icon_zoomselect.png ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/icon_zoomselect.png");

/***/ }),

/***/ "./stdassets/images/icons/info.png":
/*!*****************************************!*\
  !*** ./stdassets/images/icons/info.png ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/info.png");

/***/ }),

/***/ "./stdassets/images/icons/initial-center.png":
/*!***************************************************!*\
  !*** ./stdassets/images/icons/initial-center.png ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/initial-center.png");

/***/ }),

/***/ "./stdassets/images/icons/invoke-script.png":
/*!**************************************************!*\
  !*** ./stdassets/images/icons/invoke-script.png ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/invoke-script.png");

/***/ }),

/***/ "./stdassets/images/icons/invoke-url.png":
/*!***********************************************!*\
  !*** ./stdassets/images/icons/invoke-url.png ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/invoke-url.png");

/***/ }),

/***/ "./stdassets/images/icons/layer_add.png":
/*!**********************************************!*\
  !*** ./stdassets/images/icons/layer_add.png ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/layer_add.png");

/***/ }),

/***/ "./stdassets/images/icons/lc_unselect.png":
/*!************************************************!*\
  !*** ./stdassets/images/icons/lc_unselect.png ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/lc_unselect.png");

/***/ }),

/***/ "./stdassets/images/icons/legend-DWF.png":
/*!***********************************************!*\
  !*** ./stdassets/images/icons/legend-DWF.png ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/legend-DWF.png");

/***/ }),

/***/ "./stdassets/images/icons/legend-layer.png":
/*!*************************************************!*\
  !*** ./stdassets/images/icons/legend-layer.png ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/legend-layer.png");

/***/ }),

/***/ "./stdassets/images/icons/legend-map.png":
/*!***********************************************!*\
  !*** ./stdassets/images/icons/legend-map.png ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/legend-map.png");

/***/ }),

/***/ "./stdassets/images/icons/legend-raster.png":
/*!**************************************************!*\
  !*** ./stdassets/images/icons/legend-raster.png ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/legend-raster.png");

/***/ }),

/***/ "./stdassets/images/icons/legend-theme.png":
/*!*************************************************!*\
  !*** ./stdassets/images/icons/legend-theme.png ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/legend-theme.png");

/***/ }),

/***/ "./stdassets/images/icons/maptip.png":
/*!*******************************************!*\
  !*** ./stdassets/images/icons/maptip.png ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/maptip.png");

/***/ }),

/***/ "./stdassets/images/icons/measure.png":
/*!********************************************!*\
  !*** ./stdassets/images/icons/measure.png ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/measure.png");

/***/ }),

/***/ "./stdassets/images/icons/options.png":
/*!********************************************!*\
  !*** ./stdassets/images/icons/options.png ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/options.png");

/***/ }),

/***/ "./stdassets/images/icons/out-of-range.png":
/*!*************************************************!*\
  !*** ./stdassets/images/icons/out-of-range.png ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/out-of-range.png");

/***/ }),

/***/ "./stdassets/images/icons/overview-map.png":
/*!*************************************************!*\
  !*** ./stdassets/images/icons/overview-map.png ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/overview-map.png");

/***/ }),

/***/ "./stdassets/images/icons/pan-east.png":
/*!*********************************************!*\
  !*** ./stdassets/images/icons/pan-east.png ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/pan-east.png");

/***/ }),

/***/ "./stdassets/images/icons/pan-north.png":
/*!**********************************************!*\
  !*** ./stdassets/images/icons/pan-north.png ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/pan-north.png");

/***/ }),

/***/ "./stdassets/images/icons/pan-south.png":
/*!**********************************************!*\
  !*** ./stdassets/images/icons/pan-south.png ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/pan-south.png");

/***/ }),

/***/ "./stdassets/images/icons/pan-west.png":
/*!*********************************************!*\
  !*** ./stdassets/images/icons/pan-west.png ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/pan-west.png");

/***/ }),

/***/ "./stdassets/images/icons/pan.png":
/*!****************************************!*\
  !*** ./stdassets/images/icons/pan.png ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/pan.png");

/***/ }),

/***/ "./stdassets/images/icons/preview.png":
/*!********************************************!*\
  !*** ./stdassets/images/icons/preview.png ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/preview.png");

/***/ }),

/***/ "./stdassets/images/icons/print.png":
/*!******************************************!*\
  !*** ./stdassets/images/icons/print.png ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/print.png");

/***/ }),

/***/ "./stdassets/images/icons/property.png":
/*!*********************************************!*\
  !*** ./stdassets/images/icons/property.png ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/property.png");

/***/ }),

/***/ "./stdassets/images/icons/query.png":
/*!******************************************!*\
  !*** ./stdassets/images/icons/query.png ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/query.png");

/***/ }),

/***/ "./stdassets/images/icons/redline.png":
/*!********************************************!*\
  !*** ./stdassets/images/icons/redline.png ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/redline.png");

/***/ }),

/***/ "./stdassets/images/icons/search.png":
/*!*******************************************!*\
  !*** ./stdassets/images/icons/search.png ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/search.png");

/***/ }),

/***/ "./stdassets/images/icons/select-centre.png":
/*!**************************************************!*\
  !*** ./stdassets/images/icons/select-centre.png ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/select-centre.png");

/***/ }),

/***/ "./stdassets/images/icons/select-clear.png":
/*!*************************************************!*\
  !*** ./stdassets/images/icons/select-clear.png ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/select-clear.png");

/***/ }),

/***/ "./stdassets/images/icons/select-features.png":
/*!****************************************************!*\
  !*** ./stdassets/images/icons/select-features.png ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/select-features.png");

/***/ }),

/***/ "./stdassets/images/icons/select-polygon.png":
/*!***************************************************!*\
  !*** ./stdassets/images/icons/select-polygon.png ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/select-polygon.png");

/***/ }),

/***/ "./stdassets/images/icons/select-radius.png":
/*!**************************************************!*\
  !*** ./stdassets/images/icons/select-radius.png ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/select-radius.png");

/***/ }),

/***/ "./stdassets/images/icons/select-zoom.png":
/*!************************************************!*\
  !*** ./stdassets/images/icons/select-zoom.png ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/select-zoom.png");

/***/ }),

/***/ "./stdassets/images/icons/select.png":
/*!*******************************************!*\
  !*** ./stdassets/images/icons/select.png ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/select.png");

/***/ }),

/***/ "./stdassets/images/icons/theme.png":
/*!******************************************!*\
  !*** ./stdassets/images/icons/theme.png ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/theme.png");

/***/ }),

/***/ "./stdassets/images/icons/toggle-expand.png":
/*!**************************************************!*\
  !*** ./stdassets/images/icons/toggle-expand.png ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/toggle-expand.png");

/***/ }),

/***/ "./stdassets/images/icons/toggle.png":
/*!*******************************************!*\
  !*** ./stdassets/images/icons/toggle.png ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/toggle.png");

/***/ }),

/***/ "./stdassets/images/icons/ui-menu.png":
/*!********************************************!*\
  !*** ./stdassets/images/icons/ui-menu.png ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/ui-menu.png");

/***/ }),

/***/ "./stdassets/images/icons/view-back.png":
/*!**********************************************!*\
  !*** ./stdassets/images/icons/view-back.png ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/view-back.png");

/***/ }),

/***/ "./stdassets/images/icons/view-forward.png":
/*!*************************************************!*\
  !*** ./stdassets/images/icons/view-forward.png ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/view-forward.png");

/***/ }),

/***/ "./stdassets/images/icons/view-refresh.png":
/*!*************************************************!*\
  !*** ./stdassets/images/icons/view-refresh.png ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/view-refresh.png");

/***/ }),

/***/ "./stdassets/images/icons/zoom-dynamic.png":
/*!*************************************************!*\
  !*** ./stdassets/images/icons/zoom-dynamic.png ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/zoom-dynamic.png");

/***/ }),

/***/ "./stdassets/images/icons/zoom-full.png":
/*!**********************************************!*\
  !*** ./stdassets/images/icons/zoom-full.png ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/zoom-full.png");

/***/ }),

/***/ "./stdassets/images/icons/zoom-in-fixed.png":
/*!**************************************************!*\
  !*** ./stdassets/images/icons/zoom-in-fixed.png ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/zoom-in-fixed.png");

/***/ }),

/***/ "./stdassets/images/icons/zoom-in.png":
/*!********************************************!*\
  !*** ./stdassets/images/icons/zoom-in.png ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/zoom-in.png");

/***/ }),

/***/ "./stdassets/images/icons/zoom-out-fixed.png":
/*!***************************************************!*\
  !*** ./stdassets/images/icons/zoom-out-fixed.png ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/icons/zoom-out-fixed.png");

/***/ }),

/***/ "./stdassets/images/res/slider.png":
/*!*****************************************!*\
  !*** ./stdassets/images/res/slider.png ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/res/slider.png");

/***/ }),

/***/ "./stdassets/images/res/sliderscale.png":
/*!**********************************************!*\
  !*** ./stdassets/images/res/sliderscale.png ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/res/sliderscale.png");

/***/ }),

/***/ "./stdassets/images/res/spinner.gif":
/*!******************************************!*\
  !*** ./stdassets/images/res/spinner.gif ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/images/res/spinner.gif");

/***/ }),

/***/ "./stdassets/cursors/digitizeCircle.cur":
/*!**********************************************!*\
  !*** ./stdassets/cursors/digitizeCircle.cur ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/cursors/digitizeCircle.cur");

/***/ }),

/***/ "./stdassets/cursors/digitizeLine.cur":
/*!********************************************!*\
  !*** ./stdassets/cursors/digitizeLine.cur ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/cursors/digitizeLine.cur");

/***/ }),

/***/ "./stdassets/cursors/digitizeLineString.cur":
/*!**************************************************!*\
  !*** ./stdassets/cursors/digitizeLineString.cur ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/cursors/digitizeLineString.cur");

/***/ }),

/***/ "./stdassets/cursors/digitizePoint.cur":
/*!*********************************************!*\
  !*** ./stdassets/cursors/digitizePoint.cur ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/cursors/digitizePoint.cur");

/***/ }),

/***/ "./stdassets/cursors/digitizePolygon.cur":
/*!***********************************************!*\
  !*** ./stdassets/cursors/digitizePolygon.cur ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/cursors/digitizePolygon.cur");

/***/ }),

/***/ "./stdassets/cursors/digitizeRectangle.cur":
/*!*************************************************!*\
  !*** ./stdassets/cursors/digitizeRectangle.cur ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/cursors/digitizeRectangle.cur");

/***/ }),

/***/ "./stdassets/cursors/grab.cur":
/*!************************************!*\
  !*** ./stdassets/cursors/grab.cur ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/cursors/grab.cur");

/***/ }),

/***/ "./stdassets/cursors/grabbing.cur":
/*!****************************************!*\
  !*** ./stdassets/cursors/grabbing.cur ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/cursors/grabbing.cur");

/***/ }),

/***/ "./stdassets/cursors/zoomin.cur":
/*!**************************************!*\
  !*** ./stdassets/cursors/zoomin.cur ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("./dist/stdassets/cursors/zoomin.cur");

/***/ }),

/***/ "./src/styles/index.css":
/*!******************************!*\
  !*** ./src/styles/index.css ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/actions/defs.ts":
/*!*****************************!*\
  !*** ./src/actions/defs.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/**
 * defs.ts
 *
 * Redux action definitions
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isGenericSubjectMapLayer = exports.GenericSubjectLayerType = void 0;
/**
 * Valid generic subject layer types
 *
 * @export
 * @enum {string}
 * @since 0.14
 */
var GenericSubjectLayerType;
(function (GenericSubjectLayerType) {
    /**
     * A tiled WMS layer
     */
    GenericSubjectLayerType["TileWMS"] = "TileWMS";
    /**
     * A vector layer based on an external CSV file
     */
    GenericSubjectLayerType["CSV"] = "CSV";
    /**
     * A vector layer based on an external KML file
     */
    GenericSubjectLayerType["KML"] = "KML";
    /**
     * A vector layer based on an external GeoJSON file
     */
    GenericSubjectLayerType["GeoJSON"] = "GeoJSON";
    /**
     * A vector layer based on an inline GeoJSON fragment
     */
    GenericSubjectLayerType["GeoJSON_Inline"] = "GeoJSON_Inline";
    /**
     * A vector layer based on a custom-defined format whose driver was registered with {@link ExternalLayerFactoryRegistry.registerExternalVectorLayerCreator}
     */
    GenericSubjectLayerType["CustomVector"] = "CustomVector";
    /**
     * A vector layer based on a Mapbox Vector Tile set
     */
    GenericSubjectLayerType["MVT"] = "MVT";
    /**
     * A XYZ tileset
     * @since 0.14.3
     * @remarks A XYZ subject layer will not be added as a base layer. It will be considered as an "overlay" with respect to any existing base layers present
     */
    GenericSubjectLayerType["XYZ"] = "XYZ";
    /**
     * A static image layer
     * @since 0.14.3
     */
    GenericSubjectLayerType["StaticImage"] = "StaticImage";
})(GenericSubjectLayerType = exports.GenericSubjectLayerType || (exports.GenericSubjectLayerType = {}));
function isGenericSubjectMapLayer(map) {
    var _a;
    return typeof ((_a = map) === null || _a === void 0 ? void 0 : _a.type) == 'string';
}
exports.isGenericSubjectMapLayer = isGenericSubjectMapLayer;


/***/ }),

/***/ "./src/actions/flyout.ts":
/*!*******************************!*\
  !*** ./src/actions/flyout.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.closeComponent = exports.openComponent = exports.closeFlyout = exports.openFlyout = exports.closeContextMenu = exports.openContextMenu = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
/**
 * Opens the context menu at the specific position
 *
 * @param position The client x/y position
 * @since 0.13
 */
function openContextMenu(position) {
    return {
        type: actions_1.ActionType.CONTEXT_MENU_OPEN,
        payload: (0, tslib_1.__assign)({}, position)
    };
}
exports.openContextMenu = openContextMenu;
/**
 * Closes the context menu
 *
 * @since 0.13
 */
function closeContextMenu() {
    return {
        type: actions_1.ActionType.CONTEXT_MENU_CLOSE
    };
}
exports.closeContextMenu = closeContextMenu;
/**
 * Opens the specified flyout menu
 *
 * @export
 * @param {string} id
 * @param {IDOMElementMetrics} metrics
 * @returns {IOpenFlyoutAction}
 */
function openFlyout(id, metrics) {
    return {
        type: actions_1.ActionType.FLYOUT_OPEN,
        payload: {
            flyoutId: id,
            metrics: metrics
        }
    };
}
exports.openFlyout = openFlyout;
/**
 * Closes the specified flyout menu
 *
 * @export
 * @param {string} id
 * @returns {ICloseFlyoutAction}
 */
function closeFlyout(id) {
    return {
        type: actions_1.ActionType.FLYOUT_CLOSE,
        payload: {
            flyoutId: id
        }
    };
}
exports.closeFlyout = closeFlyout;
/**
 * Load the specified component in the given flyout with the given component props
 *
 * @export
 * @param {string} id
 * @param {IDOMElementMetrics} metrics
 * @param {string} name
 * @param {*} props
 * @returns {IOpenComponentInFlyoutAction}
 */
function openComponent(id, metrics, name, props) {
    return {
        type: actions_1.ActionType.COMPONENT_OPEN,
        payload: {
            flyoutId: id,
            metrics: metrics,
            name: name,
            props: props
        }
    };
}
exports.openComponent = openComponent;
/**
 * Closes the component in the given flyout
 *
 * @export
 * @param {string} id
 * @returns {ICloseComponentInFlyoutAction}
 */
function closeComponent(id) {
    return {
        type: actions_1.ActionType.COMPONENT_CLOSE,
        payload: {
            flyoutId: id
        }
    };
}
exports.closeComponent = closeComponent;


/***/ }),

/***/ "./src/actions/init-command.ts":
/*!*************************************!*\
  !*** ./src/actions/init-command.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViewerInitCommand = exports.isStateless = exports.isMapDefinition = exports.getMapDefinitionsFromFlexLayout = exports.buildSubjectLayerDefn = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var init_1 = __webpack_require__(/*! ./init */ "./src/actions/init.ts");
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var command_spec_1 = __webpack_require__(/*! ../api/registry/command-spec */ "./src/api/registry/command-spec.ts");
var array_1 = __webpack_require__(/*! ../utils/array */ "./src/utils/array.ts");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
var command_1 = __webpack_require__(/*! ../api/registry/command */ "./src/api/registry/command.ts");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
var url_1 = __webpack_require__(/*! ../utils/url */ "./src/utils/url.ts");
var error_1 = __webpack_require__(/*! ../api/error */ "./src/api/error.ts");
var string_1 = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");
var TYPE_SUBJECT = "SubjectLayer";
var TYPE_EXTERNAL = "External";
function getMapGuideConfiguration(appDef) {
    var configs = [];
    if (appDef.MapSet) {
        for (var _i = 0, _a = appDef.MapSet.MapGroup; _i < _a.length; _i++) {
            var mg = _a[_i];
            for (var _b = 0, _c = mg.Map; _b < _c.length; _b++) {
                var map = _c[_b];
                if (map.Type == "MapGuide") {
                    configs.push([mg["@id"], map]);
                }
            }
        }
    }
    return configs;
}
function tryExtractMapMetadata(extension) {
    var ext = {};
    for (var k in extension) {
        if ((0, string_1.strStartsWith)(k, "Meta_")) {
            var sk = k.substring("Meta_".length);
            ext[sk] = extension[k];
        }
    }
    return ext;
}
function buildSubjectLayerDefn(name, map) {
    var _a, _b;
    var st = map.Extension.source_type;
    var initiallyVisible = (_a = map.Extension.initially_visible) !== null && _a !== void 0 ? _a : true;
    var sp = {};
    var lo = {};
    var meta = {};
    var keys = Object.keys(map.Extension);
    var popupTemplate = map.Extension.popup_template;
    var selectable = (_b = map.Extension.is_selectable) !== null && _b !== void 0 ? _b : true;
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var k = keys_1[_i];
        var spidx = k.indexOf("source_param_");
        var loidx = k.indexOf("layer_opt_");
        var midx = k.indexOf("meta_");
        if (spidx == 0) {
            var kn = k.substring("source_param_".length);
            sp[kn] = map.Extension[k];
        }
        else if (loidx == 0) {
            var kn = k.substring("layer_opt_".length);
            lo[kn] = map.Extension[k];
        }
        else if (midx == 0) {
            var kn = k.substring("meta_".length);
            meta[kn] = map.Extension[k];
        }
    }
    var sl = {
        name: name,
        description: map.Extension.layer_description,
        displayName: map.Extension.display_name,
        driverName: map.Extension.driver_name,
        type: st,
        layerOptions: lo,
        sourceParams: sp,
        meta: (Object.keys(meta).length > 0 ? meta : undefined),
        initiallyVisible: initiallyVisible,
        selectable: selectable,
        popupTemplate: popupTemplate,
        vectorStyle: map.Extension.vector_layer_style
    };
    if (map.Extension.cluster) {
        sl.cluster = (0, tslib_1.__assign)({}, map.Extension.cluster);
    }
    return sl;
}
exports.buildSubjectLayerDefn = buildSubjectLayerDefn;
function getMapDefinitionsFromFlexLayout(appDef) {
    var _a;
    var maps = [];
    var configs = getMapGuideConfiguration(appDef);
    if (configs.length > 0) {
        for (var _i = 0, configs_1 = configs; _i < configs_1.length; _i++) {
            var c = configs_1[_i];
            maps.push({
                name: c[0],
                mapDef: c[1].Extension.ResourceId,
                metadata: tryExtractMapMetadata(c[1].Extension)
            });
        }
    }
    if ((_a = appDef.MapSet) === null || _a === void 0 ? void 0 : _a.MapGroup) {
        for (var _b = 0, _c = appDef.MapSet.MapGroup; _b < _c.length; _b++) {
            var mGroup = _c[_b];
            for (var _d = 0, _e = mGroup.Map; _d < _e.length; _d++) {
                var map = _e[_d];
                if (map.Type == TYPE_SUBJECT) {
                    var name_1 = mGroup["@id"];
                    maps.push(buildSubjectLayerDefn(name_1, map));
                }
            }
        }
    }
    if (maps.length == 0)
        throw new error_1.MgError("No Map Definition or subject layer found in Application Definition");
    return maps;
}
exports.getMapDefinitionsFromFlexLayout = getMapDefinitionsFromFlexLayout;
function isMapDefinition(arg) {
    return arg.mapDef != null;
}
exports.isMapDefinition = isMapDefinition;
function isStateless(appDef) {
    var _a;
    // This appdef is stateless if:
    //
    //  1. It has a Stateless extension property set to "true" (ie. The author has opted-in to this feature)
    //  2. No MapGuide Map Definitions were found in the appdef
    if (((_a = appDef.Extension) === null || _a === void 0 ? void 0 : _a.Stateless) == "true")
        return true;
    try {
        var maps = getMapDefinitionsFromFlexLayout(appDef);
        for (var _i = 0, maps_1 = maps; _i < maps_1.length; _i++) {
            var m = maps_1[_i];
            if (isMapDefinition(m)) {
                return false;
            }
        }
        return true;
    }
    catch (e) {
        return true;
    }
}
exports.isStateless = isStateless;
var ViewerInitCommand = /** @class */ (function () {
    function ViewerInitCommand(dispatch) {
        this.dispatch = dispatch;
    }
    ViewerInitCommand.prototype.initLocaleAsync = function (options) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var locale, r, res;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        locale = options.locale;
                        if (!(locale != i18n_1.DEFAULT_LOCALE)) return [3 /*break*/, 4];
                        return [4 /*yield*/, fetch("strings/" + locale + ".json")];
                    case 1:
                        r = _a.sent();
                        if (!r.ok) return [3 /*break*/, 3];
                        return [4 /*yield*/, r.json()];
                    case 2:
                        res = _a.sent();
                        (0, i18n_1.registerStringBundle)(locale, res);
                        // Dispatch the SET_LOCALE as it is safe to change UI strings at this point
                        this.dispatch({
                            type: actions_1.ActionType.SET_LOCALE,
                            payload: locale
                        });
                        (0, logger_1.info)("Registered string bundle for locale: " + locale);
                        return [3 /*break*/, 4];
                    case 3:
                        //TODO: Push warning to init error/warning reducer when we implement it
                        (0, logger_1.warn)("Failed to register string bundle for locale: " + locale);
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    ViewerInitCommand.prototype.getExtraProjectionsFromFlexLayout = function (appDef) {
        //The only widget we care about is the coordinate tracker
        var epsgs = [];
        for (var _i = 0, _a = appDef.WidgetSet; _i < _a.length; _i++) {
            var ws = _a[_i];
            for (var _b = 0, _c = ws.Widget; _b < _c.length; _b++) {
                var w = _c[_b];
                if (w.Type == "CoordinateTracker") {
                    var ps = w.Extension.Projection || [];
                    for (var _d = 0, ps_1 = ps; _d < ps_1.length; _d++) {
                        var p = ps_1[_d];
                        epsgs.push(p.split(':')[1]);
                    }
                }
                else if (w.Type == "CursorPosition") {
                    var dp = w.Extension.DisplayProjection;
                    if (dp) {
                        epsgs.push(dp.split(':')[1]);
                    }
                }
            }
        }
        return (0, array_1.makeUnique)(epsgs);
    };
    ViewerInitCommand.prototype.initFromAppDefCoreAsync = function (appDef, options, mapsByName, warnings) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, taskPane, hasTaskBar, hasStatus, hasNavigator, hasSelectionPanel, hasLegend, viewSize, widgetsByKey, isStateless, initialTask, locale, featureTooltipsEnabled, config, tbConf, _i, _b, widgetSet, _c, _d, cont, tbName, _e, _f, w, mapsDict, maps, _g, firstMapName, firstSessionId, _h, tb, bFoundContextMenu;
            return (0, tslib_1.__generator)(this, function (_j) {
                _a = (0, command_spec_1.parseWidgetsInAppDef)(appDef, command_1.registerCommand), taskPane = _a.taskPane, hasTaskBar = _a.hasTaskBar, hasStatus = _a.hasStatus, hasNavigator = _a.hasNavigator, hasSelectionPanel = _a.hasSelectionPanel, hasLegend = _a.hasLegend, viewSize = _a.viewSize, widgetsByKey = _a.widgetsByKey, isStateless = _a.isStateless, initialTask = _a.initialTask;
                locale = options.locale, featureTooltipsEnabled = options.featureTooltipsEnabled;
                config = {};
                config.isStateless = isStateless;
                tbConf = {};
                //Now build toolbar layouts
                for (_i = 0, _b = appDef.WidgetSet; _i < _b.length; _i++) {
                    widgetSet = _b[_i];
                    for (_c = 0, _d = widgetSet.Container; _c < _d.length; _c++) {
                        cont = _d[_c];
                        tbName = cont.Name;
                        tbConf[tbName] = { items: (0, command_spec_1.convertFlexLayoutUIItems)(isStateless, cont.Item, widgetsByKey, locale) };
                    }
                    for (_e = 0, _f = widgetSet.Widget; _e < _f.length; _e++) {
                        w = _f[_e];
                        if (w.Type == "CursorPosition") {
                            config.coordinateProjection = w.Extension.DisplayProjection;
                            config.coordinateDecimals = w.Extension.Precision;
                            config.coordinateDisplayFormat = w.Extension.Template;
                        }
                    }
                }
                mapsDict = mapsByName;
                maps = this.setupMaps(appDef, mapsDict, config, warnings, locale);
                if (appDef.Title) {
                    document.title = appDef.Title || document.title;
                }
                _g = this.establishInitialMapNameAndSession(mapsDict), firstMapName = _g[0], firstSessionId = _g[1];
                _h = (0, command_spec_1.prepareSubMenus)(tbConf), tb = _h[0], bFoundContextMenu = _h[1];
                if (!bFoundContextMenu) {
                    warnings.push((0, i18n_1.tr)("INIT_WARNING_NO_CONTEXT_MENU", locale, { containerName: constants_1.WEBLAYOUT_CONTEXTMENU }));
                }
                return [2 /*return*/, (0, init_1.normalizeInitPayload)({
                        activeMapName: firstMapName,
                        initialUrl: (0, url_1.ensureParameters)(initialTask, firstMapName, firstSessionId, locale),
                        featureTooltipsEnabled: featureTooltipsEnabled,
                        locale: locale,
                        maps: maps,
                        config: config,
                        capabilities: {
                            hasTaskPane: (taskPane != null),
                            hasTaskBar: hasTaskBar,
                            hasStatusBar: hasStatus,
                            hasNavigator: hasNavigator,
                            hasSelectionPanel: hasSelectionPanel,
                            hasLegend: hasLegend,
                            hasToolbar: (Object.keys(tbConf).length > 0),
                            hasViewSize: (viewSize != null)
                        },
                        toolbars: tb,
                        warnings: warnings,
                        initialActiveTool: common_1.ActiveMapTool.Pan
                    }, options.layout)];
            });
        });
    };
    return ViewerInitCommand;
}());
exports.ViewerInitCommand = ViewerInitCommand;


/***/ }),

/***/ "./src/actions/init-mapguide.ts":
/*!**************************************!*\
  !*** ./src/actions/init-mapguide.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultViewerInitCommand = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var string_1 = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");
var client_1 = __webpack_require__(/*! ../api/client */ "./src/api/client.ts");
var init_1 = __webpack_require__(/*! ./init */ "./src/actions/init.ts");
var request_builder_1 = __webpack_require__(/*! ../api/request-builder */ "./src/api/request-builder.ts");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
var error_1 = __webpack_require__(/*! ../api/error */ "./src/api/error.ts");
var projections_1 = __webpack_require__(/*! ../api/registry/projections */ "./src/api/registry/projections.ts");
var proj4_1 = __webpack_require__(/*! ol/proj/proj4 */ "./node_modules/ol/proj/proj4.js");
var proj4_2 = (0, tslib_1.__importDefault)(__webpack_require__(/*! proj4 */ "./node_modules/proj4/lib/index.js"));
var init_command_1 = __webpack_require__(/*! ./init-command */ "./src/actions/init-command.ts");
var command_spec_1 = __webpack_require__(/*! ../api/registry/command-spec */ "./src/api/registry/command-spec.ts");
var session_store_1 = __webpack_require__(/*! ../api/session-store */ "./src/api/session-store.ts");
var shortid = (0, tslib_1.__importStar)(__webpack_require__(/*! shortid */ "./node_modules/shortid/index.js"));
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
var command_1 = __webpack_require__(/*! ../api/registry/command */ "./src/api/registry/command.ts");
var url_1 = __webpack_require__(/*! ../utils/url */ "./src/utils/url.ts");
var assert_1 = __webpack_require__(/*! ../utils/assert */ "./src/utils/assert.ts");
var lazy_1 = __webpack_require__(/*! ../api/lazy */ "./src/api/lazy.ts");
var type_guards_1 = __webpack_require__(/*! ../utils/type-guards */ "./src/utils/type-guards.ts");
var units_1 = __webpack_require__(/*! ../utils/units */ "./src/utils/units.tsx");
var TYPE_SUBJECT = "SubjectLayer";
var TYPE_EXTERNAL = "External";
/**
 * Default viewer init commmand
 *
 * @since 0.14
 */
var DefaultViewerInitCommand = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(DefaultViewerInitCommand, _super);
    function DefaultViewerInitCommand(dispatch) {
        return _super.call(this, dispatch) || this;
    }
    DefaultViewerInitCommand.prototype.attachClient = function (client) {
        this.client = client;
    };
    DefaultViewerInitCommand.prototype.isArbitraryCoordSys = function (subject) {
        if (subject) {
            if ((0, type_guards_1.isRuntimeMap)(subject)) {
                var arbCs = (0, units_1.tryParseArbitraryCs)(subject.CoordinateSystem.MentorCode);
                return arbCs != null;
            }
        }
        return false;
    };
    /**
     * @override
     * @protected
     * @param {Dictionary<RuntimeMap>} mapsByName
     * @memberof MgViewerInitCommand
     */
    DefaultViewerInitCommand.prototype.establishInitialMapNameAndSession = function (mapsByName) {
        var firstMapName = "";
        var firstSessionId = "";
        for (var mapName in mapsByName) {
            if (!firstMapName && !firstSessionId) {
                var map = mapsByName[mapName];
                if ((0, type_guards_1.isRuntimeMap)(map)) {
                    firstMapName = map.Name;
                    firstSessionId = map.SessionId;
                    break;
                }
            }
        }
        return [firstMapName, firstSessionId];
    };
    DefaultViewerInitCommand.prototype.getDesiredTargetMapName = function (mapDef) {
        var lastSlash = mapDef.lastIndexOf("/");
        var lastDot = mapDef.lastIndexOf(".");
        if (lastSlash >= 0 && lastDot >= 0 && lastDot > lastSlash) {
            return "" + mapDef.substring(lastSlash + 1, lastDot);
        }
        else {
            return "Map_" + shortid.generate();
        }
    };
    DefaultViewerInitCommand.prototype.initFromWebLayoutAsync = function (webLayout, session, sessionWasReused) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, mapsByName, warnings, _b, locale, featureTooltipsEnabled, externalBaseLayers, cmdsByKey, mainToolbar, taskBar, contextMenu, config, initialView, maps, _c, firstMapName, firstSessionId, menus, tb;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, this.createRuntimeMapsAsync(session, webLayout, false, function (wl) { return [{ name: _this.getDesiredTargetMapName(wl.Map.ResourceId), mapDef: wl.Map.ResourceId, metadata: {} }]; }, function () { return []; }, sessionWasReused)];
                    case 1:
                        _a = _d.sent(), mapsByName = _a[0], warnings = _a[1];
                        _b = this.options, locale = _b.locale, featureTooltipsEnabled = _b.featureTooltipsEnabled, externalBaseLayers = _b.externalBaseLayers;
                        cmdsByKey = (0, command_spec_1.parseCommandsInWebLayout)(webLayout, command_1.registerCommand);
                        mainToolbar = (webLayout.ToolBar.Visible
                            ? (0, command_spec_1.convertWebLayoutUIItems)(webLayout.ToolBar.Button, cmdsByKey, locale)
                            : []);
                        taskBar = (webLayout.TaskPane.TaskBar.Visible
                            ? (0, command_spec_1.convertWebLayoutUIItems)(webLayout.TaskPane.TaskBar.MenuButton, cmdsByKey, locale, false)
                            : []);
                        contextMenu = (webLayout.ContextMenu.Visible
                            ? (0, command_spec_1.convertWebLayoutUIItems)(webLayout.ContextMenu.MenuItem, cmdsByKey, locale, false)
                            : []);
                        config = {};
                        if (webLayout.SelectionColor != null) {
                            config.selectionColor = webLayout.SelectionColor;
                        }
                        if (webLayout.MapImageFormat != null) {
                            config.imageFormat = webLayout.MapImageFormat;
                        }
                        if (webLayout.SelectionImageFormat != null) {
                            config.selectionImageFormat = webLayout.SelectionImageFormat;
                        }
                        if (webLayout.PointSelectionBuffer != null) {
                            config.pointSelectionBuffer = webLayout.PointSelectionBuffer;
                        }
                        initialView = null;
                        if (webLayout.Map.InitialView != null) {
                            initialView = {
                                x: webLayout.Map.InitialView.CenterX,
                                y: webLayout.Map.InitialView.CenterY,
                                scale: webLayout.Map.InitialView.Scale
                            };
                        }
                        if (webLayout.Title != "") {
                            document.title = webLayout.Title || document.title;
                        }
                        maps = {};
                        _c = this.establishInitialMapNameAndSession(mapsByName), firstMapName = _c[0], firstSessionId = _c[1];
                        menus = {};
                        menus[constants_1.WEBLAYOUT_TOOLBAR] = {
                            items: mainToolbar
                        };
                        menus[constants_1.WEBLAYOUT_TASKMENU] = {
                            items: taskBar
                        };
                        menus[constants_1.WEBLAYOUT_CONTEXTMENU] = {
                            items: contextMenu
                        };
                        tb = (0, command_spec_1.prepareSubMenus)(menus)[0];
                        return [2 /*return*/, {
                                activeMapName: firstMapName,
                                featureTooltipsEnabled: featureTooltipsEnabled,
                                initialUrl: (0, url_1.ensureParameters)(webLayout.TaskPane.InitialTask || "server/TaskPane.html", firstMapName, firstSessionId, locale),
                                initialTaskPaneWidth: webLayout.TaskPane.Width,
                                initialInfoPaneWidth: webLayout.InformationPane.Width,
                                maps: maps,
                                locale: locale,
                                config: config,
                                capabilities: {
                                    hasTaskPane: webLayout.TaskPane.Visible,
                                    hasTaskBar: webLayout.TaskPane.TaskBar.Visible,
                                    hasStatusBar: webLayout.StatusBar.Visible,
                                    hasNavigator: webLayout.ZoomControl.Visible,
                                    hasSelectionPanel: webLayout.InformationPane.Visible && webLayout.InformationPane.PropertiesVisible,
                                    hasLegend: webLayout.InformationPane.Visible && webLayout.InformationPane.LegendVisible,
                                    hasToolbar: webLayout.ToolBar.Visible,
                                    hasViewSize: webLayout.StatusBar.Visible
                                },
                                toolbars: tb,
                                warnings: warnings,
                                initialActiveTool: common_1.ActiveMapTool.Pan
                            }];
                }
            });
        });
    };
    DefaultViewerInitCommand.prototype.tryDescribeRuntimeMapAsync = function (mapName, session, mapDef) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var map, _a, _b, e_1, map, _c, _d;
            var _e, _f;
            return (0, tslib_1.__generator)(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        (0, assert_1.assertIsDefined)(this.client);
                        _g.label = 1;
                    case 1:
                        _g.trys.push([1, 4, , 8]);
                        _b = (_a = this.client).describeRuntimeMap;
                        _e = {
                            mapname: mapName,
                            requestedFeatures: request_builder_1.RuntimeMapFeatureFlags.LayerFeatureSources | request_builder_1.RuntimeMapFeatureFlags.LayerIcons | request_builder_1.RuntimeMapFeatureFlags.LayersAndGroups
                        };
                        return [4 /*yield*/, session.getValueAsync()];
                    case 2: return [4 /*yield*/, _b.apply(_a, [(_e.session = _g.sent(),
                                _e)])];
                    case 3:
                        map = _g.sent();
                        return [2 /*return*/, map];
                    case 4:
                        e_1 = _g.sent();
                        if (!(e_1.message === "MgResourceNotFoundException")) return [3 /*break*/, 7];
                        _d = (_c = this.client).createRuntimeMap;
                        _f = {
                            mapDefinition: mapDef,
                            requestedFeatures: request_builder_1.RuntimeMapFeatureFlags.LayerFeatureSources | request_builder_1.RuntimeMapFeatureFlags.LayerIcons | request_builder_1.RuntimeMapFeatureFlags.LayersAndGroups
                        };
                        return [4 /*yield*/, session.getValueAsync()];
                    case 5: return [4 /*yield*/, _d.apply(_c, [(_f.session = _g.sent(),
                                _f.targetMapName = mapName,
                                _f)])];
                    case 6:
                        map = _g.sent();
                        return [2 /*return*/, map];
                    case 7: throw e_1;
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    DefaultViewerInitCommand.prototype.createRuntimeMapsAsync = function (session, res, isStateless, mapDefSelector, projectionSelector, sessionWasReused) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var mapDefs, mapPromises, warnings, locale, subjectLayers, siteVersion, _i, mapDefs_1, m, siteVer, _a, mapDefs_2, m, _b, _c, _d, _e, maps, fetchEpsgs, _f, maps_1, m, epsg, mapDef, arbCs, extraEpsgs, _g, extraEpsgs_1, e, epsgs, mapsByName, _h, maps_2, map, _j, mapDefs_3, gs;
            var _k;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_l) {
                switch (_l.label) {
                    case 0:
                        mapDefs = mapDefSelector(res);
                        mapPromises = [];
                        warnings = [];
                        locale = this.options.locale;
                        subjectLayers = {};
                        if (!isStateless) return [3 /*break*/, 5];
                        siteVersion = new lazy_1.AsyncLazy(function () { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                            var sv;
                            return (0, tslib_1.__generator)(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        (0, assert_1.assertIsDefined)(this.client);
                                        return [4 /*yield*/, this.client.getSiteVersion()];
                                    case 1:
                                        sv = _a.sent();
                                        return [2 /*return*/, sv];
                                }
                            });
                        }); });
                        _i = 0, mapDefs_1 = mapDefs;
                        _l.label = 1;
                    case 1:
                        if (!(_i < mapDefs_1.length)) return [3 /*break*/, 4];
                        m = mapDefs_1[_i];
                        if (!(0, init_command_1.isMapDefinition)(m)) return [3 /*break*/, 3];
                        return [4 /*yield*/, siteVersion.getValueAsync()];
                    case 2:
                        siteVer = _l.sent();
                        (0, assert_1.assertIsDefined)(this.client);
                        mapPromises.push(this.describeRuntimeMapStateless(this.client, siteVer.Version, m));
                        _l.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [3 /*break*/, 10];
                    case 5:
                        _a = 0, mapDefs_2 = mapDefs;
                        _l.label = 6;
                    case 6:
                        if (!(_a < mapDefs_2.length)) return [3 /*break*/, 10];
                        m = mapDefs_2[_a];
                        if (!(0, init_command_1.isMapDefinition)(m)) return [3 /*break*/, 9];
                        if (!sessionWasReused) return [3 /*break*/, 7];
                        //FIXME: If the map state we're recovering has a selection, we need to re-init the selection client-side
                        (0, logger_1.info)("Session ID re-used. Attempting recovery of map state of: " + m.name);
                        mapPromises.push(this.tryDescribeRuntimeMapAsync(m.name, session, m.mapDef));
                        return [3 /*break*/, 9];
                    case 7:
                        (0, logger_1.info)("Creating runtime map state (" + m.name + ") for: " + m.mapDef);
                        (0, assert_1.assertIsDefined)(this.client);
                        _c = (_b = mapPromises).push;
                        _e = (_d = this.client).createRuntimeMap;
                        _k = {
                            mapDefinition: m.mapDef,
                            requestedFeatures: request_builder_1.RuntimeMapFeatureFlags.LayerFeatureSources | request_builder_1.RuntimeMapFeatureFlags.LayerIcons | request_builder_1.RuntimeMapFeatureFlags.LayersAndGroups
                        };
                        return [4 /*yield*/, session.getValueAsync()];
                    case 8:
                        _c.apply(_b, [_e.apply(_d, [(_k.session = _l.sent(),
                                    _k.targetMapName = m.name,
                                    _k)])]);
                        _l.label = 9;
                    case 9:
                        _a++;
                        return [3 /*break*/, 6];
                    case 10: return [4 /*yield*/, Promise.all(mapPromises)];
                    case 11:
                        maps = _l.sent();
                        fetchEpsgs = [];
                        //All must be non-zero
                        for (_f = 0, maps_1 = maps; _f < maps_1.length; _f++) {
                            m = maps_1[_f];
                            epsg = m.CoordinateSystem.EpsgCode;
                            mapDef = m.MapDefinition;
                            arbCs = (0, units_1.tryParseArbitraryCs)(m.CoordinateSystem.MentorCode);
                            if (!arbCs) {
                                if (epsg == "0") {
                                    throw new error_1.MgError((0, i18n_1.tr)("INIT_ERROR_UNSUPPORTED_COORD_SYS", locale || i18n_1.DEFAULT_LOCALE, { mapDefinition: mapDef }));
                                }
                                //Must be registered to proj4js if not 4326 or 3857
                                if (!proj4_2.default.defs["EPSG:" + epsg]) {
                                    fetchEpsgs.push({ epsg: epsg, mapDef: mapDef });
                                }
                            }
                        }
                        extraEpsgs = projectionSelector(res);
                        for (_g = 0, extraEpsgs_1 = extraEpsgs; _g < extraEpsgs_1.length; _g++) {
                            e = extraEpsgs_1[_g];
                            fetchEpsgs.push({ epsg: e, mapDef: "" });
                        }
                        return [4 /*yield*/, Promise.all(fetchEpsgs.map(function (f) { return (0, projections_1.resolveProjectionFromEpsgIoAsync)(f.epsg, locale, f.mapDef); }))];
                    case 12:
                        epsgs = _l.sent();
                        //Previously, we register proj4 with OpenLayers on the bootstrap phase way before this init
                        //process is started. This no longer works for OL6 where it doesn't seem to pick up the extra
                        //projections we've registered with proj4 after linking proj4 to OpenLayers. So that registration
                        //step has been relocated here, after all the custom projections have been fetched and registered
                        //with proj4
                        (0, logger_1.debug)("Register proj4 with OpenLayers");
                        (0, proj4_1.register)(proj4_2.default);
                        mapsByName = {};
                        for (_h = 0, maps_2 = maps; _h < maps_2.length; _h++) {
                            map = maps_2[_h];
                            mapsByName[map.Name] = map;
                        }
                        for (_j = 0, mapDefs_3 = mapDefs; _j < mapDefs_3.length; _j++) {
                            gs = mapDefs_3[_j];
                            if (!(0, init_command_1.isMapDefinition)(gs)) {
                                mapsByName[gs.name] = gs;
                            }
                        }
                        return [2 /*return*/, [mapsByName, warnings]];
                }
            });
        });
    };
    DefaultViewerInitCommand.prototype.describeRuntimeMapStateless = function (client, siteVersion, m) {
        var _a, _b, _c;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var name, mapDef, metadata, mdf, rt, groups, layers, tsd, sTileWidth, sTileHeight, _i, _d, bg, _e, _f, lyr, _g, _h, grp, _j, _k, lyr;
            return (0, tslib_1.__generator)(this, function (_l) {
                switch (_l.label) {
                    case 0:
                        name = m.name, mapDef = m.mapDef, metadata = m.metadata;
                        return [4 /*yield*/, ((_a = this.client) === null || _a === void 0 ? void 0 : _a.getResource(mapDef, { username: "Anonymous" }))];
                    case 1:
                        mdf = _l.sent();
                        if (!mdf)
                            throw new Error("Failed to fetch map def");
                        rt = {
                            SessionId: "",
                            Extents: {
                                LowerLeftCoordinate: {
                                    X: mdf.Extents.MinX,
                                    Y: mdf.Extents.MinY
                                },
                                UpperRightCoordinate: {
                                    X: mdf.Extents.MaxX,
                                    Y: mdf.Extents.MaxY
                                }
                            },
                            SiteVersion: siteVersion,
                            Name: name,
                            DisplayDpi: 96,
                            BackgroundColor: mdf.BackgroundColor,
                            MapDefinition: mapDef,
                            CoordinateSystem: {
                                // We are assuming the app def specifies this data in each <Map> entry as extension properties
                                // beginning with "Meta_" (eg. Meta_MentorCode, Meta_EpsgCode, etc)
                                MentorCode: metadata.MentorCode,
                                EpsgCode: metadata.EpsgCode,
                                MetersPerUnit: metadata.MetersPerUnit,
                                Wkt: mdf.CoordinateSystem
                            },
                            IconMimeType: "image/png",
                        };
                        groups = [];
                        layers = [];
                        if (!mdf.TileSetSource) return [3 /*break*/, 3];
                        rt.TileSetDefinition = mdf.TileSetSource.ResourceId;
                        return [4 /*yield*/, client.getResource(mdf.TileSetSource.ResourceId)];
                    case 2:
                        tsd = _l.sent();
                        if (tsd.TileStoreParameters.TileProvider == "Default") {
                            sTileWidth = (_b = tsd.TileStoreParameters.Parameter.find(function (p) { return p.Name == "TileWidth"; })) === null || _b === void 0 ? void 0 : _b.Value;
                            sTileHeight = (_c = tsd.TileStoreParameters.Parameter.find(function (p) { return p.Name == "TileHeight"; })) === null || _c === void 0 ? void 0 : _c.Value;
                            if (!(0, string_1.strIsNullOrEmpty)(sTileWidth) && !(0, string_1.strIsNullOrEmpty)(sTileHeight)) {
                                rt.TileWidth = parseInt(sTileWidth, 10);
                                rt.TileHeight = parseInt(sTileHeight, 10);
                            }
                        }
                        else if (tsd.TileStoreParameters.TileProvider == "XYZ") {
                            rt.TileHeight = 256;
                            rt.TileHeight = 256;
                        }
                        for (_i = 0, _d = tsd.BaseMapLayerGroup; _i < _d.length; _i++) {
                            bg = _d[_i];
                            groups.push({
                                Name: bg.Name,
                                DisplayInLegend: bg.ShowInLegend,
                                LegendLabel: bg.LegendLabel,
                                ObjectId: bg.Name,
                                ExpandInLegend: bg.ExpandInLegend,
                                Visible: bg.Visible,
                                ActuallyVisible: bg.Visible,
                                Type: 3 /* BaseMapFromTileSet */
                            });
                            for (_e = 0, _f = bg.BaseMapLayer; _e < _f.length; _e++) {
                                lyr = _f[_e];
                                layers.push({
                                    Name: lyr.Name,
                                    DisplayInLegend: lyr.ShowInLegend,
                                    // We don't have stateless QUERYMAPFEATURES (yet), so there is no point actually respecting this flag
                                    Selectable: false,
                                    LegendLabel: lyr.LegendLabel,
                                    ExpandInLegend: lyr.ExpandInLegend,
                                    Visible: true,
                                    ParentId: bg.Name,
                                    ActuallyVisible: true,
                                    LayerDefinition: lyr.ResourceId,
                                    ObjectId: lyr.Name,
                                    Type: 2 /* BaseMap */
                                });
                            }
                        }
                        _l.label = 3;
                    case 3:
                        for (_g = 0, _h = mdf.MapLayerGroup; _g < _h.length; _g++) {
                            grp = _h[_g];
                            groups.push({
                                Name: grp.Name,
                                DisplayInLegend: grp.ShowInLegend,
                                LegendLabel: grp.LegendLabel,
                                ObjectId: grp.Name,
                                ExpandInLegend: grp.ExpandInLegend,
                                Visible: grp.Visible,
                                ActuallyVisible: grp.Visible,
                                Type: 1 /* Normal */
                            });
                        }
                        for (_j = 0, _k = mdf.MapLayer; _j < _k.length; _j++) {
                            lyr = _k[_j];
                            layers.push({
                                Name: lyr.Name,
                                DisplayInLegend: lyr.ShowInLegend,
                                // We don't have stateless QUERYMAPFEATURES (yet), so there is no point actually respecting this flag
                                Selectable: false,
                                LegendLabel: lyr.LegendLabel,
                                ExpandInLegend: lyr.ExpandInLegend,
                                Visible: true,
                                ParentId: lyr.Group,
                                ActuallyVisible: true,
                                LayerDefinition: lyr.ResourceId,
                                ObjectId: lyr.Name,
                                Type: 1 /* Dynamic */
                            });
                        }
                        rt.Group = groups;
                        rt.Layer = layers;
                        return [2 /*return*/, rt];
                }
            });
        });
    };
    /**
     * @override
     * @protected
     * @param {ApplicationDefinition} appDef
     * @param {Dictionary<SubjectLayerType>} mapsByName
     * @param {*} config
     * @param {string[]} warnings
     * @returns {Dictionary<MapInfo>}
     * @memberof MgViewerInitCommand
     */
    DefaultViewerInitCommand.prototype.setupMaps = function (appDef, mapsByName, config, warnings, locale) {
        var dict = {};
        if (appDef.MapSet) {
            for (var _i = 0, _a = appDef.MapSet.MapGroup; _i < _a.length; _i++) {
                var mGroup = _a[_i];
                var mapName = void 0;
                //Setup external layers
                var initExternalLayers = [];
                var externalBaseLayers = [];
                var subject = void 0;
                //Need to do this in 2 passes. 1st pass to try and get the MG map
                for (var _b = 0, _c = mGroup.Map; _b < _c.length; _b++) {
                    var map = _c[_b];
                    if (map.Type === "MapGuide") {
                        //TODO: Based on the schema, different MG map groups could have different
                        //settings here and our redux tree should reflect that. Currently the first one "wins"
                        if (!config.selectionColor && map.Extension.SelectionColor != null) {
                            config.selectionColor = map.Extension.SelectionColor;
                        }
                        if (!config.imageFormat && map.Extension.ImageFormat != null) {
                            config.imageFormat = map.Extension.ImageFormat;
                        }
                        if (!config.selectionImageFormat && map.Extension.SelectionFormat != null) {
                            config.selectionImageFormat = map.Extension.SelectionFormat;
                        }
                        //NOTE: Although non-sensical, if the same map definition exists across multiple
                        //MapGroups, we might be matching the wrong one. We just assume such non-sensical
                        //AppDefs won't exist
                        for (var name_1 in mapsByName) {
                            var mapDef = mapsByName[name_1];
                            if ((0, type_guards_1.isRuntimeMap)(mapDef) && mapDef.MapDefinition == map.Extension.ResourceId) {
                                mapName = name_1;
                                subject = mapDef;
                                break;
                            }
                        }
                    }
                }
                var isArbitrary = this.isArbitraryCoordSys(subject);
                //2nd pass to process non-MG maps
                for (var _d = 0, _e = mGroup.Map; _d < _e.length; _d++) {
                    var map = _e[_d];
                    if (map.Type == "MapGuide") {
                        continue;
                    }
                    if (map.Type == TYPE_SUBJECT) {
                        mapName = mGroup["@id"];
                    }
                    else {
                        if (isArbitrary) {
                            warnings.push((0, i18n_1.tr)("INIT_WARNING_ARBITRARY_COORDSYS_INCOMPATIBLE_LAYER", locale, { mapId: mGroup["@id"], type: map.Type }));
                        }
                        else {
                            if (map.Type == TYPE_EXTERNAL) {
                                initExternalLayers.push((0, init_command_1.buildSubjectLayerDefn)(map.Extension.layer_name, map));
                            }
                            else {
                                (0, init_1.processLayerInMapGroup)(map, warnings, config, appDef, externalBaseLayers);
                            }
                        }
                    }
                }
                if (isArbitrary) {
                    //Check for incompatible widgets
                    for (var _f = 0, _g = appDef.WidgetSet; _f < _g.length; _f++) {
                        var wset = _g[_f];
                        for (var _h = 0, _j = wset.Widget; _h < _j.length; _h++) {
                            var widget = _j[_h];
                            switch (widget.Type) {
                                case "CoordinateTracker":
                                    warnings.push((0, i18n_1.tr)("INIT_WARNING_ARBITRARY_COORDSYS_UNSUPPORTED_WIDGET", locale, { mapId: mGroup["@id"], widget: widget.Type }));
                                    break;
                            }
                        }
                    }
                }
                (0, init_1.applyInitialBaseLayerVisibility)(externalBaseLayers);
                //Setup initial view
                var initialView = void 0;
                if (mGroup.InitialView) {
                    initialView = {
                        x: mGroup.InitialView.CenterX,
                        y: mGroup.InitialView.CenterY,
                        scale: mGroup.InitialView.Scale
                    };
                }
                if (mapName) {
                    dict[mapName] = {
                        mapGroupId: mGroup["@id"],
                        map: mapsByName[mapName],
                        initialView: initialView,
                        externalBaseLayers: externalBaseLayers,
                        initialExternalLayers: initExternalLayers
                    };
                }
            }
        }
        return dict;
    };
    DefaultViewerInitCommand.prototype.initFromAppDefAsync = function (appDef, session, sessionWasReused) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, mapsByName, warnings;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.createRuntimeMapsAsync(session, appDef, (0, init_command_1.isStateless)(appDef), function (fl) { return (0, init_command_1.getMapDefinitionsFromFlexLayout)(fl); }, function (fl) { return _this.getExtraProjectionsFromFlexLayout(fl); }, sessionWasReused)];
                    case 1:
                        _a = _b.sent(), mapsByName = _a[0], warnings = _a[1];
                        return [4 /*yield*/, this.initFromAppDefCoreAsync(appDef, this.options, mapsByName, warnings)];
                    case 2: return [2 /*return*/, _b.sent()];
                }
            });
        });
    };
    DefaultViewerInitCommand.prototype.sessionAcquiredAsync = function (session, sessionWasReused) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, resourceId, locale, cl, fl, e_2, wl, _b, _c, _d, fl, _e, _f, _g, fl, cl, fl;
            var _h, _j;
            return (0, tslib_1.__generator)(this, function (_k) {
                switch (_k.label) {
                    case 0:
                        _a = this.options, resourceId = _a.resourceId, locale = _a.locale;
                        if (!!resourceId) return [3 /*break*/, 6];
                        cl = new client_1.Client("", "mapagent");
                        _k.label = 1;
                    case 1:
                        _k.trys.push([1, 4, , 5]);
                        return [4 /*yield*/, cl.get("appdef.json")];
                    case 2:
                        fl = _k.sent();
                        return [4 /*yield*/, this.initFromAppDefAsync(fl, session, sessionWasReused)];
                    case 3: return [2 /*return*/, _k.sent()];
                    case 4:
                        e_2 = _k.sent();
                        throw new error_1.MgError((0, i18n_1.tr)("INIT_ERROR_MISSING_RESOURCE_PARAM", locale));
                    case 5: return [3 /*break*/, 25];
                    case 6:
                        if (!(typeof (resourceId) == 'string')) return [3 /*break*/, 22];
                        if (!(0, string_1.strEndsWith)(resourceId, "WebLayout")) return [3 /*break*/, 10];
                        (0, assert_1.assertIsDefined)(this.client);
                        _c = (_b = this.client).getResource;
                        _d = [resourceId];
                        _h = {};
                        return [4 /*yield*/, session.getValueAsync()];
                    case 7: return [4 /*yield*/, _c.apply(_b, _d.concat([(_h.SESSION = _k.sent(), _h)]))];
                    case 8:
                        wl = _k.sent();
                        return [4 /*yield*/, this.initFromWebLayoutAsync(wl, session, sessionWasReused)];
                    case 9: return [2 /*return*/, _k.sent()];
                    case 10:
                        if (!(0, string_1.strEndsWith)(resourceId, "ApplicationDefinition")) return [3 /*break*/, 14];
                        (0, assert_1.assertIsDefined)(this.client);
                        _f = (_e = this.client).getResource;
                        _g = [resourceId];
                        _j = {};
                        return [4 /*yield*/, session.getValueAsync()];
                    case 11: return [4 /*yield*/, _f.apply(_e, _g.concat([(_j.SESSION = _k.sent(), _j)]))];
                    case 12:
                        fl = _k.sent();
                        return [4 /*yield*/, this.initFromAppDefAsync(fl, session, sessionWasReused)];
                    case 13: return [2 /*return*/, _k.sent()];
                    case 14:
                        if (!(0, string_1.isResourceId)(resourceId)) return [3 /*break*/, 15];
                        throw new error_1.MgError((0, i18n_1.tr)("INIT_ERROR_UNKNOWN_RESOURCE_TYPE", locale, { resourceId: resourceId }));
                    case 15:
                        fl = void 0;
                        if (!!this.client) return [3 /*break*/, 17];
                        cl = new client_1.Client("", "mapagent");
                        return [4 /*yield*/, cl.get(resourceId)];
                    case 16:
                        fl = _k.sent();
                        return [3 /*break*/, 19];
                    case 17: return [4 /*yield*/, this.client.get(resourceId)];
                    case 18:
                        fl = _k.sent();
                        _k.label = 19;
                    case 19: return [4 /*yield*/, this.initFromAppDefAsync(fl, session, sessionWasReused)];
                    case 20: return [2 /*return*/, _k.sent()];
                    case 21: return [3 /*break*/, 25];
                    case 22: return [4 /*yield*/, resourceId()];
                    case 23:
                        fl = _k.sent();
                        return [4 /*yield*/, this.initFromAppDefAsync(fl, session, sessionWasReused)];
                    case 24: return [2 /*return*/, _k.sent()];
                    case 25: return [2 /*return*/];
                }
            });
        });
    };
    DefaultViewerInitCommand.prototype.runAsync = function (options) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var sessionWasReused, session, payload, initSelections, _a, _b, _i, mapName, sset, e_3;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        this.options = options;
                        return [4 /*yield*/, this.initLocaleAsync(this.options)];
                    case 1:
                        _c.sent();
                        sessionWasReused = false;
                        if (!this.options.session) {
                            session = new lazy_1.AsyncLazy(function () { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                                var sid;
                                return (0, tslib_1.__generator)(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            (0, assert_1.assertIsDefined)(this.client);
                                            return [4 /*yield*/, this.client.createSession("Anonymous", "")];
                                        case 1:
                                            sid = _a.sent();
                                            return [2 /*return*/, sid];
                                    }
                                });
                            }); });
                        }
                        else {
                            (0, logger_1.info)("Re-using session: " + this.options.session);
                            sessionWasReused = true;
                            session = new lazy_1.AsyncLazy(function () { return Promise.resolve(_this.options.session); });
                        }
                        return [4 /*yield*/, this.sessionAcquiredAsync(session, sessionWasReused)];
                    case 2:
                        payload = _c.sent();
                        if (!sessionWasReused) return [3 /*break*/, 10];
                        initSelections = {};
                        _a = [];
                        for (_b in payload.maps)
                            _a.push(_b);
                        _i = 0;
                        _c.label = 3;
                    case 3:
                        if (!(_i < _a.length)) return [3 /*break*/, 6];
                        mapName = _a[_i];
                        return [4 /*yield*/, (0, session_store_1.retrieveSelectionSetFromLocalStorage)(session, mapName)];
                    case 4:
                        sset = _c.sent();
                        if (sset) {
                            initSelections[mapName] = sset;
                        }
                        _c.label = 5;
                    case 5:
                        _i++;
                        return [3 /*break*/, 3];
                    case 6:
                        payload.initialSelections = initSelections;
                        _c.label = 7;
                    case 7:
                        _c.trys.push([7, 9, , 10]);
                        //In the interest of being a responsible citizen, clean up all selection-related stuff from
                        //session store
                        return [4 /*yield*/, (0, session_store_1.clearSessionStore)()];
                    case 8:
                        //In the interest of being a responsible citizen, clean up all selection-related stuff from
                        //session store
                        _c.sent();
                        return [3 /*break*/, 10];
                    case 9:
                        e_3 = _c.sent();
                        return [3 /*break*/, 10];
                    case 10: return [2 /*return*/, payload];
                }
            });
        });
    };
    return DefaultViewerInitCommand;
}(init_command_1.ViewerInitCommand));
exports.DefaultViewerInitCommand = DefaultViewerInitCommand;


/***/ }),

/***/ "./src/actions/init.ts":
/*!*****************************!*\
  !*** ./src/actions/init.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.acknowledgeInitWarnings = exports.initLayout = exports.processLayerInMapGroup = exports.normalizeInitPayload = exports.applyInitialBaseLayerVisibility = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var client_1 = __webpack_require__(/*! ../api/client */ "./src/api/client.ts");
var string_1 = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
var runtime_1 = __webpack_require__(/*! ../api/runtime */ "./src/api/runtime.ts");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var layout_1 = __webpack_require__(/*! ../api/registry/layout */ "./src/api/registry/layout.ts");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
function applyInitialBaseLayerVisibility(externalBaseLayers) {
    if (externalBaseLayers.length > 0) {
        // First visual base layer, first served
        var firstBase = externalBaseLayers.find(function (bl) { return bl.kind != "UTFGrid"; });
        if (firstBase) {
            firstBase.visible = true;
        }
        // Make all non-visual base layers (ie. UTFGrid) visible
        var nonVisuals = externalBaseLayers.filter(function (bl) { return bl.kind == "UTFGrid"; });
        for (var _i = 0, nonVisuals_1 = nonVisuals; _i < nonVisuals_1.length; _i++) {
            var nv = nonVisuals_1[_i];
            nv.visible = true;
        }
    }
}
exports.applyInitialBaseLayerVisibility = applyInitialBaseLayerVisibility;
function processAndDispatchInitError(error, includeStack, dispatch, opts) {
    if (error.stack) {
        dispatch({
            type: actions_1.ActionType.INIT_ERROR,
            payload: {
                error: {
                    message: error.message,
                    stack: (error.stack || "").split("\n")
                },
                includeStack: includeStack,
                options: opts
            }
        });
    }
    else {
        dispatch({
            type: actions_1.ActionType.INIT_ERROR,
            payload: {
                error: {
                    message: error.message,
                    stack: []
                },
                includeStack: includeStack,
                options: opts
            }
        });
    }
}
/**
 * @hidden
 */
function normalizeInitPayload(payload, layout) {
    if (!(0, string_1.strIsNullOrEmpty)(layout)) {
        var caps = (0, layout_1.getLayoutCapabilities)(layout);
        if (caps) {
            if (!caps.hasTaskPane) {
                (0, logger_1.debug)("Overriding hasTaskPane capability to false");
                payload.capabilities.hasTaskPane = false;
            }
        }
    }
    return payload;
}
exports.normalizeInitPayload = normalizeInitPayload;
var _counter = 0;
function processLayerInMapGroup(map, warnings, config, appDef, externalBaseLayers) {
    switch (map.Type) {
        case "Google":
            warnings.push((0, i18n_1.tr)("INIT_WARNING_UNSUPPORTED_GOOGLE_MAPS", config.locale));
            break;
        case "VirtualEarth":
            {
                //HACK: De-arrayification of arbitrary extension elements
                //is shallow (hence name/type is string[]). Do we bother to fix this?
                var _a = map.Extension.Options, name_1 = _a.name, type = _a.type;
                var sName_1 = Array.isArray(name_1) ? name_1[0] : name_1;
                var sType = Array.isArray(type) ? type[0] : type;
                var options = {};
                var bAdd = true;
                switch (sType) {
                    case "Aerial":
                    case "a":
                        options.imagerySet = "Aerial";
                        break;
                    case "AerialWithLabels":
                        options.imagerySet = "AerialWithLabels";
                        break;
                    case "Road":
                        options.imagerySet = "Road";
                        break;
                    default:
                        bAdd = false;
                        warnings.push((0, i18n_1.tr)("INIT_WARNING_BING_UNKNOWN_LAYER", config.locale, { type: type }));
                        break;
                }
                if (appDef.Extension.BingMapKey) {
                    options.key = appDef.Extension.BingMapKey;
                }
                else {
                    bAdd = false;
                    warnings.push((0, i18n_1.tr)("INIT_WARNING_BING_API_KEY_REQD", config.locale));
                }
                if (bAdd) {
                    externalBaseLayers.push({
                        name: sName_1,
                        kind: "BingMaps",
                        options: options
                    });
                }
            }
            break;
        case "OpenStreetMap":
            {
                //HACK: De-arrayification of arbitrary extension elements
                //is shallow (hence name/type is string[]). Do we bother to fix this?
                var _b = map.Extension.Options, name_2 = _b.name, type = _b.type;
                var sName_2 = Array.isArray(name_2) ? name_2[0] : name_2;
                var sType = Array.isArray(type) ? type[0] : type;
                var options = {};
                switch (sType) {
                    case "CycleMap":
                        options.url = "http://{a-c}.tile.opencyclemap.org/cycle/{z}/{x}/{y}.png";
                        break;
                    case "TransportMap":
                        options.url = "http://tile2.opencyclemap.org/transport/{z}/{x}/{y}.png";
                        break;
                }
                externalBaseLayers.push({
                    name: sName_2,
                    kind: "OSM",
                    options: options
                });
            }
            break;
        case "Stamen":
            {
                //HACK: De-arrayification of arbitrary extension elements
                //is shallow (hence name/type is string[]). Do we bother to fix this?
                var _c = map.Extension.Options, name_3 = _c.name, type = _c.type;
                var sName_3 = Array.isArray(name_3) ? name_3[0] : name_3;
                var sType = Array.isArray(type) ? type[0] : type;
                externalBaseLayers.push({
                    name: sName_3,
                    kind: "Stamen",
                    options: {
                        layer: sType
                    }
                });
            }
            break;
        case "UTFGrid":
            {
                externalBaseLayers.push({
                    name: "UTFGridSource" + _counter++,
                    kind: "UTFGrid",
                    options: {
                        tileJSON: {
                            scheme: "xyz",
                            grids: Array.isArray(map.Extension.UrlTemplate) ? (0, tslib_1.__spreadArray)([], map.Extension.UrlTemplate, true) : [map.Extension.UrlTemplate]
                        }
                    }
                });
            }
            break;
        case "XYZDebug":
            //HACK: De-arrayification of arbitrary extension elements
            //is shallow (hence name/type is string[]). Do we bother to fix this?
            var name_4 = map.Extension.Options.name;
            var sName = Array.isArray(name_4) ? name_4[0] : name_4;
            externalBaseLayers.push({
                name: sName,
                kind: "XYZDebug"
            });
            break;
        case "XYZ":
            {
                //HACK: De-arrayification of arbitrary extension elements
                //is shallow (hence name/type is string[]). Do we bother to fix this?
                var _d = map.Extension.Options, name_5 = _d.name, type = _d.type, attributions = _d.attributions;
                var sName_4 = Array.isArray(name_5) ? name_5[0] : name_5;
                var sType = Array.isArray(type) ? type[0] : type;
                var tilePixelRatio = 1;
                if (map.Extension.Options.tilePixelRatio) {
                    tilePixelRatio = parseInt(map.Extension.Options.tilePixelRatio[0], 10);
                }
                //NOTE: From a fusion appdef, we're expecting placeholder tokens to be in ${this_format} instead of
                //{this_format} as the primary consumer is the Fusion viewer that is based on OpenLayers 2
                //As we're not using OL2, but OL4+ the expected format is {this_format}, so we need to convert these
                //placeholder tokens
                var urls = (map.Extension.Options.urls || []).map(function (s) { return (0, string_1.strReplaceAll)(s, "${", "{"); });
                externalBaseLayers.push({
                    name: sName_4,
                    kind: "XYZ",
                    options: {
                        layer: sType,
                        urls: urls,
                        attributions: attributions,
                        tilePixelRatio: tilePixelRatio
                    }
                });
            }
            break;
    }
}
exports.processLayerInMapGroup = processLayerInMapGroup;
/**
 * Initializes the viewer
 *
 * @export
 * @param {IViewerInitCommand} cmd
 * @param {IInitAppLayout} options
 * @returns {ReduxThunkedAction}
 */
function initLayout(cmd, options) {
    var opts = (0, tslib_1.__assign)({}, options);
    return function (dispatch, getState) {
        var args = getState().config;
        //TODO: Fetch and init the string bundle earlier if "locale" is present
        //so the English init messages are seen only for a blink if requesting a
        //non-english string bundle
        if (args.agentUri && args.agentKind) {
            var client = new client_1.Client(args.agentUri, args.agentKind);
            cmd.attachClient(client);
        }
        cmd.runAsync(options).then(function (payload) {
            var initPayload = payload;
            if (opts.initialView) {
                initPayload.initialView = (0, tslib_1.__assign)({}, opts.initialView);
            }
            if (opts.initialActiveMap) {
                initPayload.activeMapName = opts.initialActiveMap;
            }
            initPayload.initialHideGroups = opts.initialHideGroups;
            initPayload.initialHideLayers = opts.initialHideLayers;
            initPayload.initialShowGroups = opts.initialShowGroups;
            initPayload.initialShowLayers = opts.initialShowLayers;
            initPayload.featureTooltipsEnabled = opts.featureTooltipsEnabled;
            dispatch({
                type: actions_1.ActionType.INIT_APP,
                payload: payload
            });
            if (options.onInit) {
                var viewer = (0, runtime_1.getViewer)();
                if (viewer) {
                    options.onInit(viewer);
                }
            }
        }).catch(function (err) {
            processAndDispatchInitError(err, false, dispatch, opts);
        });
    };
}
exports.initLayout = initLayout;
function acknowledgeInitWarnings() {
    return {
        type: actions_1.ActionType.INIT_ACKNOWLEDGE_WARNINGS
    };
}
exports.acknowledgeInitWarnings = acknowledgeInitWarnings;


/***/ }),

/***/ "./src/actions/legend.ts":
/*!*******************************!*\
  !*** ./src/actions/legend.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.refresh = exports.setLayerSelectable = exports.setGroupExpanded = exports.setLayerVisibility = exports.setGroupVisibility = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var client_1 = __webpack_require__(/*! ../api/client */ "./src/api/client.ts");
var request_builder_1 = __webpack_require__(/*! ../api/request-builder */ "./src/api/request-builder.ts");
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
/**
 * Sets the visibility for the given map group
 *
 * @export
 * @param {string} mapName
 * @param {{ id: string, value: boolean }} options
 * @returns
 */
function setGroupVisibility(mapName, options) {
    return {
        type: actions_1.ActionType.LEGEND_SET_GROUP_VISIBILITY,
        payload: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, options), { mapName: mapName })
    };
}
exports.setGroupVisibility = setGroupVisibility;
/**
 * Sets the visibility for the given map layer
 *
 * @export
 * @param {string} mapName
 * @param {{ id: string, value: boolean }} options
 * @returns
 */
function setLayerVisibility(mapName, options) {
    return {
        type: actions_1.ActionType.LEGEND_SET_LAYER_VISIBILITY,
        payload: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, options), { mapName: mapName })
    };
}
exports.setLayerVisibility = setLayerVisibility;
/**
 * Sets the expanded/collapsed state of the given group
 *
 * @export
 * @param {string} mapName
 * @param {{ id: string, value: boolean }} options
 * @returns
 */
function setGroupExpanded(mapName, options) {
    return {
        type: actions_1.ActionType.LEGEND_SET_GROUP_EXPANDABLE,
        payload: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, options), { mapName: mapName })
    };
}
exports.setGroupExpanded = setGroupExpanded;
/**
 * Sets the selectability state for the given map layer
 *
 * @export
 * @param {string} mapName
 * @param {{ id: string, value: boolean }} options
 * @returns
 */
function setLayerSelectable(mapName, options) {
    return {
        type: actions_1.ActionType.LEGEND_SET_LAYER_SELECTABLE,
        payload: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, options), { mapName: mapName })
    };
}
exports.setLayerSelectable = setLayerSelectable;
/**
 * Perform a full refresh with a requery of the layer/group structure
 *
 * @export
 * @returns {ReduxThunkedAction}
 */
function refresh() {
    return function (dispatch, getState) {
        var state = getState();
        var args = state.config;
        if (!args.viewer.isStateless) {
            var map = (0, common_1.getRuntimeMap)(state);
            if (map && args.agentUri && args.agentKind) {
                var client = new client_1.Client(args.agentUri, args.agentKind);
                client.describeRuntimeMap({
                    mapname: map.Name,
                    session: map.SessionId,
                    requestedFeatures: request_builder_1.RuntimeMapFeatureFlags.LayerFeatureSources | request_builder_1.RuntimeMapFeatureFlags.LayerIcons | request_builder_1.RuntimeMapFeatureFlags.LayersAndGroups
                }).then(function (res) {
                    if (args.activeMapName) {
                        dispatch({
                            type: actions_1.ActionType.MAP_REFRESH,
                            payload: {
                                mapName: args.activeMapName,
                                map: res
                            }
                        });
                    }
                });
            }
        }
    };
}
exports.refresh = refresh;


/***/ }),

/***/ "./src/actions/map.ts":
/*!****************************!*\
  !*** ./src/actions/map.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clearClientSelection = exports.addClientSelectedFeature = exports.removeMapLayerBusyWorker = exports.addMapLayerBusyWorker = exports.setMapLayerVectorStyle = exports.setMapLayerVisibility = exports.setHeatmapLayerRadius = exports.setHeatmapLayerBlur = exports.setMapLayerOpacity = exports.setMapLayerIndex = exports.removeMapLayer = exports.externalLayersReady = exports.mapLayerAdded = exports.showSelectedFeature = exports.setViewRotationEnabled = exports.setViewRotation = exports.setManualFeatureTooltipsEnabled = exports.enableSelectDragPan = exports.setFeatureTooltipsEnabled = exports.setActiveMap = exports.setActiveTool = exports.nextView = exports.previousView = exports.setViewSizeUnits = exports.setLayerTransparency = exports.setMouseCoordinates = exports.setScale = exports.setBaseLayer = exports.setBusyCount = exports.invokeCommand = exports.setSelection = exports.mapResized = exports.setCurrentView = exports.queryMapFeatures = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var runtime_1 = __webpack_require__(/*! ../api/runtime */ "./src/api/runtime.ts");
var number_1 = __webpack_require__(/*! ../utils/number */ "./src/utils/number.ts");
var client_1 = __webpack_require__(/*! ../api/client */ "./src/api/client.ts");
var deArrayify_1 = __webpack_require__(/*! ../api/builders/deArrayify */ "./src/api/builders/deArrayify.ts");
var array_1 = __webpack_require__(/*! ../utils/array */ "./src/utils/array.ts");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
var session_store_1 = __webpack_require__(/*! ../api/session-store */ "./src/api/session-store.ts");
var site_version_1 = __webpack_require__(/*! ../utils/site-version */ "./src/utils/site-version.ts");
var viewer_state_1 = __webpack_require__(/*! ../utils/viewer-state */ "./src/utils/viewer-state.ts");
function combineSelectedFeatures(oldRes, newRes) {
    var merged = [];
    for (var _i = 0, oldRes_1 = oldRes; _i < oldRes_1.length; _i++) {
        var feat = oldRes_1[_i];
        merged.push(feat);
    }
    var _loop_1 = function (feat) {
        //NOTE: Due to lack of identity property information, we have to
        //check all property values
        var matches = merged.filter(function (f) {
            for (var _i = 0, _a = f.Property; _i < _a.length; _i++) {
                var p = _a[_i];
                for (var _b = 0, _c = feat.Property; _b < _c.length; _b++) {
                    var np = _c[_b];
                    if (p.Name == np.Name) {
                        if (p.Value != np.Value) {
                            return false;
                        }
                    }
                }
            }
            return true;
        });
        if (matches.length == 0) {
            merged.push(feat);
        }
    };
    for (var _a = 0, newRes_1 = newRes; _a < newRes_1.length; _a++) {
        var feat = newRes_1[_a];
        _loop_1(feat);
    }
    return merged;
}
function combineSelectedFeatureSets(oldRes, newRes) {
    if (oldRes == null) {
        return newRes;
    }
    var merged = {
        SelectedLayer: []
    };
    for (var _i = 0, _a = oldRes.SelectedLayer; _i < _a.length; _i++) {
        var layer = _a[_i];
        merged.SelectedLayer.push(layer);
    }
    if (newRes) {
        var _loop_2 = function (layer) {
            var layerId = layer["@id"];
            var layerName = layer["@name"];
            var existing = merged.SelectedLayer.filter(function (l) { return l["@id"] == layerId && l["@name"] == layerName; });
            if (existing.length == 0) {
                merged.SelectedLayer.push(layer);
            }
            else {
                existing[0].Feature = combineSelectedFeatures(existing[0].Feature, layer.Feature);
            }
        };
        for (var _b = 0, _c = newRes.SelectedLayer; _b < _c.length; _b++) {
            var layer = _c[_b];
            _loop_2(layer);
        }
    }
    return merged;
}
function combineFeatureSets(oldRes, newRes) {
    if (oldRes == null) {
        return newRes;
    }
    var merged = {
        Layer: []
    };
    for (var _i = 0, _a = oldRes.Layer; _i < _a.length; _i++) {
        var layer = _a[_i];
        merged.Layer.push(layer);
    }
    if (newRes) {
        var _loop_3 = function (layer) {
            var layerId = layer["@id"];
            var existing = merged.Layer.filter(function (l) { return l["@id"] == layerId; });
            if (existing.length == 0) {
                merged.Layer.push(layer);
            }
            else {
                existing[0].Class.ID = (0, array_1.makeUnique)(existing[0].Class.ID.concat(layer.Class.ID));
            }
        };
        for (var _b = 0, _c = newRes.Layer; _b < _c.length; _b++) {
            var layer = _c[_b];
            _loop_3(layer);
        }
    }
    return merged;
}
function combineSelections(oldRes, newRes) {
    if (oldRes) {
        var merged = {
            SelectedFeatures: combineSelectedFeatureSets(oldRes.SelectedFeatures, newRes.SelectedFeatures),
            FeatureSet: combineFeatureSets(oldRes.FeatureSet, newRes.FeatureSet),
            Hyperlink: undefined,
            InlineSelectionImage: undefined
        };
        return merged;
    }
    else {
        return newRes;
    }
}
/**
 * Queries map features
 *
 * @export
 * @param {string} mapName The name of the current runtime map
 * @param {QueryMapFeatureActionOptions} opts query options
 * @returns {ReduxThunkedAction}
 */
function queryMapFeatures(mapName, opts) {
    return function (dispatch, getState) {
        var state = getState();
        var args = state.config;
        var map = (0, common_1.getRuntimeMap)(state);
        var selectionSet = (0, common_1.getSelectionSet)(state);
        if (map && args.agentKind && args.agentUri) {
            var client_2 = new client_1.Client(args.agentUri, args.agentKind);
            var success_1 = function (res) {
                if (opts.callback != null) {
                    opts.callback(res);
                }
            };
            var failure = function (err) {
                if (opts.errBack != null) {
                    opts.errBack(err);
                }
            };
            //We want v4.0.0 QUERYMAPFEATURES if available
            var sv = (0, site_version_1.getSiteVersion)(map);
            var queryOp_1 = (0, site_version_1.canUseQueryMapFeaturesV4)(sv)
                ? function (opts) { return client_2.queryMapFeatures_v4(opts); }
                : function (opts) { return client_2.queryMapFeatures(opts); };
            queryOp_1(opts.options).then(function (res) {
                if (opts.options.persist === 1) {
                    if (opts.append === true) {
                        var combined_1 = combineSelections(selectionSet, res);
                        var mergedXml = (0, deArrayify_1.buildSelectionXml)(combined_1.FeatureSet);
                        //Need to update the server-side selection with the merged result
                        queryOp_1({
                            session: map.SessionId,
                            mapname: map.Name,
                            persist: 1,
                            featurefilter: mergedXml
                        }).then(function () {
                            (0, session_store_1.persistSelectionSetToLocalStorage)(map.SessionId, mapName, combined_1); // set and forget
                            dispatch(setSelection(mapName, combined_1));
                            success_1(combined_1);
                        });
                    }
                    else {
                        (0, session_store_1.persistSelectionSetToLocalStorage)(map.SessionId, mapName, res); // set and forget
                        dispatch(setSelection(mapName, res));
                        success_1(res);
                    }
                }
                else {
                    success_1(res);
                }
            }).catch(failure);
        }
    };
}
exports.queryMapFeatures = queryMapFeatures;
/**
 * Sets the current map view.
 *
 * NOTE: Subscribing components are not guaranteed to receive every new view change sent by
 * calling this method. For purposes of optimization, views passed in that are "close enough"
 * to the current view are not dispatched to subscribing components.
 *
 * @export
 * @param {IMapView} view The map view to set
 * @returns {ReduxThunkedAction}
 */
function setCurrentView(view) {
    return function (dispatch, getState) {
        var _a, _b;
        // HACK-y:
        //
        // We don't want to dispatch SET_VIEW actions with redundant view
        // states if the one we're about to dispatch is the same as the
        // previous one
        var state = getState();
        var currentView = (0, common_1.getCurrentView)(state);
        var newView = (0, tslib_1.__assign)({}, view);
        var mapName = state.config.activeMapName;
        var dispatchThis = true;
        if (currentView && mapName) {
            //If the current map is tiled (has finite scales), "snap" the view's scale
            //to the closest applicable finite scale then do the test 
            var mapState = state.mapState[mapName];
            var fs = (_b = (_a = mapState === null || mapState === void 0 ? void 0 : mapState.mapguide) === null || _a === void 0 ? void 0 : _a.runtimeMap) === null || _b === void 0 ? void 0 : _b.FiniteDisplayScale;
            if (fs && fs.length > 0) {
                var fi = (0, number_1.getFiniteScaleIndexForScale)(fs, newView.scale);
                newView.scale = fs[fi];
            }
            if ((0, viewer_state_1.areViewsCloseToEqual)(currentView, newView)) {
                dispatchThis = false;
            }
        }
        if (dispatchThis && mapName) {
            dispatch({
                type: actions_1.ActionType.MAP_SET_VIEW,
                payload: {
                    mapName: mapName,
                    view: newView
                }
            });
        }
    };
}
exports.setCurrentView = setCurrentView;
/**
 * Sends a map resized notification
 *
 * @export
 * @param {number} width
 * @param {number} height
 * @returns {IMapResizedAction}
 */
function mapResized(width, height) {
    return {
        type: actions_1.ActionType.MAP_RESIZED,
        payload: {
            width: width,
            height: height
        }
    };
}
exports.mapResized = mapResized;
/**
 * Sets the selection set for the given map
 *
 * @param mapName
 * @param selectionSet
 * @returns
 *
 * @since 0.14 Fixed up the type of selectionSet parameter
 */
function setSelection(mapName, selectionSet) {
    return {
        type: actions_1.ActionType.MAP_SET_SELECTION,
        payload: {
            mapName: mapName,
            selection: selectionSet
        }
    };
}
exports.setSelection = setSelection;
/**
 * Invokes the specified command
 *
 * @export
 * @param {ICommand} cmd
 * @param {*} [parameters]
 * @returns {ReduxThunkedAction}
 */
function invokeCommand(cmd, parameters) {
    return function (dispatch, getState) {
        return cmd.invoke(dispatch, getState, (0, runtime_1.getViewer)(), parameters);
    };
}
exports.invokeCommand = invokeCommand;
/**
 * Sets the busy count of the viewer. A value greater than zero signifies that the viewer is currently
 * busy performing various actions (eg. Loading/Rendering the current map image)
 *
 * @export
 * @param {number} busyCount The current busy count
 * @returns {IMapSetBusyCountAction}
 */
function setBusyCount(busyCount) {
    return {
        type: actions_1.ActionType.MAP_SET_BUSY_COUNT,
        payload: busyCount
    };
}
exports.setBusyCount = setBusyCount;
/**
 * Set the given external base layer as the active base layer
 *
 * @export
 * @param {string} mapName The name of the current runtime map
 * @param {string} layerName The name of the external base layer to set as active
 * @returns
 */
function setBaseLayer(mapName, layerName) {
    return {
        type: actions_1.ActionType.MAP_SET_BASE_LAYER,
        payload: {
            mapName: mapName,
            layerName: layerName
        }
    };
}
exports.setBaseLayer = setBaseLayer;
/**
 * Sets the view scale
 *
 * @export
 * @param {string} mapName The name of the current runtime map
 * @param {number} scale The scale to set
 * @returns
 */
function setScale(mapName, scale) {
    var viewer = (0, runtime_1.getViewer)();
    var resolution;
    if (viewer) {
        resolution = viewer.scaleToResolution(scale);
    }
    return {
        type: actions_1.ActionType.MAP_SET_SCALE,
        payload: {
            mapName: mapName,
            scale: scale,
            resolution: resolution
        }
    };
}
exports.setScale = setScale;
/**
 * Sets the current mouse coordinates
 *
 * @export
 * @param {string} mapName The name of the current runtime map
 * @param {*} coord The current mouse coordinates
 * @returns
 */
function setMouseCoordinates(mapName, coord) {
    return {
        type: actions_1.ActionType.UPDATE_MOUSE_COORDINATES,
        payload: {
            mapName: mapName,
            coord: coord
        }
    };
}
exports.setMouseCoordinates = setMouseCoordinates;
/**
 * Set the transparency for the given OL layer
 *
 * @export
 * @param {string} mapName The name of the current runtime map
 * @param {string} layerName The name of the OL layer
 * @param {number} opacity A value between 0 and 1. 1 - Fully Opaque, 0 - Fully Transparent
 * @returns
 */
function setLayerTransparency(mapName, layerName, opacity) {
    return {
        type: actions_1.ActionType.MAP_SET_LAYER_TRANSPARENCY,
        payload: {
            mapName: mapName,
            layerName: layerName,
            opacity: opacity
        }
    };
}
exports.setLayerTransparency = setLayerTransparency;
/**
 * Sets the units for the map view size display
 *
 * @export
 * @param {UnitOfMeasure} unit
 * @returns {IMapSetViewSizeUnitsAction}
 */
function setViewSizeUnits(unit) {
    return {
        type: actions_1.ActionType.MAP_SET_VIEW_SIZE_UNITS,
        payload: unit
    };
}
exports.setViewSizeUnits = setViewSizeUnits;
/**
 * Goes back to the previous view on the navigation stack
 *
 * @export
 * @param {string} mapName The name of the current runtime map
 * @returns
 */
function previousView(mapName) {
    return {
        type: actions_1.ActionType.MAP_PREVIOUS_VIEW,
        payload: {
            mapName: mapName
        }
    };
}
exports.previousView = previousView;
/**
 * Goes to the next view on the navigation stack
 *
 * @export
 * @param {string} mapName The name of the current runtime amp
 * @returns
 */
function nextView(mapName) {
    return {
        type: actions_1.ActionType.MAP_NEXT_VIEW,
        payload: {
            mapName: mapName
        }
    };
}
exports.nextView = nextView;
/**
 * Sets the active map tool
 *
 * @export
 * @param {ActiveMapTool} tool The active map tool command
 * @returns
 */
function setActiveTool(tool) {
    return {
        type: actions_1.ActionType.MAP_SET_ACTIVE_TOOL,
        payload: tool
    };
}
exports.setActiveTool = setActiveTool;
/**
 * Sets the active runtime map
 *
 * @export
 * @param {string} mapName The name of the runtime map to set as active
 * @returns
 */
function setActiveMap(mapName) {
    return {
        type: actions_1.ActionType.MAP_SET_ACTIVE_MAP,
        payload: mapName
    };
}
exports.setActiveMap = setActiveMap;
/**
 * Sets whether feature tooltips (aka. Map Tips) are enabled
 *
 * @export
 * @param {boolean} enabled
 * @returns
 */
function setFeatureTooltipsEnabled(enabled) {
    return {
        type: actions_1.ActionType.MAP_SET_MAPTIP,
        payload: enabled
    };
}
exports.setFeatureTooltipsEnabled = setFeatureTooltipsEnabled;
/**
 * Sets whether the select tool can pan while dragging
 *
 * @param enabled
 * @since 0.14.2
 */
function enableSelectDragPan(enabled) {
    return {
        type: actions_1.ActionType.MAP_ENABLE_SELECT_DRAGPAN,
        payload: enabled
    };
}
exports.enableSelectDragPan = enableSelectDragPan;
/**
 * Sets whether manual feature tooltips (aka. Map Tips) are enabled
 *
 * @export
 * @param {boolean} enabled
 * @returns
 */
function setManualFeatureTooltipsEnabled(enabled) {
    return {
        type: actions_1.ActionType.MAP_SET_MANUAL_MAPTIP,
        payload: enabled
    };
}
exports.setManualFeatureTooltipsEnabled = setManualFeatureTooltipsEnabled;
/**
 * Sets the rotation of the current view
 *
 * @export
 * @param {number} rotation
 * @returns
 */
function setViewRotation(rotation) {
    return {
        type: actions_1.ActionType.MAP_SET_VIEW_ROTATION,
        payload: rotation
    };
}
exports.setViewRotation = setViewRotation;
/**
 * Sets whether view rotation is enabled or not
 *
 * @export
 * @param {boolean} enabled
 */
function setViewRotationEnabled(enabled) {
    return {
        type: actions_1.ActionType.MAP_SET_VIEW_ROTATION_ENABLED,
        payload: enabled
    };
}
exports.setViewRotationEnabled = setViewRotationEnabled;
/**
 * Shows the selected feature on the map
 *
 * @export
 * @param {string} mapName
 * @param {string} layerId
 * @param {string} selectionKey
 * @returns {IShowSelectedFeatureAction}
 */
function showSelectedFeature(mapName, layerId, selectionKey) {
    return {
        type: actions_1.ActionType.MAP_SHOW_SELECTED_FEATURE,
        payload: {
            mapName: mapName,
            layerId: layerId,
            selectionKey: selectionKey
        }
    };
}
exports.showSelectedFeature = showSelectedFeature;
/**
 * NOTE: Dispatching this action does not add the layer to the map. This is a means to notify others
 * that a new layer has been added. It is expected to be dispatched by any component that is managing
 * layers
 *
 * @export
 * @param {string} mapName
 * @param {ILayerInfo} layer
 * @param {IVectorLayerStyle} [defaultStyle]
 * @returns {IAddedLayerAction}
 * @since 0.13
 * @since 0.14 defaultStyle argument changed to IVectorLayerStyle
 */
function mapLayerAdded(mapName, layer, defaultStyle) {
    return {
        type: actions_1.ActionType.LAYER_ADDED,
        payload: {
            mapName: mapName,
            layer: layer,
            defaultStyle: defaultStyle
        }
    };
}
exports.mapLayerAdded = mapLayerAdded;
/**
 * An action that signals the externa layers for the given map name is ready. This action
 * is only dispatched when there is no external layers to initially add
 *
 * @param mapName
 * @since 0.14
 */
function externalLayersReady(mapName) {
    return {
        type: actions_1.ActionType.EXTERNAL_LAYERS_READY,
        payload: {
            mapName: mapName
        }
    };
}
exports.externalLayersReady = externalLayersReady;
/**
 * Removes a given external layer for the given map
 *
 * @export
 * @param {string} mapName
 * @param {string} layerName
 * @returns {IRemoveLayerAction}
 * @since 0.13
 */
function removeMapLayer(mapName, layerName) {
    return {
        type: actions_1.ActionType.REMOVE_LAYER,
        payload: {
            mapName: mapName,
            layerName: layerName
        }
    };
}
exports.removeMapLayer = removeMapLayer;
/**
 * Sets the display order index for the given external layer for the given map
 *
 * @export
 * @param {string} mapName
 * @param {string} layerName
 * @param {number} index
 * @returns {ISetLayerIndexAction}
 * @since 0.13
 */
function setMapLayerIndex(mapName, layerName, index) {
    return {
        type: actions_1.ActionType.SET_LAYER_INDEX,
        payload: {
            mapName: mapName,
            layerName: layerName,
            index: index
        }
    };
}
exports.setMapLayerIndex = setMapLayerIndex;
/**
 * Sets the opacity for the given external layer for the given map
 *
 * @export
 * @param {string} mapName
 * @param {string} layerName
 * @param {number} opacity
 * @returns {ISetLayerOpacityAction}
 * @since 0.13
 */
function setMapLayerOpacity(mapName, layerName, opacity) {
    return {
        type: actions_1.ActionType.SET_LAYER_OPACITY,
        payload: {
            mapName: mapName,
            layerName: layerName,
            opacity: opacity
        }
    };
}
exports.setMapLayerOpacity = setMapLayerOpacity;
/**
 * Sets the heatmap blur for the given external heatmap layer for the given map
 *
 * @param mapName
 * @param layerName
 * @param blur
 */
function setHeatmapLayerBlur(mapName, layerName, blur) {
    return {
        type: actions_1.ActionType.SET_HEATMAP_LAYER_BLUR,
        payload: {
            mapName: mapName,
            layerName: layerName,
            blur: blur
        }
    };
}
exports.setHeatmapLayerBlur = setHeatmapLayerBlur;
/**
 * Sets the heatmap radius for the given external heatmap layer for the given map
 *
 * @param mapName
 * @param layerName
 * @param radius
 */
function setHeatmapLayerRadius(mapName, layerName, radius) {
    return {
        type: actions_1.ActionType.SET_HEATMAP_LAYER_RADIUS,
        payload: {
            mapName: mapName,
            layerName: layerName,
            radius: radius
        }
    };
}
exports.setHeatmapLayerRadius = setHeatmapLayerRadius;
/**
 * Sets the visibility for the given external layer for the given map
 *
 * @export
 * @param {string} mapName
 * @param {string} layerName
 * @param {boolean} visible
 * @returns {ISetLayerVisibilityAction}
 * @since 0.13
 */
function setMapLayerVisibility(mapName, layerName, visible) {
    return {
        type: actions_1.ActionType.SET_LAYER_VISIBILITY,
        payload: {
            mapName: mapName,
            layerName: layerName,
            visible: visible
        }
    };
}
exports.setMapLayerVisibility = setMapLayerVisibility;
/**
 * Sets the vector style for the given external layer for the given map
 *
 * @export
 * @param {string} mapName
 * @param {string} layerName
 * @param {IVectorLayerStyle} style
 * @param {VectorStyleSource} which
 * @returns {ISetMapLayerVectorStyle}
 * @since 0.13
 * @since 0.14 style and which arguments changed to IVectorLayerStyle
 */
function setMapLayerVectorStyle(mapName, layerName, style, which) {
    return {
        type: actions_1.ActionType.SET_LAYER_VECTOR_STYLE,
        payload: {
            mapName: mapName,
            layerName: layerName,
            style: style,
            which: which
        }
    };
}
exports.setMapLayerVectorStyle = setMapLayerVectorStyle;
/**
 * Adds a busy worker for the given external layer for the given map
 *
 * @export
 * @param {string} mapName
 * @param {string} layerName
 * @returns {IAddMapLayerBusyWorkerAction}
 * @since 0.13
 */
function addMapLayerBusyWorker(mapName, layerName) {
    return {
        type: actions_1.ActionType.ADD_LAYER_BUSY_WORKER,
        payload: {
            mapName: mapName,
            layerName: layerName
        }
    };
}
exports.addMapLayerBusyWorker = addMapLayerBusyWorker;
/**
 * Removes a busy worker for the given external layer for the given map
 *
 * @export
 * @param {string} mapName
 * @param {string} layerName
 * @returns {IRemoveMapLayerBusyWorkerAction}
 * @since 0.13
 */
function removeMapLayerBusyWorker(mapName, layerName) {
    return {
        type: actions_1.ActionType.REMOVE_LAYER_BUSY_WORKER,
        payload: {
            mapName: mapName,
            layerName: layerName
        }
    };
}
exports.removeMapLayerBusyWorker = removeMapLayerBusyWorker;
/**
 * Adds a feature to the client selection set for the given map
 *
 * @param mapName
 * @param layerName
 * @param feature
 * @returns
 * @since 0.14
 */
function addClientSelectedFeature(mapName, layerName, feature) {
    return {
        type: actions_1.ActionType.MAP_ADD_CLIENT_SELECTED_FEATURE,
        payload: {
            mapName: mapName,
            layerName: layerName,
            feature: feature
        }
    };
}
exports.addClientSelectedFeature = addClientSelectedFeature;
/**
 * Clears the client selection set for the given map
 *
 * @param mapName
 * @since 0.14
 */
function clearClientSelection(mapName) {
    return {
        type: actions_1.ActionType.MAP_CLEAR_CLIENT_SELECTION,
        payload: {
            mapName: mapName
        }
    };
}
exports.clearClientSelection = clearClientSelection;


/***/ }),

/***/ "./src/actions/modal.ts":
/*!******************************!*\
  !*** ./src/actions/modal.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hideModal = exports.showModalUrl = exports.showModalComponent = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
/**
 * Displays the specified component in a modal dialog
 *
 * @export
 * @param {*} options Modal dialog display options
 * @returns {IShowComponentInModalAction}
 */
function showModalComponent(options) {
    return {
        type: actions_1.ActionType.MODAL_SHOW_COMPONENT,
        payload: (0, tslib_1.__assign)({}, options)
    };
}
exports.showModalComponent = showModalComponent;
/**
 * Displays the specified URL in a modal dialog
 *
 * @export
 * @param {*} options Modal dialog display options
 * @returns {IShowModalUrlAction}
 */
function showModalUrl(options) {
    return {
        type: actions_1.ActionType.MODAL_SHOW_URL,
        payload: (0, tslib_1.__assign)({}, options)
    };
}
exports.showModalUrl = showModalUrl;
/**
 * Hides an open modal dialog
 *
 * @export
 * @param name The name of the modal to hide
 * @returns {ICloseModalAction}
 */
function hideModal(name) {
    return {
        type: actions_1.ActionType.MODAL_CLOSE,
        payload: name
    };
}
exports.hideModal = hideModal;


/***/ }),

/***/ "./src/actions/taskpane.ts":
/*!*********************************!*\
  !*** ./src/actions/taskpane.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pushUrl = exports.goForward = exports.goBack = exports.goHome = void 0;
var error_1 = __webpack_require__(/*! ../api/error */ "./src/api/error.ts");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
/**
 * Go back to the initial task URL
 *
 * @export
 * @returns {ReduxThunkedAction}
 */
function goHome() {
    return function (dispatch, getState) {
        var initUrl = getState().taskpane.initialUrl;
        if (initUrl != null) {
            dispatch({
                type: actions_1.ActionType.TASK_PANE_HOME
            });
        }
        else {
            throw new error_1.MgError("Case not handled yet: Home action when no initial task URL set");
        }
    };
}
exports.goHome = goHome;
/**
 * Go back one entry in the task pane navigation history
 *
 * @export
 * @returns
 */
function goBack() {
    return {
        type: actions_1.ActionType.TASK_PANE_BACK
    };
}
exports.goBack = goBack;
/**
 * Go forward one entry in the task pane navigation history
 *
 * @export
 * @returns
 */
function goForward() {
    return {
        type: actions_1.ActionType.TASK_PANE_FORWARD
    };
}
exports.goForward = goForward;
/**
 * Pushes the given URL to the task pane navigation history stack
 *
 * @export
 * @param {string} url
 * @param {boolean} [silent]
 * @returns
 */
function pushUrl(url, silent) {
    return {
        type: actions_1.ActionType.TASK_PANE_PUSH_URL,
        payload: {
            url: url,
            silent: silent
        }
    };
}
exports.pushUrl = pushUrl;


/***/ }),

/***/ "./src/actions/template.ts":
/*!*********************************!*\
  !*** ./src/actions/template.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setLegendVisibility = exports.setSelectionPanelVisibility = exports.setTaskPaneVisibility = exports.setElementStates = void 0;
/**
 * template.ts
 *
 * Actions to support fusion templates
 */
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
function setElementStates(states) {
    return {
        type: actions_1.ActionType.FUSION_SET_ELEMENT_STATE,
        payload: states
    };
}
exports.setElementStates = setElementStates;
function setTaskPaneVisibility(visible) {
    return {
        type: actions_1.ActionType.FUSION_SET_TASK_PANE_VISIBILITY,
        payload: visible
    };
}
exports.setTaskPaneVisibility = setTaskPaneVisibility;
function setSelectionPanelVisibility(visible) {
    return {
        type: actions_1.ActionType.FUSION_SET_SELECTION_PANEL_VISIBILITY,
        payload: visible
    };
}
exports.setSelectionPanelVisibility = setSelectionPanelVisibility;
/*
export function setOverviewMapVisibility(visible: boolean): ReduxAction {
    return {
        type: ActionType.FUSION_SET_OVERVIEW_MAP_VISIBILITY,
        payload: visible
    };
}
*/
function setLegendVisibility(visible) {
    return {
        type: actions_1.ActionType.FUSION_SET_LEGEND_VISIBILITY,
        payload: visible
    };
}
exports.setLegendVisibility = setLegendVisibility;


/***/ }),

/***/ "./src/api/base-layer-set.ts":
/*!***********************************!*\
  !*** ./src/api/base-layer-set.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @module
 * @hidden
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseLayerSetOL = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var olHas = (0, tslib_1.__importStar)(__webpack_require__(/*! ol/has */ "./node_modules/ol/has.js"));
/**
 * @hidden
 */
var BaseLayerSetOL = /** @class */ (function () {
    function BaseLayerSetOL(externalBaseLayersGroup, projection, dpi, extent, inPerUnit, view) {
        this.externalBaseLayersGroup = externalBaseLayersGroup;
        this.projection = projection;
        this.dpi = dpi;
        this.extent = extent;
        this.inPerUnit = inPerUnit;
        this.view = view;
    }
    BaseLayerSetOL.prototype.getMetersPerUnit = function () {
        return this.inPerUnit / 39.37;
    };
    BaseLayerSetOL.prototype.scaleToResolution = function (scale) {
        return (scale / this.inPerUnit / this.dpi) * olHas.DEVICE_PIXEL_RATIO;
    };
    BaseLayerSetOL.prototype.resolutionToScale = function (resolution) {
        return (resolution * this.dpi * this.inPerUnit) / olHas.DEVICE_PIXEL_RATIO;
    };
    BaseLayerSetOL.prototype.updateExternalBaseLayers = function (externalBaseLayers) {
        if (this.externalBaseLayersGroup) {
            var layers = this.externalBaseLayersGroup.getLayers();
            layers.forEach(function (l) {
                var match = (externalBaseLayers || []).filter(function (el) { return el.name === l.get("title"); });
                if (match.length == 1) {
                    l.setVisible(!!match[0].visible);
                }
                else {
                    l.setVisible(false);
                }
            });
        }
    };
    /**
     *
     * @virtual
     * @param {RefreshMode} mode
     * @memberof BaseLayerSetOL
     */
    BaseLayerSetOL.prototype.refreshMap = function (mode) { };
    return BaseLayerSetOL;
}());
exports.BaseLayerSetOL = BaseLayerSetOL;


/***/ }),

/***/ "./src/api/bootstrap.ts":
/*!******************************!*\
  !*** ./src/api/bootstrap.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bootstrap = void 0;
/**
 * Sets up key dependencies needed by the viewer. This only needs to be called on the entry point of your custom viewer bundle
 *
 * @export
 */
function bootstrap() {
}
exports.bootstrap = bootstrap;


/***/ }),

/***/ "./src/api/builders/deArrayify.ts":
/*!****************************************!*\
  !*** ./src/api/builders/deArrayify.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getActiveSelectedFeatureXml = exports.buildSelectionXml = exports.deArrayify = exports.isQueryMapFeaturesResponse = exports.isSiteVersion = exports.isTileSet = exports.isMapDef = exports.isAppDef = exports.isWebLayout = void 0;
/**
 * deArrayify.ts
 *
 * This module provides JSON sanitization of JSON responses from the mapagent
 *
 * Being a transformation of the XML form, and taking a lowest-common-denominator
 * approach to JSON conversion, the JSON responses from MapGuide are un-wieldy to
 * use from the client-side due to:
 *
 *  a) All properties being arrays
 *  b) All property values being strings
 *
 * These functions help "clean" those responses to be of the form we expect (and prefer)
 */
var error_1 = __webpack_require__(/*! ../error */ "./src/api/error.ts");
var constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
function buildPropertyGetter() {
    return function (el, name, type) {
        if (type === void 0) { type = "string"; }
        return tryGetAsProperty(el, name, type);
    };
}
function tryGetAsProperty(el, name, type) {
    if (type === void 0) { type = "string"; }
    if (!el[name]) {
        return null;
    }
    else if (el[name].length === 1) {
        var val = el[name][0];
        switch (type) {
            case "int":
                return parseInt(val, 10);
            case "float":
                return parseFloat(val);
            case "boolean":
                return val.toLowerCase() === "true";
            default:
                return val;
        }
    }
}
function deArrayifyRules(rules) {
    var getter = buildPropertyGetter();
    return rules.map(function (r) {
        var rule = {
            LegendLabel: getter(r, "LegendLabel"),
            Filter: getter(r, "Filter"),
            Icon: getter(r, "Icon")
        };
        return rule;
    });
}
function deArrayifyFeatureStyles(fts) {
    if (!fts) {
        return [];
    }
    var getter = buildPropertyGetter();
    return fts.map(function (ft) {
        var featureStyle = {
            Type: getter(ft, "Type", "int"),
            Rule: deArrayifyRules(ft.Rule)
        };
        return featureStyle;
    });
}
function deArrayifyScaleRanges(scales) {
    if (!scales) { //Happens with raster layers (this is probably a bug in CREATERUNTIMEMAP)
        var defaultRange = {
            MinScale: 0,
            MaxScale: constants_1.MDF_INFINITY,
            FeatureStyle: []
        };
        return [defaultRange];
    }
    var getter = buildPropertyGetter();
    return scales.map(function (sc) {
        var scale = {
            MinScale: getter(sc, "MinScale", "float"),
            MaxScale: getter(sc, "MaxScale", "float"),
            FeatureStyle: deArrayifyFeatureStyles(sc.FeatureStyle)
        };
        return scale;
    });
}
function deArrayifyFeatureSourceInfo(fs) {
    if (!fs || fs.length !== 1) {
        return undefined;
    }
    var getter = buildPropertyGetter();
    return {
        ResourceId: getter(fs[0], "ResourceId"),
        ClassName: getter(fs[0], "ClassName"),
        Geometry: getter(fs[0], "Geometry")
    };
}
function deArrayifyLayers(layers) {
    if (!layers)
        return layers;
    var getter = buildPropertyGetter();
    return layers.map(function (lyr) {
        var layer = {
            Type: getter(lyr, "Type", "int"),
            Selectable: getter(lyr, "Selectable", "boolean"),
            LayerDefinition: getter(lyr, "LayerDefinition"),
            Name: getter(lyr, "Name"),
            LegendLabel: getter(lyr, "LegendLabel"),
            ObjectId: getter(lyr, "ObjectId"),
            ParentId: getter(lyr, "ParentId"),
            DisplayInLegend: getter(lyr, "DisplayInLegend", "boolean"),
            ExpandInLegend: getter(lyr, "ExpandInLegend", "boolean"),
            Visible: getter(lyr, "Visible", "boolean"),
            ActuallyVisible: getter(lyr, "ActuallyVisible", "boolean"),
            FeatureSource: deArrayifyFeatureSourceInfo(lyr.FeatureSource),
            ScaleRange: deArrayifyScaleRanges(lyr.ScaleRange)
        };
        //This is either a raster or drawing layer, in this case disregard the
        //selectability flag (and set it to false). This is to prevent false positive
        //errors trying to do tooltip/selections against raster/drawing layers
        if (!lyr.ScaleRange) {
            layer.Selectable = false;
        }
        return layer;
    });
}
function deArrayifyGroups(groups) {
    if (!groups)
        return undefined;
    var getter = buildPropertyGetter();
    return groups.map(function (grp) {
        var group = {
            Type: getter(grp, "Type", "int"),
            Name: getter(grp, "Name"),
            LegendLabel: getter(grp, "LegendLabel"),
            ObjectId: getter(grp, "ObjectId"),
            ParentId: getter(grp, "ParentId"),
            DisplayInLegend: getter(grp, "DisplayInLegend", "boolean"),
            ExpandInLegend: getter(grp, "ExpandInLegend", "boolean"),
            Visible: getter(grp, "Visible", "boolean"),
            ActuallyVisible: getter(grp, "ActuallyVisible", "boolean")
        };
        return group;
    });
}
function deArrayifyCoordinateSystem(cs) {
    if (!cs || cs.length !== 1) {
        throw new error_1.MgError("Malformed input. Expected CoordinateSystem element");
    }
    var getter = buildPropertyGetter();
    var res = {
        Wkt: getter(cs[0], "Wkt"),
        MentorCode: getter(cs[0], "MentorCode"),
        EpsgCode: getter(cs[0], "EpsgCode"),
        MetersPerUnit: getter(cs[0], "MetersPerUnit", "float")
    };
    return res;
}
function deArrayifyCoordinate(coord) {
    if (!coord || coord.length !== 1) {
        throw new error_1.MgError("Malformed input. Expected coordinate array");
    }
    var getter = buildPropertyGetter();
    return {
        X: getter(coord[0], "X", "float"),
        Y: getter(coord[0], "Y", "float")
    };
}
function deArrayifyExtents(extents) {
    if (!extents || extents.length !== 1) {
        throw new error_1.MgError("Malformed input. Expected extent element");
    }
    var env = {
        LowerLeftCoordinate: deArrayifyCoordinate(extents[0].LowerLeftCoordinate),
        UpperRightCoordinate: deArrayifyCoordinate(extents[0].UpperRightCoordinate)
    };
    return env;
}
function deArrayifyFiniteDisplayScales(fds) {
    if (!fds)
        return undefined;
    return fds.map(parseFloat);
}
function deArrayifyRuntimeMap(json) {
    var root = json;
    var getter = buildPropertyGetter();
    var rtMap = {
        SessionId: getter(root, "SessionId"),
        SiteVersion: getter(root, "SiteVersion"),
        Name: getter(root, "Name"),
        MapDefinition: getter(root, "MapDefinition"),
        TileSetDefinition: getter(root, "TileSetDefinition"),
        TileWidth: getter(root, "TileWidth", "int"),
        TileHeight: getter(root, "TileHeight", "int"),
        BackgroundColor: getter(root, "BackgroundColor"),
        DisplayDpi: getter(root, "DisplayDpi", "int"),
        IconMimeType: getter(root, "IconMimeType"),
        CoordinateSystem: deArrayifyCoordinateSystem(root.CoordinateSystem),
        Extents: deArrayifyExtents(root.Extents),
        Group: deArrayifyGroups(root.Group),
        Layer: deArrayifyLayers(root.Layer),
        FiniteDisplayScale: deArrayifyFiniteDisplayScales(root.FiniteDisplayScale)
    };
    return rtMap;
}
function deArrayifyFeatureSetClass(json) {
    var root = json;
    var getter = buildPropertyGetter();
    if (root.length != 1) {
        throw new error_1.MgError("Malformed input. Expected Class element");
    }
    var cls = {
        "@id": getter(root[0], "@id"),
        ID: root[0].ID
    };
    return cls;
}
function deArrayifyFeatureSetLayers(json) {
    var getter = buildPropertyGetter();
    return (json || []).map(function (root) {
        var layer = {
            "@id": getter(root, "@id"),
            "@name": getter(root, "@name"),
            Class: deArrayifyFeatureSetClass(root.Class)
        };
        return layer;
    });
}
function deArrayifyFeatureSet(json) {
    var root = json;
    if (root == null || root.length != 1) {
        return undefined;
    }
    var fs = {
        Layer: deArrayifyFeatureSetLayers(root[0].Layer)
    };
    return fs;
}
function deArrayifyInlineSelectionImage(json) {
    var root = json;
    if (root == null || root.length != 1) {
        return undefined;
    }
    var getter = buildPropertyGetter();
    var img = {
        MimeType: getter(root[0], "MimeType"),
        Content: getter(root[0], "Content")
    };
    return img;
}
function deArrayifyFeatureProperties(json) {
    var getter = buildPropertyGetter();
    return (json || []).map(function (root) {
        var prop = {
            Name: getter(root, "Name"),
            Value: getter(root, "Value")
        };
        return prop;
    });
}
function deArrayifyFeatures(json) {
    var getter = buildPropertyGetter();
    return (json || []).map(function (root) {
        var feat = {
            Bounds: getter(root, "Bounds"),
            Property: deArrayifyFeatureProperties(root.Property),
            SelectionKey: getter(root, "SelectionKey")
        };
        return feat;
    });
}
function deArrayifyLayerMetadataProperties(json) {
    var getter = buildPropertyGetter();
    return (json || []).map(function (root) {
        var prop = {
            DisplayName: getter(root, "DisplayName"),
            Name: getter(root, "Name"),
            Type: getter(root, "Type", "int")
        };
        return prop;
    });
}
function deArrayifyLayerMetadata(json) {
    var root = json;
    //NOTE: root could be null if the layer selected has no properties beyond id/geom
    if (root == null || root.length != 1) {
        return undefined;
    }
    var meta = {
        Property: deArrayifyLayerMetadataProperties(root[0].Property)
    };
    return meta;
}
function deArrayifySelectedLayer(json) {
    var getter = buildPropertyGetter();
    return (json || []).map(function (root) {
        var layer = {
            "@id": getter(root, "@id"),
            "@name": getter(root, "@name"),
            Feature: deArrayifyFeatures(root.Feature),
            LayerMetadata: deArrayifyLayerMetadata(root.LayerMetadata)
        };
        return layer;
    });
}
function deArrayifySelectedFeatures(json) {
    var root = json;
    if (root == null || root.length != 1) {
        return undefined;
    }
    var sf = {
        SelectedLayer: deArrayifySelectedLayer(root[0].SelectedLayer)
    };
    return sf;
}
function deArrayifyFeatureInformation(json) {
    var root = json;
    var getter = buildPropertyGetter();
    var resp = {
        FeatureSet: deArrayifyFeatureSet(root.FeatureSet),
        Hyperlink: getter(root, "Hyperlink"),
        InlineSelectionImage: deArrayifyInlineSelectionImage(root.InlineSelectionImage),
        SelectedFeatures: deArrayifySelectedFeatures(root.SelectedFeatures),
        Tooltip: getter(root, "Tooltip")
    };
    return resp;
}
function deArrayifyWebLayoutControl(json) {
    var root = json;
    if (root == null || root.length != 1) {
        throw new error_1.MgError("Malformed input. Expected control element");
    }
    var getter = buildPropertyGetter();
    var control = {
        Visible: getter(root[0], "Visible", "boolean")
    };
    return control;
}
function deArrayifyWebLayoutInfoPane(json) {
    var root = json;
    if (root == null || root.length != 1) {
        throw new error_1.MgError("Malformed input. Expected InformationPane element");
    }
    var getter = buildPropertyGetter();
    var infoPane = {
        Visible: getter(root[0], "Visible", "boolean"),
        Width: getter(root[0], "Width", "int"),
        LegendVisible: getter(root[0], "LegendVisible", "boolean"),
        PropertiesVisible: getter(root[0], "PropertiesVisible", "boolean")
    };
    return infoPane;
}
function deArrayifyWebLayoutInitialView(json) {
    var root = json;
    if (root == null || root.length != 1) {
        return undefined;
    }
    var getter = buildPropertyGetter();
    var view = {
        CenterX: getter(root[0], "CenterX", "float"),
        CenterY: getter(root[0], "CenterY", "float"),
        Scale: getter(root[0], "Scale", "float")
    };
    return view;
}
function deArrayifyWebLayoutMap(json) {
    var root = json;
    if (root == null || root.length != 1) {
        throw new error_1.MgError("Malformed input. Expected Map element");
    }
    var getter = buildPropertyGetter();
    var map = {
        ResourceId: getter(root[0], "ResourceId"),
        InitialView: deArrayifyWebLayoutInitialView(root[0].InitialView),
        HyperlinkTarget: getter(root[0], "HyperlinkTarget"),
        HyperlinkTargetFrame: getter(root[0], "HyperlinkTargetFrame")
    };
    return map;
}
function deArrayifyTaskButton(json) {
    var root = json;
    if (root == null || root.length != 1) {
        throw new error_1.MgError("Malformed input. Expected TaskButton element");
    }
    var getter = buildPropertyGetter();
    var button = {
        Name: getter(root[0], "Name"),
        Tooltip: getter(root[0], "Tooltip"),
        Description: getter(root[0], "Description"),
        ImageURL: getter(root[0], "ImageURL"),
        DisabledImageURL: getter(root[0], "DisabledImageURL")
    };
    return button;
}
function deArrayifyWebLayoutTaskBar(json) {
    var root = json;
    if (root == null || root.length != 1) {
        throw new error_1.MgError("Malformed input. Expected TaskBar element");
    }
    var getter = buildPropertyGetter();
    var taskbar = {
        Visible: getter(root[0], "Visible", "boolean"),
        Home: deArrayifyTaskButton(root[0].Home),
        Forward: deArrayifyTaskButton(root[0].Forward),
        Back: deArrayifyTaskButton(root[0].Back),
        Tasks: deArrayifyTaskButton(root[0].Tasks),
        MenuButton: []
    };
    if (root[0].MenuButton) {
        for (var _i = 0, _a = root[0].MenuButton; _i < _a.length; _i++) {
            var mb = _a[_i];
            taskbar.MenuButton.push(deArrayifyUIItem(mb));
        }
    }
    return taskbar;
}
function deArrayifyWebLayoutTaskPane(json) {
    var root = json;
    if (root == null || root.length != 1) {
        throw new error_1.MgError("Malformed input. Expected TaskPane element");
    }
    var getter = buildPropertyGetter();
    var taskPane = {
        Visible: getter(root[0], "Visible", "boolean"),
        InitialTask: getter(root[0], "InitialTask"),
        Width: getter(root[0], "Width", "int"),
        TaskBar: deArrayifyWebLayoutTaskBar(root[0].TaskBar)
    };
    return taskPane;
}
function deArrayifyUIItem(json) {
    var root = json;
    var getter = buildPropertyGetter();
    var func = getter(root, "Function");
    //Wouldn't it be nice if we could incrementally build up a union type that then becomes a specific
    //type once certain properties are set?
    //
    //Well, that's currently not possible. So we have to resort to "any"
    var item = {
        Function: func
    };
    switch (func) {
        case "Command":
            item.Command = getter(root, "Command");
            break;
        case "Flyout":
            item.Label = getter(root, "Label");
            item.Tooltip = getter(root, "Tooltip");
            item.Description = getter(root, "Description");
            item.ImageURL = getter(root, "ImageURL");
            item.DisabledImageURL = getter(root, "DisabledImageURL");
            item.SubItem = [];
            for (var _i = 0, _a = root.SubItem; _i < _a.length; _i++) {
                var si = _a[_i];
                item.SubItem.push(deArrayifyUIItem(si));
            }
            break;
    }
    return item;
}
function deArrayifyItemContainer(json, name) {
    var root = json;
    if (root == null || root.length != 1) {
        throw new error_1.MgError("Malformed input. Expected container element");
    }
    var getter = buildPropertyGetter();
    var container = {};
    container[name] = [];
    for (var _i = 0, _a = root[0][name]; _i < _a.length; _i++) {
        var item = _a[_i];
        container[name].push(deArrayifyUIItem(item));
    }
    if (typeof (root[0].Visible) != 'undefined') {
        container.Visible = getter(root[0], "Visible", "boolean");
    }
    return container;
}
function deArrayifyWebLayoutSearchResultColumnSet(json) {
    var root = json;
    if (root == null || root.length != 1) {
        throw new error_1.MgError("Malformed input. Expected ResultColumns element");
    }
    var getter = buildPropertyGetter();
    var res = {
        Column: []
    };
    for (var _i = 0, _a = root[0].Column; _i < _a.length; _i++) {
        var col = _a[_i];
        res.Column.push({
            Name: getter(col, "Name"),
            Property: getter(col, "Property")
        });
    }
    return res;
}
function deArrayifyWebLayoutInvokeURLLayerSet(json) {
    var root = json;
    if (root == null || root.length != 1) {
        return undefined;
    }
    var layerset = {
        Layer: root[0].Layer
    };
    return layerset;
}
function deArrayifyWebLayoutParameterPairs(json) {
    var root = json;
    var pairs = [];
    if (!root) {
        return pairs;
    }
    var getter = buildPropertyGetter();
    for (var _i = 0, root_1 = root; _i < root_1.length; _i++) {
        var kvp = root_1[_i];
        pairs.push({
            Key: getter(kvp, "Key"),
            Value: getter(kvp, "Value")
        });
    }
    return pairs;
}
function deArrayifyCommand(json) {
    var root = json;
    var getter = buildPropertyGetter();
    var cmd = {
        "@xsi:type": getter(root, "@xsi:type"),
        Name: getter(root, "Name"),
        Label: getter(root, "Label"),
        Tooltip: getter(root, "Tooltip"),
        Description: getter(root, "Description"),
        ImageURL: getter(root, "ImageURL"),
        DisabledImageURL: getter(root, "DisabledImageURL"),
        TargetViewer: getter(root, "TargetViewer")
    };
    //Basic
    if (typeof (root.Action) != 'undefined') {
        cmd.Action = getter(root, "Action");
    }
    //Targeted
    if (typeof (root.Target) != 'undefined') {
        cmd.Target = getter(root, "Target");
    }
    if (typeof (root.TargetFrame) != 'undefined') {
        cmd.TargetFrame = getter(root, "TargetFrame");
    }
    //Search
    if (typeof (root.Layer) != 'undefined') {
        cmd.Layer = getter(root, "Layer");
        cmd.Prompt = getter(root, "Prompt");
        cmd.ResultColumns = deArrayifyWebLayoutSearchResultColumnSet(root.ResultColumns);
        cmd.Filter = getter(root, "Filter");
        cmd.MatchLimit = getter(root, "MatchLimit", "int");
    }
    //InvokeURL | Help
    if (typeof (root.URL) != 'undefined') {
        cmd.URL = getter(root, "URL");
    }
    if (typeof (root.DisableIfSelectionEmpty) != 'undefined') {
        cmd.LayerSet = deArrayifyWebLayoutInvokeURLLayerSet(root.LayerSet);
        cmd.AdditionalParameter = deArrayifyWebLayoutParameterPairs(root.AdditionalParameter);
        cmd.DisableIfSelectionEmpty = getter(root, "DisableIfSelectionEmpty", "boolean");
    }
    //InvokeScript
    if (typeof (root.Script) != 'undefined') {
        cmd.Script = getter(root, "Script");
    }
    return cmd;
}
function deArrayifyWebLayoutCommandSet(json) {
    var root = json;
    if (root == null || root.length != 1) {
        throw new error_1.MgError("Malformed input. Expected CommandSet element");
    }
    var set = {
        Command: []
    };
    if (root[0].Command) {
        for (var _i = 0, _a = root[0].Command; _i < _a.length; _i++) {
            var cmd = _a[_i];
            set.Command.push(deArrayifyCommand(cmd));
        }
    }
    return set;
}
function deArrayifyWebLayout(json) {
    var root = json;
    var getter = buildPropertyGetter();
    var resp = {
        Title: getter(root, "Title"),
        Map: deArrayifyWebLayoutMap(root.Map),
        EnablePingServer: getter(root, "EnablePingServer", "boolean"),
        SelectionColor: getter(root, "SelectionColor"),
        PointSelectionBuffer: getter(root, "PointSelectionBuffer", "int"),
        MapImageFormat: getter(root, "MapImageFormat"),
        SelectionImageFormat: getter(root, "SelectionImageFormat"),
        StartupScript: getter(root, "StartupScript"),
        ToolBar: deArrayifyItemContainer(root.ToolBar, "Button"),
        InformationPane: deArrayifyWebLayoutInfoPane(root.InformationPane),
        ContextMenu: deArrayifyItemContainer(root.ContextMenu, "MenuItem"),
        TaskPane: deArrayifyWebLayoutTaskPane(root.TaskPane),
        StatusBar: deArrayifyWebLayoutControl(root.StatusBar),
        ZoomControl: deArrayifyWebLayoutControl(root.ZoomControl),
        CommandSet: deArrayifyWebLayoutCommandSet(root.CommandSet)
    };
    return resp;
}
function deArrayifyMapGroup(json) {
    var root = json;
    if (root == null) {
        throw new error_1.MgError("Malformed input. Expected MapGroup element");
    }
    var getter = buildPropertyGetter();
    var mapGroup = {
        "@id": getter(root, "@id", "string"),
        InitialView: undefined,
        Map: []
    };
    if (root.InitialView) {
        var iview = root.InitialView[0];
        mapGroup.InitialView = {
            CenterX: getter(iview, "CenterX", "float"),
            CenterY: getter(iview, "CenterY", "float"),
            Scale: getter(iview, "Scale", "float")
        };
    }
    if (root.Map) {
        for (var _i = 0, _a = root.Map; _i < _a.length; _i++) {
            var m = _a[_i];
            mapGroup.Map.push({
                Type: getter(m, "Type", "string"),
                //SingleTile: getter(m, "SingleTile", "boolean"),
                Extension: deArrayifyExtension(m.Extension)
            });
        }
    }
    return mapGroup;
}
function deArrayifyMapSet(json) {
    var root = json;
    if (root == null || root.length != 1) {
        throw new error_1.MgError("Malformed input. Expected MapSet element");
    }
    var set = {
        MapGroup: []
    };
    if (root[0].MapGroup) {
        for (var _i = 0, _a = root[0].MapGroup; _i < _a.length; _i++) {
            var map = _a[_i];
            set.MapGroup.push(deArrayifyMapGroup(map));
        }
    }
    return set;
}
function deArrayifyContainerItems(json) {
    var items = [];
    var getter = buildPropertyGetter();
    if (json && json.length) {
        for (var _i = 0, json_1 = json; _i < json_1.length; _i++) {
            var i = json_1[_i];
            var func = getter(i, "Function", "string");
            switch (func) {
                case "Separator":
                    items.push({
                        Function: "Separator"
                    });
                    break;
                case "Widget":
                    items.push({
                        Function: "Widget",
                        Widget: getter(i, "Widget", "string")
                    });
                    break;
                case "Flyout":
                    items.push({
                        Function: "Flyout",
                        Label: getter(i, "Label", "string"),
                        Tooltip: getter(i, "Tooltip", "string"),
                        ImageUrl: getter(i, "ImageUrl", "string"),
                        ImageClass: getter(i, "ImageClass", "string"),
                        Item: deArrayifyContainerItems(i.Item || [])
                    });
                    break;
            }
        }
    }
    return items;
}
function deArrayifyContainer(json) {
    var containers = [];
    var getter = buildPropertyGetter();
    for (var _i = 0, json_2 = json; _i < json_2.length; _i++) {
        var c = json_2[_i];
        containers.push({
            Name: getter(c, "Name", "string"),
            Type: getter(c, "Type", "string"),
            //Position: getter(c, "Position", "string"),
            Extension: deArrayifyExtension(c.Extension),
            Item: deArrayifyContainerItems(c.Item)
        });
    }
    return containers;
}
function deArrayifyWidgets(json) {
    var widgets = [];
    for (var _i = 0, json_3 = json; _i < json_3.length; _i++) {
        var w = json_3[_i];
        if (w["@xsi:type"] == "UiWidgetType") {
            var uiw = deArrayifyUiWidget(w);
            widgets.push(uiw);
        }
        else {
            widgets.push(deArrayifyWidget(w));
        }
    }
    return widgets;
}
function deArrayifyWidget(json) {
    var root = json;
    if (root == null) {
        throw new error_1.MgError("Malformed input. Expected Widget element");
    }
    var getter = buildPropertyGetter();
    var w = {
        WidgetType: getter(root, "@xsi:type", "string"),
        Name: getter(root, "Name", "string"),
        Type: getter(root, "Type", "string"),
        //Location: getter(root, "Location", "string"),
        Extension: deArrayifyExtension(root.Extension)
    };
    return w;
}
function deArrayifyExtension(json, arrayCheck) {
    if (arrayCheck === void 0) { arrayCheck = true; }
    var root = json;
    if (root == null) {
        return null;
    }
    if (arrayCheck && root.length != 1) {
        throw new error_1.MgError("Malformed input. Expected Extension element");
    }
    var getter = buildPropertyGetter();
    var ext = {};
    for (var key in root[0]) {
        if (Array.isArray(root[0][key])) {
            //Special case handling
            switch (key) {
                case "AdditionalParameter":
                    {
                        var params = [];
                        for (var _i = 0, _a = root[0][key]; _i < _a.length; _i++) {
                            var p = _a[_i];
                            params.push({
                                Key: getter(p, "Key", "string"),
                                Value: getter(p, "Value", "string")
                            });
                        }
                        ext[key] = params;
                    }
                    break;
                case "Projection":
                    {
                        ext[key] = root[0][key];
                    }
                    break;
                default:
                    ext[key] = getter(root[0], key, "string");
                    break;
            }
        }
        else {
            ext[key] = deArrayifyExtension(root[0][key], false);
        }
    }
    return ext;
}
function deArrayifyUiWidget(json) {
    var root = json;
    if (root == null) {
        throw new error_1.MgError("Malformed input. Expected Widget element");
    }
    var getter = buildPropertyGetter();
    var w = {
        WidgetType: getter(root, "@xsi:type", "string"),
        ImageUrl: getter(root, "ImageUrl", "string"),
        ImageClass: getter(root, "ImageClass", "string"),
        Label: getter(root, "Label", "string"),
        Tooltip: getter(root, "Tooltip", "string"),
        StatusText: getter(root, "StatusText", "string"),
        Disabled: getter(root, "Disabled", "boolean"),
        Name: getter(root, "Name", "string"),
        Type: getter(root, "Type", "string"),
        //Location: getter(root, "Location", "string"),
        Extension: deArrayifyExtension(root.Extension)
    };
    return w;
}
function deArrayifyMapWidget(json) {
    var root = json;
    if (root == null || root.length != 1) {
        throw new error_1.MgError("Malformed input. Expected MapWidget element");
    }
    var getter = buildPropertyGetter();
    var mw = {
        WidgetType: getter(root, "@xsi:type", "string"),
        MapId: getter(root, "MapId", "string"),
        Name: getter(root, "Name", "string"),
        Type: getter(root, "Type", "string"),
        //Location: getter(root, "Location", "string"),
        Extension: deArrayifyExtension(root.Extension)
    };
    return mw;
}
function deArrayifyWidgetSet(json) {
    var widgetSet = [];
    for (var _i = 0, json_4 = json; _i < json_4.length; _i++) {
        var ws = json_4[_i];
        widgetSet.push({
            Container: deArrayifyContainer(ws.Container),
            MapWidget: deArrayifyMapWidget(ws.MapWidget),
            Widget: deArrayifyWidgets(ws.Widget)
        });
    }
    return widgetSet;
}
function deArrayifyFlexibleLayout(json) {
    var root = json;
    var getter = buildPropertyGetter();
    var resp = {
        Title: getter(root, "Title"),
        TemplateUrl: getter(root, "TemplateUrl"),
        MapSet: deArrayifyMapSet(root.MapSet),
        WidgetSet: deArrayifyWidgetSet(root.WidgetSet),
        Extension: deArrayifyExtension(root.Extension)
    };
    return resp;
}
function deArrayifyMapDefinitionGroups(json) {
    var groups = [];
    var getter = buildPropertyGetter();
    for (var _i = 0, json_5 = json; _i < json_5.length; _i++) {
        var g = json_5[_i];
        groups.push({
            Name: getter(g, "Name"),
            ExpandInLegend: getter(g, "ExpandInLegend", "boolean"),
            ShowInLegend: getter(g, "ShowInLegend", "boolean"),
            Visible: getter(g, "Visible", "boolean"),
            LegendLabel: getter(g, "LegendLabel"),
            Group: getter(g, "Group")
        });
    }
    return groups;
}
function deArrayifyMapDefinitionLayers(json) {
    var layers = [];
    var getter = buildPropertyGetter();
    for (var _i = 0, json_6 = json; _i < json_6.length; _i++) {
        var g = json_6[_i];
        layers.push({
            Name: getter(g, "Name"),
            ResourceId: getter(g, "ResourceId"),
            ExpandInLegend: getter(g, "ExpandInLegend", "boolean"),
            ShowInLegend: getter(g, "ShowInLegend", "boolean"),
            Selectable: getter(g, "Selectable", "boolean"),
            Visible: getter(g, "Visible", "boolean"),
            LegendLabel: getter(g, "LegendLabel"),
            Group: getter(g, "Group"),
        });
    }
    return layers;
}
function deArrayifyMapDefinition(json) {
    var _a, _b;
    var root = json;
    var getter = buildPropertyGetter();
    var eGetter = buildPropertyGetter();
    var resp = {
        BackgroundColor: getter(root, "BackgroundColor"),
        CoordinateSystem: getter(root, "CoordinateSystem"),
        Extents: {
            MinX: eGetter(root.Extents[0], "MinX", "float"),
            MinY: eGetter(root.Extents[0], "MinY", "float"),
            MaxX: eGetter(root.Extents[0], "MaxX", "float"),
            MaxY: eGetter(root.Extents[0], "MaxY", "float")
        },
        MapLayer: deArrayifyMapDefinitionLayers((_a = root.MapLayer) !== null && _a !== void 0 ? _a : []),
        MapLayerGroup: deArrayifyMapDefinitionGroups((_b = root.MapLayerGroup) !== null && _b !== void 0 ? _b : [])
    };
    if (root.TileSetSource) {
        var tGetter = buildPropertyGetter();
        resp.TileSetSource = {
            ResourceId: tGetter(root.TileSetSource, "ResourceId")
        };
    }
    return resp;
}
function deArrayifyTileSetDefinitionLayers(json) {
    var getter = buildPropertyGetter();
    var layers = [];
    for (var _i = 0, json_7 = json; _i < json_7.length; _i++) {
        var l = json_7[_i];
        layers.push({
            Name: getter(l, "Name"),
            ResourceId: getter(l, "ResourceId"),
            Selectable: getter(l, "Selectable", "boolean"),
            ShowInLegend: getter(l, "ShowInLegend", "boolean"),
            LegendLabel: getter(l, "LegendLabel"),
            ExpandInLegend: getter(l, "ExpandInLegend", "boolean")
        });
    }
    return layers;
}
function deArrayifyTileSetDefinitionGroups(json) {
    var getter = buildPropertyGetter();
    var groups = [];
    for (var _i = 0, json_8 = json; _i < json_8.length; _i++) {
        var g = json_8[_i];
        groups.push({
            Name: getter(g, "Name"),
            Visible: getter(g, "Visible", "boolean"),
            ShowInLegend: getter(g, "ShowInLegend", "boolean"),
            ExpandInLegend: getter(g, "ExpandInLegend", "boolean"),
            LegendLabel: getter(g, "LegendLabel"),
            BaseMapLayer: deArrayifyTileSetDefinitionLayers(g.BaseMapLayer)
        });
    }
    return groups;
}
function deArrayifyTileSetDefinitionParamList(root) {
    var getter = buildPropertyGetter();
    var params = [];
    for (var _i = 0, root_2 = root; _i < root_2.length; _i++) {
        var p = root_2[_i];
        params.push({
            Name: getter(p, "Name"),
            Value: getter(p, "Value")
        });
    }
    return params;
}
function deArrayifyTileSetDefinitionParams(root) {
    var getter = buildPropertyGetter();
    var tsp = {
        TileProvider: getter(root, "TileProvider"),
        Parameter: deArrayifyTileSetDefinitionParamList(root[0].Parameter)
    };
    return tsp;
}
function deArrayifyTileSetDefinition(json) {
    var root = json;
    var eGetter = buildPropertyGetter();
    var resp = {
        Extents: {
            MinX: eGetter(root.Extents[0], "MinX", "float"),
            MinY: eGetter(root.Extents[0], "MinY", "float"),
            MaxX: eGetter(root.Extents[0], "MaxX", "float"),
            MaxY: eGetter(root.Extents[0], "MaxY", "float")
        },
        TileStoreParameters: deArrayifyTileSetDefinitionParams(json.TileStoreParameters),
        BaseMapLayerGroup: deArrayifyTileSetDefinitionGroups(json.BaseMapLayerGroup)
    };
    return resp;
}
/**
 * Indicates if the de-arrayified result is a {@link WebLayout}
 *
 * @since 0.14
 */
function isWebLayout(arg) {
    return arg.CommandSet != null
        && arg.ContextMenu != null
        && arg.Map != null;
}
exports.isWebLayout = isWebLayout;
/**
 * Indicates if the de-arrayified result is an {@link ApplicationDefinition}
 *
 * @since 0.14
 */
function isAppDef(arg) {
    return arg.WidgetSet != null;
}
exports.isAppDef = isAppDef;
/**
 * Indicates if the de-arrayified result is a {@link MapDefinition}
 *
 * @since 0.14
 */
function isMapDef(arg) {
    return arg.Extents != null
        && arg.BackgroundColor != null
        && arg.CoordinateSystem != null
        && arg.MapLayer != null
        && arg.MapLayerGroup != null;
}
exports.isMapDef = isMapDef;
/**
 * Indicates if the de-arrayified result is a {@link TileSetDefinition}
 *
 * @since 0.14
 */
function isTileSet(arg) {
    return arg.Extents != null
        && arg.TileStoreParameters != null
        && arg.BaseMapLayerGroup != null;
}
exports.isTileSet = isTileSet;
/**
 * Indicates if the de-arrayified result is a {@link SiteVersionResponse}
 *
 * @since 0.14
 */
function isSiteVersion(arg) {
    return arg.Version != null;
}
exports.isSiteVersion = isSiteVersion;
/**
 * Indicates if the de-arrayified result is a {@link QueryMapFeaturesResponse}
 *
 * @since 0.14
 */
function isQueryMapFeaturesResponse(arg) {
    return arg.FeatureSet != null
        || arg.Hyperlink != null
        || arg.InlineSelectionImage != null
        || arg.SelectedFeatures != null
        || arg.Tooltip != null;
}
exports.isQueryMapFeaturesResponse = isQueryMapFeaturesResponse;
/**
 * Normalizes the given JSON object to match the content model of its original XML form
 *
 * @export
 * @param {*} json The JSON object to normalize
 * @returns {*} The normalized JSON object
 */
function deArrayify(json) {
    if (json["RuntimeMap"]) {
        return deArrayifyRuntimeMap(json.RuntimeMap);
    }
    if (json["FeatureInformation"]) {
        return deArrayifyFeatureInformation(json.FeatureInformation);
    }
    if (json["WebLayout"]) {
        return deArrayifyWebLayout(json.WebLayout);
    }
    if (json["ApplicationDefinition"]) {
        return deArrayifyFlexibleLayout(json.ApplicationDefinition);
    }
    if (json["MapDefinition"]) {
        return deArrayifyMapDefinition(json.MapDefinition);
    }
    if (json["TileSetDefinition"]) {
        return deArrayifyTileSetDefinition(json.TileSetDefinition);
    }
    if (json["SiteVersion"]) {
        return {
            Version: json.SiteVersion.Version[0]
        };
    }
    var keys = [];
    for (var k in json) {
        keys.push(k);
    }
    throw new error_1.MgError("Unsure how to process JSON response. Root elements are: (" + keys.join(", ") + ")");
}
exports.deArrayify = deArrayify;
/**
 * Builds an XML selection string from the given selection set.
 *
 * @export
 * @param {(FeatureSet | undefined)} selection The selection set
 * @param {string[]} [layerIds] If specified, the selection XML will only include selections from the specified layers
 * @returns {string} The selection XML string
 */
function buildSelectionXml(selection, layerIds) {
    var xml = '<?xml version="1.0" encoding="utf-8"?>';
    xml += '<FeatureSet xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FeatureSet-1.0.0.xsd">';
    if (selection) {
        var selLayers = selection.Layer;
        for (var _i = 0, selLayers_1 = selLayers; _i < selLayers_1.length; _i++) {
            var layer = selLayers_1[_i];
            var layerId = layer["@id"];
            if (layerIds != null && layerIds.indexOf(layerId) < 0) {
                continue;
            }
            xml += "<Layer id=\"" + layerId + "\">";
            var cls = layer.Class;
            xml += "<Class id=\"" + cls["@id"] + "\">";
            for (var _a = 0, _b = cls.ID; _a < _b.length; _a++) {
                var id = _b[_a];
                xml += "<ID>" + id + "</ID>";
            }
            xml += '</Class>';
            xml += '</Layer>';
        }
    }
    xml += '</FeatureSet>';
    return xml;
}
exports.buildSelectionXml = buildSelectionXml;
/**
 * Can only be used for a v4.0.0 or higher QUERYMAPFEATURES request
 *
 * @param selection Current selection set
 * @param feat The active selected feature
 */
function getActiveSelectedFeatureXml(selection, feat) {
    for (var _i = 0, _a = selection.Layer; _i < _a.length; _i++) {
        var layer = _a[_i];
        var layerId = layer["@id"];
        if (layerId == feat.layerId) {
            var key = feat.selectionKey;
            var xml = '<?xml version="1.0" encoding="utf-8"?>';
            xml += '<FeatureSet xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="FeatureSet-1.0.0.xsd">';
            xml += "<Layer id=\"" + layerId + "\">";
            xml += "<Class id=\"" + layer.Class["@id"] + "\">";
            xml += "<ID>" + key + "</ID>";
            xml += '</Class>';
            xml += '</Layer>';
            xml += '</FeatureSet>';
            return xml;
        }
    }
}
exports.getActiveSelectedFeatureXml = getActiveSelectedFeatureXml;


/***/ }),

/***/ "./src/api/builders/factory.ts":
/*!*************************************!*\
  !*** ./src/api/builders/factory.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createRequestBuilder = exports.registerRequestBuilder = void 0;
var error_1 = __webpack_require__(/*! ../error */ "./src/api/error.ts");
var _builders = {};
/**
 * Registers a factory for creating request builders for the given kind. This only needs to be called in the entry point of your custom viewer bundle.
 *
 * @param kind
 * @param factory
 * @since 0.13
 */
function registerRequestBuilder(kind, factory) {
    _builders[kind] = factory;
}
exports.registerRequestBuilder = registerRequestBuilder;
/**
 * Creates the request builder for the given kind
 *
 * @param agentUri
 * @param kind
 * @since 0.13
 */
function createRequestBuilder(agentUri, kind) {
    if (_builders[kind]) {
        return _builders[kind](agentUri);
    }
    throw new error_1.MgError("Unknown or unsupported client kind: " + kind);
}
exports.createRequestBuilder = createRequestBuilder;


/***/ }),

/***/ "./src/api/builders/mapagent.ts":
/*!**************************************!*\
  !*** ./src/api/builders/mapagent.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapAgentRequestBuilder = exports.serialize = exports.isErrorResponse = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var error_1 = __webpack_require__(/*! ../error */ "./src/api/error.ts");
var deArrayify_1 = __webpack_require__(/*! ./deArrayify */ "./src/api/builders/deArrayify.ts");
var i18n_1 = __webpack_require__(/*! ../i18n */ "./src/api/i18n.ts");
var request_builder_1 = __webpack_require__(/*! ../request-builder */ "./src/api/request-builder.ts");
var MG_MAPAGENT_ERROR_CODE = 559;
/**
 * Indicates if the given response is an error response
 *
 * @export
 * @param {Response} response
 * @returns {boolean}
 */
function isErrorResponse(response) {
    return !response.ok || response.status === MG_MAPAGENT_ERROR_CODE;
}
exports.isErrorResponse = isErrorResponse;
/**
 * Encodes the given object for a POST submission
 *
 * @export
 * @param {*} data
 * @returns {string}
 */
function serialize(data, uppercase) {
    if (uppercase === void 0) { uppercase = true; }
    return Object.keys(data).map(function (keyName) {
        return encodeURIComponent(uppercase ? keyName.toUpperCase() : keyName) + '=' + encodeURIComponent(data[keyName]);
    }).join('&');
}
exports.serialize = serialize;
/**
 * The mapagent client
 *
 * @export
 * @class MapAgentRequestBuilder
 * @extends {RequestBuilder}
 */
var MapAgentRequestBuilder = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(MapAgentRequestBuilder, _super);
    function MapAgentRequestBuilder(agentUri, locale) {
        if (locale === void 0) { locale = i18n_1.DEFAULT_LOCALE; }
        var _this = _super.call(this, agentUri) || this;
        _this.locale = locale;
        return _this;
    }
    MapAgentRequestBuilder.prototype.get = function (url) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var response, json;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fetch(url, {
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json'
                            },
                            method: "GET"
                        })];
                    case 1:
                        response = _a.sent();
                        if (!isErrorResponse(response)) return [3 /*break*/, 2];
                        throw new error_1.MgError(response.statusText);
                    case 2: return [4 /*yield*/, response.json()];
                    case 3:
                        json = _a.sent();
                        return [2 /*return*/, (0, deArrayify_1.deArrayify)(json)];
                }
            });
        });
    };
    MapAgentRequestBuilder.prototype.post = function (url, data) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var response, json;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!data.format) {
                            data.format = "application/json";
                        }
                        return [4 /*yield*/, fetch(url, {
                                headers: {
                                    'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
                                },
                                method: "POST",
                                body: serialize(data) //form
                            })];
                    case 1:
                        response = _a.sent();
                        if (!isErrorResponse(response)) return [3 /*break*/, 2];
                        throw new error_1.MgError(response.statusText);
                    case 2: return [4 /*yield*/, response.json()];
                    case 3:
                        json = _a.sent();
                        return [2 /*return*/, (0, deArrayify_1.deArrayify)(json)];
                }
            });
        });
    };
    MapAgentRequestBuilder.prototype.stringifyGetUrl = function (options) {
        if (!options.version) {
            options.version = "1.0.0";
        }
        if (!options.locale) {
            options.locale = this.locale;
        }
        if (!options.format) {
            options.format = "application/json";
        }
        var url = this.agentUri;
        var bFirst = true;
        for (var key in options) {
            if (bFirst) {
                url += "?" + key.toUpperCase() + "=" + options[key];
                bFirst = false;
            }
            else {
                url += "&" + key.toUpperCase() + "=" + options[key];
            }
        }
        return url;
    };
    MapAgentRequestBuilder.prototype.createSession = function (username, password) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var url, data, response;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.agentUri;
                        data = { operation: "CREATESESSION", version: "1.0.0", USERNAME: username, PASSWORD: password };
                        return [4 /*yield*/, fetch(url, {
                                headers: {
                                    'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
                                },
                                method: "POST",
                                body: serialize(data) //form
                            })];
                    case 1:
                        response = _a.sent();
                        if (!isErrorResponse(response)) return [3 /*break*/, 2];
                        throw new error_1.MgError(response.statusText);
                    case 2: return [4 /*yield*/, response.text()];
                    case 3: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    MapAgentRequestBuilder.prototype.getServerSessionTimeout = function (session) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var url, data, response, val;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = this.agentUri;
                        data = { operation: "GETSESSIONTIMEOUT", version: "1.0.0", SESSION: session };
                        return [4 /*yield*/, fetch(url, {
                                headers: {
                                    'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
                                },
                                method: "POST",
                                body: serialize(data) //form
                            })];
                    case 1:
                        response = _a.sent();
                        if (!isErrorResponse(response)) return [3 /*break*/, 2];
                        throw new error_1.MgError(response.statusText);
                    case 2: return [4 /*yield*/, response.text()];
                    case 3:
                        val = _a.sent();
                        return [2 /*return*/, parseInt(val, 10)];
                }
            });
        });
    };
    MapAgentRequestBuilder.prototype.getResource = function (resourceId, args) {
        if (args != null) {
            var p1 = { operation: "GETRESOURCECONTENT", resourceId: resourceId };
            var url = this.stringifyGetUrl((0, tslib_1.__assign)((0, tslib_1.__assign)({}, args), p1));
            return this.get(url);
        }
        else {
            var url = this.stringifyGetUrl({ operation: "GETRESOURCE", resourceId: resourceId });
            return this.get(url);
        }
    };
    MapAgentRequestBuilder.prototype.getSiteVersion = function () {
        var p1 = { operation: "GETSITEVERSION", version: "1.0.0", username: "Anonymous" };
        var url = this.stringifyGetUrl((0, tslib_1.__assign)({}, p1));
        return this.get(url);
    };
    MapAgentRequestBuilder.prototype.createRuntimeMap = function (options) {
        var p1 = { operation: "CREATERUNTIMEMAP", version: "3.0.0" };
        var url = this.stringifyGetUrl((0, tslib_1.__assign)((0, tslib_1.__assign)({}, options), p1));
        return this.get(url);
    };
    MapAgentRequestBuilder.prototype.queryMapFeatures = function (options) {
        var p1 = { operation: "QUERYMAPFEATURES", version: "2.6.0" };
        return this.post(this.agentUri, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, options), p1));
    };
    MapAgentRequestBuilder.prototype.queryMapFeatures_v4 = function (options) {
        var p1 = { operation: "QUERYMAPFEATURES", version: "4.0.0" };
        return this.post(this.agentUri, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, options), p1));
    };
    MapAgentRequestBuilder.prototype.describeRuntimeMap = function (options) {
        var p1 = { operation: "DESCRIBERUNTIMEMAP", version: "3.0.0" };
        var url = this.stringifyGetUrl((0, tslib_1.__assign)((0, tslib_1.__assign)({}, options), p1));
        return this.get(url);
    };
    MapAgentRequestBuilder.prototype.getTileTemplateUrl = function (resourceId, groupName, xPlaceholder, yPlaceholder, zPlaceholder) {
        var urlTemplate = this.agentUri + "?OPERATION=GETTILEIMAGE&VERSION=1.2.0&USERNAME=Anonymous&MAPDEFINITION=" + resourceId + "&BASEMAPLAYERGROUPNAME=" + groupName + "&TILECOL=" + xPlaceholder + "&TILEROW=" + yPlaceholder + "&SCALEINDEX=" + zPlaceholder;
        return urlTemplate;
    };
    return MapAgentRequestBuilder;
}(request_builder_1.RequestBuilder));
exports.MapAgentRequestBuilder = MapAgentRequestBuilder;


/***/ }),

/***/ "./src/api/client.ts":
/*!***************************!*\
  !*** ./src/api/client.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Client = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var error_1 = __webpack_require__(/*! ./error */ "./src/api/error.ts");
var mapagent_1 = __webpack_require__(/*! ./builders/mapagent */ "./src/api/builders/mapagent.ts");
var factory_1 = __webpack_require__(/*! ./builders/factory */ "./src/api/builders/factory.ts");
/**
 * The MapGuide HTTP client
 *
 * @export
 * @class Client
 * @implements {IMapGuideClient}
 */
var Client = /** @class */ (function () {
    function Client(agentUri, kind) {
        this.builder = (0, factory_1.createRequestBuilder)(agentUri, kind);
    }
    Client.prototype.getText = function (url) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var r, text;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fetch(url)];
                    case 1:
                        r = _a.sent();
                        if (!r.ok)
                            throw new error_1.MgError(r.statusText);
                        return [4 /*yield*/, r.text()];
                    case 2:
                        text = _a.sent();
                        return [2 /*return*/, text];
                }
            });
        });
    };
    /**
     * Performs a generic GET request at the specified URL
     *
     * @template T The type of the object you are expecting to receive
     * @param {string} url The url to make the request to
     * @returns {Promise<T>} A promise for the value of the requested type
     *
     * @memberOf Client
     */
    Client.prototype.get = function (url) {
        return new Promise(function (resolve, reject) {
            fetch(url, {
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                method: "GET"
            })
                .then(function (response) {
                if ((0, mapagent_1.isErrorResponse)(response)) {
                    throw new error_1.MgError(response.statusText);
                }
                else {
                    resolve(response.json());
                }
            })
                .catch(reject);
        });
    };
    /**
     * Performs a generic POST request at the specified URL
     *
     * @template T The type of the object you are expecting to receive
     * @param {string} url The url to make the request to
     * @param {*} data The POST form data
     * @returns {Promise<T>} A promise for the value of the requested type
     *
     * @memberOf Client
     */
    Client.prototype.post = function (url, data) {
        if (!data.format) {
            data.format = "application/json";
        }
        //const form = new FormData();
        //for (const key in data) {
        //    form.append(key.toUpperCase(), data[key]);
        //}
        return new Promise(function (resolve, reject) {
            fetch(url, {
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
                },
                method: "POST",
                body: (0, mapagent_1.serialize)(data) //form
            })
                .then(function (response) {
                if ((0, mapagent_1.isErrorResponse)(response)) {
                    throw new error_1.MgError(response.statusText);
                }
                else {
                    resolve(response.json());
                }
            })
                .catch(reject);
        });
    };
    /**
     * Creates a new MapGuide session
     *
     * @param {string} username
     * @param {string} password
     * @returns {Promise<string>}
     *
     * @memberOf Client
     */
    Client.prototype.createSession = function (username, password) {
        return this.builder.createSession(username, password);
    };
    /**
     * Gets the server session timeout for the given session id
     *
     * @param {string} session
     * @returns {Promise<number>}
     *
     * @memberOf Client
     */
    Client.prototype.getServerSessionTimeout = function (session) {
        return this.builder.getServerSessionTimeout(session);
    };
    /**
     * gets the MapGuide Server version
     *
     * @since 0.14
     */
    Client.prototype.getSiteVersion = function () {
        return this.builder.getSiteVersion();
    };
    /**
     * Retrieves the requested resource
     *
     * @template T
     * @param {ResourceIdentifier} resourceId
     * @param {*} [args]
     * @returns {Promise<T>}
     *
     * @memberOf Client
     */
    Client.prototype.getResource = function (resourceId, args) {
        return this.builder.getResource(resourceId, args);
    };
    /**
     * Creates a runtime map from the specified map definition
     *
     * @param {ICreateRuntimeMapOptions} options
     * @returns {Promise<RuntimeMap>}
     *
     * @memberOf Client
     */
    Client.prototype.createRuntimeMap = function (options) {
        return this.builder.createRuntimeMap(options);
    };
    /**
     * Describes a runtime map
     *
     * @param {IDescribeRuntimeMapOptions} options
     * @returns {Promise<RuntimeMap>}
     *
     * @memberOf Client
     */
    Client.prototype.describeRuntimeMap = function (options) {
        return this.builder.describeRuntimeMap(options);
    };
    /**
     * Performs a map selection query on the current map
     *
     * @param {IQueryMapFeaturesOptions} options
     * @returns {Promise<QueryMapFeaturesResponse>}
     *
     * @memberOf Client
     */
    Client.prototype.queryMapFeatures = function (options) {
        return this.builder.queryMapFeatures(options);
    };
    /**
     * Performs a map selection query on the current map. Only applicable for use in MapGuide Open Source
     * 4.0 and higher
     *
     * @param {IQueryMapFeaturesOptions} options
     * @returns {Promise<QueryMapFeaturesResponse>}
     *
     * @memberOf Client
     */
    Client.prototype.queryMapFeatures_v4 = function (options) {
        return this.builder.queryMapFeatures_v4(options);
    };
    /**
     * Gets the tile template URL used by the viewer to send tile requests
     *
     * @param {string} resourceId
     * @param {string} groupName
     * @param {string} xPlaceholder
     * @param {string} yPlaceholder
     * @param {string} zPlaceholder
     * @returns {string}
     *
     * @memberOf Client
     */
    Client.prototype.getTileTemplateUrl = function (resourceId, groupName, xPlaceholder, yPlaceholder, zPlaceholder) {
        return this.builder.getTileTemplateUrl(resourceId, groupName, xPlaceholder, yPlaceholder, zPlaceholder);
    };
    return Client;
}());
exports.Client = Client;


/***/ }),

/***/ "./src/api/common.ts":
/*!***************************!*\
  !*** ./src/api/common.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MgBuiltInLayers = exports.MG_BASE_LAYER_GROUP_NAME = exports.MG_LAYER_TYPE_NAME = exports.MgLayerType = exports.SourceProperty = exports.LayerProperty = exports.getExternalBaseLayers = exports.getCurrentView = exports.getRuntimeMap = exports.getSelectionSet = exports.getMapGuideSubState = exports.getInitialView = exports.ALWAYS_TRUE = exports.ALWAYS_FALSE = exports.NOOP = exports.KC_U = exports.KC_ESCAPE = exports.DEFAULT_MODAL_SIZE = exports.RefreshMode = exports.ActiveMapTool = exports.UnitOfMeasure = exports.BLANK_SIZE = void 0;
/**
 * The default blank size
 */
exports.BLANK_SIZE = { w: 1, h: 1 };
var UnitOfMeasure;
(function (UnitOfMeasure) {
    /**
     * An unknown unit
     */
    UnitOfMeasure[UnitOfMeasure["Unknown"] = 0] = "Unknown";
    /**
     * Inch unit
     */
    UnitOfMeasure[UnitOfMeasure["Inches"] = 1] = "Inches";
    /**
     * Feet unit
     */
    UnitOfMeasure[UnitOfMeasure["Feet"] = 2] = "Feet";
    /**
     * Yard unit
     */
    UnitOfMeasure[UnitOfMeasure["Yards"] = 3] = "Yards";
    /**
     * Mile unit
     */
    UnitOfMeasure[UnitOfMeasure["Miles"] = 4] = "Miles";
    /**
     * Nautical Mile unit
     */
    UnitOfMeasure[UnitOfMeasure["NauticalMiles"] = 5] = "NauticalMiles";
    /**
     * Millimeter unit
     */
    UnitOfMeasure[UnitOfMeasure["Millimeters"] = 6] = "Millimeters";
    /**
     * Centimeter unit
     */
    UnitOfMeasure[UnitOfMeasure["Centimeters"] = 7] = "Centimeters";
    /**
     * Meter unit
     */
    UnitOfMeasure[UnitOfMeasure["Meters"] = 8] = "Meters";
    /**
     * Kilometer unit
     */
    UnitOfMeasure[UnitOfMeasure["Kilometers"] = 9] = "Kilometers";
    /**
     * Degree unit
     */
    UnitOfMeasure[UnitOfMeasure["Degrees"] = 10] = "Degrees";
    /**
     * Decimal Degree unit
     */
    UnitOfMeasure[UnitOfMeasure["DecimalDegrees"] = 11] = "DecimalDegrees";
    /**
     * DMS unit
     */
    UnitOfMeasure[UnitOfMeasure["DMS"] = 12] = "DMS";
    /**
     * Pixel unit
     */
    UnitOfMeasure[UnitOfMeasure["Pixels"] = 13] = "Pixels";
})(UnitOfMeasure = exports.UnitOfMeasure || (exports.UnitOfMeasure = {}));
/**
 * An active map viewer tool
 *
 * @export
 * @enum {number}
 */
var ActiveMapTool;
(function (ActiveMapTool) {
    /**
     * Zoom tool
     */
    ActiveMapTool[ActiveMapTool["Zoom"] = 0] = "Zoom";
    /**
     * Selection tool
     */
    ActiveMapTool[ActiveMapTool["Select"] = 1] = "Select";
    /**
     * Pan tool
     */
    ActiveMapTool[ActiveMapTool["Pan"] = 2] = "Pan";
    /**
     * None
     */
    ActiveMapTool[ActiveMapTool["None"] = 3] = "None";
})(ActiveMapTool = exports.ActiveMapTool || (exports.ActiveMapTool = {}));
/**
 * A bit mask indicating how a map viewer should refresh
 *
 * @export
 * @enum {number}
 */
var RefreshMode;
(function (RefreshMode) {
    /**
     * Refresh only the layers
     */
    RefreshMode[RefreshMode["LayersOnly"] = 1] = "LayersOnly";
    /**
     * Refresh only the selection
     */
    RefreshMode[RefreshMode["SelectionOnly"] = 2] = "SelectionOnly";
})(RefreshMode = exports.RefreshMode || (exports.RefreshMode = {}));
/**
 * The default modal dialog size
 */
exports.DEFAULT_MODAL_SIZE = [350, 500];
/**
 * Keyboard code for ESCAPE
 */
exports.KC_ESCAPE = 27;
/**
 * Keyboard code for the letter U
 */
exports.KC_U = 85;
/**
 * A function that does nothing
 *
 * @export
 */
function NOOP() { }
exports.NOOP = NOOP;
/**
 * A function that always returns false
 *
 * @export
 * @returns false
 */
function ALWAYS_FALSE() { return false; }
exports.ALWAYS_FALSE = ALWAYS_FALSE;
/**
 * A function that always returns true
 *
 * @export
 * @returns true
 */
function ALWAYS_TRUE() { return true; }
exports.ALWAYS_TRUE = ALWAYS_TRUE;
/**
 * Helper function to get the initial map view from the application state
 *
 * @export
 * @param {Readonly<IApplicationState>} state
 * @returns {(IMapView | undefined)}
 */
function getInitialView(state) {
    if (state.config.activeMapName) {
        return state.mapState[state.config.activeMapName].initialView;
    }
    return undefined;
}
exports.getInitialView = getInitialView;
/**
 * Helper function to get the mapguide-specific sub state of the current map group
 *
 * @export
 * @param {Readonly<IApplicationState>} state
 * @returns {(IMapGuideSubState | undefined)}
 * @since 0.14
 */
function getMapGuideSubState(state) {
    if (state.config.activeMapName) {
        return state.mapState[state.config.activeMapName].mapguide;
    }
    return undefined;
}
exports.getMapGuideSubState = getMapGuideSubState;
/**
 * Helper function to get the current selection set from the application state
 *
 * @export
 * @param {Readonly<IApplicationState>} state
 * @returns {(QueryMapFeaturesResponse | undefined)}
 */
function getSelectionSet(state) {
    var _a;
    return (_a = getMapGuideSubState(state)) === null || _a === void 0 ? void 0 : _a.selectionSet;
}
exports.getSelectionSet = getSelectionSet;
/**
 * Helper function to get the current runtime map state from the application state
 *
 * @export
 * @param {Readonly<IApplicationState>} state
 * @returns {(RuntimeMap | undefined)}
 */
function getRuntimeMap(state) {
    var _a;
    return (_a = getMapGuideSubState(state)) === null || _a === void 0 ? void 0 : _a.runtimeMap;
}
exports.getRuntimeMap = getRuntimeMap;
/**
 * Helper function to get the current view from the application state
 *
 * @export
 * @param {Readonly<IApplicationState>} state
 * @returns {(IMapView | undefined)}
 */
function getCurrentView(state) {
    if (state.config.activeMapName) {
        return state.mapState[state.config.activeMapName].currentView;
    }
    return undefined;
}
exports.getCurrentView = getCurrentView;
/**
 * Helper function to get the current set of available external base layers from the application state
 *
 * @remarks This does not include "non-visual" base layers such as UTFGrid tilesets
 *
 * @export
 * @param {Readonly<IApplicationState>} state
 * @param includeNonVisual Include "non-visual" base layers like UTFGrid tile sets
 * @returns {(IExternalBaseLayer[] | undefined)}
 */
function getExternalBaseLayers(state, includeNonVisual) {
    if (state.config.activeMapName) {
        if (includeNonVisual) {
            return state.mapState[state.config.activeMapName].externalBaseLayers;
        }
        else {
            // UTFGrid may exist as a "base layer", but it has no visual representation so it is not a switchable candidate, so
            // exclude it from the list if present
            return state.mapState[state.config.activeMapName].externalBaseLayers.filter(function (ebl) { return ebl.kind != "UTFGrid"; });
        }
    }
    return undefined;
}
exports.getExternalBaseLayers = getExternalBaseLayers;
/**
 * Custom properties that can be attached to OpenLayers layer instances
 *
 * @since 0.13
 */
var LayerProperty;
(function (LayerProperty) {
    LayerProperty["LAYER_TYPE"] = "layer_type";
    LayerProperty["LAYER_NAME"] = "name";
    /**
     * @since 0.14
     */
    LayerProperty["LAYER_DISPLAY_NAME"] = "display_name";
    LayerProperty["IS_GROUP"] = "is_group";
    LayerProperty["IS_EXTERNAL"] = "is_external";
    LayerProperty["IS_SELECTABLE"] = "is_selectable";
    LayerProperty["IS_SCRATCH"] = "is_scratch";
    LayerProperty["HAS_WMS_LEGEND"] = "has_wms_legend";
    LayerProperty["VECTOR_STYLE"] = "vector_style";
    LayerProperty["WGS84_BBOX"] = "wgs84_bbox";
    LayerProperty["BUSY_WORKER_COUNT"] = "busy_worker_count";
    /**
     * @since 0.14
     */
    LayerProperty["SELECTED_POPUP_CONFIGURATION"] = "popup_config";
    /**
     * @since 0.14
     */
    LayerProperty["LAYER_DESCRIPTION"] = "layer_description";
    /**
     * @since 0.14
     */
    LayerProperty["LAYER_METADATA"] = "layer_metadata";
    /**
     * @since 0.14
     */
    LayerProperty["IS_HOVER_HIGHLIGHT"] = "is_hover_highlight";
    /**
     * @since 0.14
     */
    LayerProperty["IS_MEASURE"] = "is_measure";
    /**
     * @since 0.14
     */
    LayerProperty["IS_WMS_SELECTION_OVERLAY"] = "is_wms_selection_overlay";
    /**
     * @since 0.14
     */
    LayerProperty["IS_HEATMAP"] = "is_heatmap";
    /**
     * A source definition to attach to the layer. This is to assist in persistence of this layer for easy
     * restoration on an application-defined basis
     *
     * @since 0.14.3
     */
    LayerProperty["LAYER_DEFN"] = "layer_defn";
})(LayerProperty = exports.LayerProperty || (exports.LayerProperty = {}));
/**
 * Custom properties that can be attached to OpenLayers image source instances
 *
 * @since 0.13
 */
var SourceProperty;
(function (SourceProperty) {
    SourceProperty["SUPPRESS_LOAD_EVENTS"] = "suppress_load_events";
})(SourceProperty = exports.SourceProperty || (exports.SourceProperty = {}));
/**
 * MapGuide layer types
 *
 * @since 0.13
 */
var MgLayerType;
(function (MgLayerType) {
    MgLayerType["Untiled"] = "MapGuide_Untiled";
    MgLayerType["Tiled"] = "MapGuide_Tiled";
})(MgLayerType = exports.MgLayerType || (exports.MgLayerType = {}));
/**
 * The type name for a MapGuide layer
 *
 * @since 0.13
 */
exports.MG_LAYER_TYPE_NAME = "MapGuide";
/**
 * The default group name for MapGuide tiled layers. This value
 * is not meant for localized display
 *
 * @since 0.13
 */
exports.MG_BASE_LAYER_GROUP_NAME = "Base Tile Layers";
/**
 * Default names for MapGuide built-in layer types. These value
 * are not meant for localized display
 *
 * @since 0.13
 */
var MgBuiltInLayers;
(function (MgBuiltInLayers) {
    MgBuiltInLayers["Overlay"] = "MapGuide Dynamic Overlay";
    MgBuiltInLayers["SelectionOverlay"] = "MapGuide Selection Overlay";
    MgBuiltInLayers["ActiveFeatureSelectionOverlay"] = "MapGuide Active Feature Selection Overlay";
})(MgBuiltInLayers = exports.MgBuiltInLayers || (exports.MgBuiltInLayers = {}));


/***/ }),

/***/ "./src/api/composite-selection.ts":
/*!****************************************!*\
  !*** ./src/api/composite-selection.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompositeSelection = exports.CompositeSelectionLayer = void 0;
//FIXME: We are inlining extend of ol/Extent here so that this module can be included in any jest test case
//without jest complaining about not being able to import ol's ES6 modules. I don't know how to get jest to
//recognize ol imports. None of the solutions I tried worked!
function extend(extent1, extent2) {
    if (extent2[0] < extent1[0]) {
        extent1[0] = extent2[0];
    }
    if (extent2[2] > extent1[2]) {
        extent1[2] = extent2[2];
    }
    if (extent2[1] < extent1[1]) {
        extent1[1] = extent2[1];
    }
    if (extent2[3] > extent1[3]) {
        extent1[3] = extent2[3];
    }
    return extent1;
}
/**
 * A layer of a {@link CompositeSelection}
 *
 * @since 0.14
 */
var CompositeSelectionLayer = /** @class */ (function () {
    function CompositeSelectionLayer(layer) {
        this.layer = layer;
        this.features = [];
        if (this.isSelectedLayer(this.layer)) {
            for (var _i = 0, _a = this.layer.Feature; _i < _a.length; _i++) {
                var f = _a[_i];
                this.features.push(f);
            }
        }
        else {
            for (var _b = 0, _c = this.layer.features; _b < _c.length; _b++) {
                var f = _c[_b];
                var fp = [];
                for (var k in f.properties) {
                    fp.push({
                        Name: k,
                        Value: f.properties[k]
                    });
                }
                var fb = f.bounds ? f.bounds.join(" ") : undefined;
                this.features.push({
                    Bounds: fb,
                    Property: fp
                });
            }
        }
    }
    CompositeSelectionLayer.prototype.isSelectedLayer = function (layer) {
        return layer.Feature
            && layer["@id"]
            && layer["@name"];
    };
    /**
     * Gets the combined bounds of all selected features
     *
     * @returns The combined bounds of all selected features in the projection of the current map view
     */
    CompositeSelectionLayer.prototype.getBounds = function () {
        var bounds;
        if (this.isSelectedLayer(this.layer)) {
            this.layer.Feature.forEach(function (feat) {
                var b = feat.Bounds
                    ? feat.Bounds.split(" ").map(function (s) { return parseFloat(s); })
                    : undefined;
                if (b) {
                    if (!bounds) {
                        bounds = b;
                    }
                    else {
                        bounds = extend(bounds, b);
                    }
                }
            });
        }
        else {
            for (var _i = 0, _a = this.layer.features; _i < _a.length; _i++) {
                var f = _a[_i];
                if (f.bounds) {
                    if (bounds == null) {
                        bounds = f.bounds;
                    }
                    else {
                        bounds = extend(bounds, f.bounds);
                    }
                }
            }
        }
        return bounds;
    };
    CompositeSelectionLayer.prototype.getLayerId = function () {
        if (this.isSelectedLayer(this.layer)) {
            return this.layer["@id"];
        }
        return undefined;
    };
    CompositeSelectionLayer.prototype.getName = function () {
        if (this.isSelectedLayer(this.layer)) {
            return this.layer["@name"];
        }
        else {
            return this.layer.name;
        }
    };
    CompositeSelectionLayer.prototype.getFeatureAt = function (featureIndex) {
        return this.features[featureIndex];
    };
    CompositeSelectionLayer.prototype.getFeatureCount = function () { return this.features.length; };
    CompositeSelectionLayer.prototype.getLayerMetadata = function () {
        if (this.isSelectedLayer(this.layer)) {
            return this.layer.LayerMetadata;
        }
        return undefined;
    };
    return CompositeSelectionLayer;
}());
exports.CompositeSelectionLayer = CompositeSelectionLayer;
/**
 * A composition of a MapGuide selection set and a client-side vector feature selection
 *
 * @since 0.14
 */
var CompositeSelection = /** @class */ (function () {
    function CompositeSelection(mgSelection, clientSelection) {
        this.layers = [];
        if (mgSelection) {
            for (var _i = 0, _a = mgSelection.SelectedLayer; _i < _a.length; _i++) {
                var layer = _a[_i];
                this.layers.push(new CompositeSelectionLayer(layer));
            }
        }
        if (clientSelection) {
            for (var _b = 0, _c = clientSelection.layers; _b < _c.length; _b++) {
                var layer = _c[_b];
                this.layers.push(new CompositeSelectionLayer(layer));
            }
        }
    }
    CompositeSelection.prototype.getBounds = function () {
        if (this.layers.length == 0) {
            return undefined;
        }
        var bounds;
        for (var _i = 0, _a = this.layers; _i < _a.length; _i++) {
            var lyr = _a[_i];
            var layerBounds = lyr.getBounds();
            if (layerBounds) {
                if (bounds) {
                    bounds = extend(bounds, layerBounds);
                }
                else {
                    bounds = layerBounds;
                }
            }
        }
        return bounds;
    };
    CompositeSelection.prototype.getLayers = function () { return this.layers; };
    CompositeSelection.prototype.getLayerCount = function () {
        return this.layers.length;
    };
    CompositeSelection.prototype.getLayerAt = function (layerIndex) {
        return this.layers[layerIndex];
    };
    CompositeSelection.prototype.getFeatureAt = function (layerIndex, featureIndex) {
        var layer = this.getLayerAt(layerIndex);
        return layer === null || layer === void 0 ? void 0 : layer.getFeatureAt(featureIndex);
    };
    return CompositeSelection;
}());
exports.CompositeSelection = CompositeSelection;


/***/ }),

/***/ "./src/api/contracts/weblayout.ts":
/*!****************************************!*\
  !*** ./src/api/contracts/weblayout.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

//TODO: When TypeScript 2.0 drops, some of these interfaces can be converted to discriminated unions
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSearchCommand = exports.isInvokeURLCommand = exports.isTargetedCommand = exports.isBasicCommand = exports.isSeparatorItem = exports.isFlyoutItem = exports.isCommandItem = void 0;
function isCommandItem(item) {
    return item.Function === "Command";
}
exports.isCommandItem = isCommandItem;
function isFlyoutItem(item) {
    return item.Function === "Flyout";
}
exports.isFlyoutItem = isFlyoutItem;
function isSeparatorItem(item) {
    return item.Function === "Separator";
}
exports.isSeparatorItem = isSeparatorItem;
function isBasicCommand(cmd) {
    return typeof (cmd.Action) != 'undefined';
}
exports.isBasicCommand = isBasicCommand;
function isTargetedCommand(cmd) {
    return typeof (cmd.Target) != 'undefined';
}
exports.isTargetedCommand = isTargetedCommand;
function isInvokeURLCommand(cmd) {
    return typeof (cmd.URL) != 'undefined' && typeof (cmd.DisableIfSelectionEmpty) != 'undefined';
}
exports.isInvokeURLCommand = isInvokeURLCommand;
function isSearchCommand(cmd) {
    return cmd["@xsi:type"] == "SearchCommandType";
}
exports.isSearchCommand = isSearchCommand;


/***/ }),

/***/ "./src/api/default-commands.ts":
/*!*************************************!*\
  !*** ./src/api/default-commands.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initDefaultCommands = exports.buildTargetedCommand = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var command_1 = __webpack_require__(/*! ./registry/command */ "./src/api/registry/command.ts");
var common_1 = __webpack_require__(/*! ./common */ "./src/api/common.ts");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var component_1 = __webpack_require__(/*! ../api/registry/component */ "./src/api/registry/component.tsx");
var assets_1 = __webpack_require__(/*! ../constants/assets */ "./src/constants/assets.ts");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var modal_1 = __webpack_require__(/*! ../actions/modal */ "./src/actions/modal.ts");
var legend_1 = __webpack_require__(/*! ../actions/legend */ "./src/actions/legend.ts");
var template_1 = __webpack_require__(/*! ../actions/template */ "./src/actions/template.ts");
var react_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var react_dom_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"));
function panMap(dispatch, viewer, value) {
    var settings = {
        "right": [2, 1],
        "left": [0, 1],
        "down": [0, 1],
        "up": [0, 3]
    };
    var view = viewer.getCurrentView();
    var current_center = [view.x, view.y];
    var currentExtent = viewer.getCurrentExtent();
    var newPos;
    var direction = settings[value];
    if (value == "right" || value == "left") {
        newPos = [
            currentExtent[direction[0]],
            current_center[direction[1]]
        ];
    }
    else {
        newPos = [
            current_center[direction[0]],
            currentExtent[direction[1]]
        ];
    }
    dispatch((0, map_1.setCurrentView)({ x: newPos[0], y: newPos[1], scale: view.scale }));
}
function buildTargetedCommand(config, parameters) {
    var cmdTarget = (parameters || {}).Target;
    var cmdDef = {
        target: cmdTarget || "NewWindow"
    };
    if (config.capabilities.hasTaskPane && cmdTarget == "TaskPane") {
        cmdDef.target = "TaskPane";
    }
    if (cmdTarget == "SpecifiedFrame") {
        cmdDef.target = cmdTarget;
        cmdDef.targetFrame = (parameters || {}).TargetFrame;
    }
    return cmdDef;
}
exports.buildTargetedCommand = buildTargetedCommand;
/**
 * Registers the default set of commands into the command registry. This is automatically called by the default viewer
 * bundle. If creating your own viewer bundle, be sure to call this function in your entry point, or individually register
 * the commands you want to make available in your custom viewer bundle
 *
 * @export
 */
function initDefaultCommands() {
    //Select Tool
    (0, command_1.registerCommand)(command_1.DefaultCommands.Select, {
        iconClass: assets_1.SPRITE_SELECT,
        selected: function (state) {
            return state.activeTool === common_1.ActiveMapTool.Select;
        },
        enabled: function () { return true; },
        invoke: function (dispatch) {
            return dispatch((0, map_1.setActiveTool)(common_1.ActiveMapTool.Select));
        }
    });
    //Pan Tool
    (0, command_1.registerCommand)(command_1.DefaultCommands.Pan, {
        iconClass: assets_1.SPRITE_PAN,
        selected: function (state) {
            return state.activeTool === common_1.ActiveMapTool.Pan;
        },
        enabled: function () { return true; },
        invoke: function (dispatch) {
            return dispatch((0, map_1.setActiveTool)(common_1.ActiveMapTool.Pan));
        }
    });
    //Zoom Tool
    (0, command_1.registerCommand)(command_1.DefaultCommands.Zoom, {
        iconClass: assets_1.SPRITE_ZOOM_IN,
        selected: function (state) {
            return state.activeTool === common_1.ActiveMapTool.Zoom;
        },
        enabled: function () { return true; },
        invoke: function (dispatch) {
            return dispatch((0, map_1.setActiveTool)(common_1.ActiveMapTool.Zoom));
        }
    });
    //Zoom in
    (0, command_1.registerCommand)(command_1.DefaultCommands.ZoomIn, {
        iconClass: assets_1.SPRITE_ZOOM_IN_FIXED,
        selected: function () { return false; },
        enabled: function () { return true; },
        invoke: function (_dispatch, _getState, viewer) {
            if (viewer) {
                viewer.zoomDelta(1);
            }
        }
    });
    //Zoom Out
    (0, command_1.registerCommand)(command_1.DefaultCommands.ZoomOut, {
        iconClass: assets_1.SPRITE_ZOOM_OUT_FIXED,
        selected: function () { return false; },
        enabled: function () { return true; },
        invoke: function (_dispatch, _getState, viewer) {
            if (viewer) {
                viewer.zoomDelta(-1);
            }
        }
    });
    //Pan Left
    (0, command_1.registerCommand)(command_1.DefaultCommands.PanLeft, {
        iconClass: assets_1.SPRITE_PAN_WEST,
        selected: function () { return false; },
        enabled: function () { return true; },
        invoke: function (dispatch, _getState, viewer) {
            if (viewer) {
                panMap(dispatch, viewer, "left");
            }
        }
    });
    //Pan Right
    (0, command_1.registerCommand)(command_1.DefaultCommands.PanRight, {
        iconClass: assets_1.SPRITE_PAN_EAST,
        selected: function () { return false; },
        enabled: function () { return true; },
        invoke: function (dispatch, _getState, viewer) {
            if (viewer) {
                panMap(dispatch, viewer, "right");
            }
        }
    });
    //Pan Up
    (0, command_1.registerCommand)(command_1.DefaultCommands.PanUp, {
        iconClass: assets_1.SPRITE_PAN_NORTH,
        selected: function () { return false; },
        enabled: function () { return true; },
        invoke: function (dispatch, _getState, viewer) {
            if (viewer) {
                panMap(dispatch, viewer, "up");
            }
        }
    });
    //Pan Down
    (0, command_1.registerCommand)(command_1.DefaultCommands.PanDown, {
        iconClass: assets_1.SPRITE_PAN_SOUTH,
        selected: function () { return false; },
        enabled: function () { return true; },
        invoke: function (dispatch, _getState, viewer) {
            if (viewer) {
                panMap(dispatch, viewer, "down");
            }
        }
    });
    //About
    (0, command_1.registerCommand)(command_1.DefaultCommands.About, {
        iconClass: assets_1.SPRITE_ABOUT,
        selected: function () { return false; },
        enabled: function () { return true; },
        invoke: function (dispatch, getState) {
            dispatch((0, modal_1.showModalComponent)({
                modal: {
                    title: (0, i18n_1.tr)("ABOUT", getState().config.locale),
                    backdrop: true,
                    size: common_1.DEFAULT_MODAL_SIZE
                },
                name: component_1.DefaultComponentNames.About,
                component: component_1.DefaultComponentNames.About
            }));
        }
    });
    //Help
    (0, command_1.registerCommand)(command_1.DefaultCommands.Help, {
        iconClass: assets_1.SPRITE_HELP,
        selected: function () { return false; },
        enabled: function () { return true; },
        invoke: function (dispatch, getState) {
            dispatch((0, modal_1.showModalUrl)({
                modal: {
                    title: (0, i18n_1.tr)("HELP", getState().config.locale),
                    backdrop: true,
                    size: common_1.DEFAULT_MODAL_SIZE
                },
                name: command_1.DefaultCommands.Help,
                url: "help/index.html"
            }));
        }
    });
    //Measure
    (0, command_1.registerCommand)(command_1.DefaultCommands.Measure, {
        iconClass: assets_1.SPRITE_MEASURE,
        selected: function () { return false; },
        enabled: function () { return true; },
        invoke: function (dispatch, getState, _viewer, parameters) {
            var config = getState().config;
            var url = "component://Measure";
            var cmdDef = buildTargetedCommand(config, parameters);
            (0, command_1.openUrlInTarget)(command_1.DefaultCommands.Measure, cmdDef, config.capabilities.hasTaskPane, dispatch, url, (0, i18n_1.tr)("MEASURE", config.locale));
        }
    });
    //Initial Center and scale
    (0, command_1.registerCommand)(command_1.DefaultCommands.RestoreView, {
        iconClass: assets_1.SPRITE_INITIAL_CENTER,
        selected: function () { return false; },
        enabled: function () { return true; },
        invoke: function (_dispatch, getState, viewer) {
            if (viewer) {
                var view = (0, common_1.getInitialView)(getState());
                if (view != null) {
                    viewer.zoomToView(view.x, view.y, view.scale);
                }
                else {
                    viewer.initialView();
                }
            }
        }
    });
    //Zoom Extents
    (0, command_1.registerCommand)(command_1.DefaultCommands.ZoomExtents, {
        iconClass: assets_1.SPRITE_ZOOM_FULL,
        selected: function () { return false; },
        enabled: function () { return true; },
        invoke: function (_dispatch, _getState, viewer) {
            if (viewer) {
                viewer.initialView();
            }
        }
    });
    //Refresh Map
    (0, command_1.registerCommand)(command_1.DefaultCommands.RefreshMap, {
        iconClass: assets_1.SPRITE_ICON_REFRESHMAP,
        selected: function () { return false; },
        enabled: command_1.CommandConditions.isNotBusy,
        invoke: function (dispatch, _getState, viewer) {
            if (viewer) {
                viewer.refreshMap(common_1.RefreshMode.LayersOnly | common_1.RefreshMode.SelectionOnly);
                dispatch((0, legend_1.refresh)());
            }
        }
    });
    //Previous View
    (0, command_1.registerCommand)(command_1.DefaultCommands.PreviousView, {
        iconClass: assets_1.SPRITE_VIEW_BACK,
        selected: function () { return false; },
        enabled: command_1.CommandConditions.hasPreviousView,
        invoke: function (dispatch, getState) {
            var mapName = getState().config.activeMapName;
            if (mapName) {
                dispatch((0, map_1.previousView)(mapName));
            }
        }
    });
    //Next View
    (0, command_1.registerCommand)(command_1.DefaultCommands.NextView, {
        iconClass: assets_1.SPRITE_VIEW_FORWARD,
        selected: function () { return false; },
        enabled: command_1.CommandConditions.hasNextView,
        invoke: function (dispatch, getState) {
            var mapName = getState().config.activeMapName;
            if (mapName) {
                dispatch((0, map_1.nextView)(mapName));
            }
        }
    });
    //Geolocation
    (0, command_1.registerCommand)(command_1.DefaultCommands.Geolocation, {
        iconClass: assets_1.SPRITE_GEOLOCATION,
        selected: function () { return false; },
        enabled: command_1.CommandConditions.isNotBusy,
        invoke: function (_dispatch, getState, viewer, parameters) {
            var state = getState();
            var view = (0, common_1.getCurrentView)(state);
            var rtMap = (0, common_1.getRuntimeMap)(state);
            var locale = state.config.locale;
            if (viewer && view && rtMap) {
                var fact_1 = viewer.getOLFactory();
                var geoOptions = {};
                var zoomScale_1 = view.scale;
                if (parameters.ZoomLevel) {
                    zoomScale_1 = parseInt(parameters.ZoomLevel, 10);
                }
                if (parameters.EnableHighAccuracy) {
                    geoOptions.enableHighAccuracy = (parameters.EnableHighAccuracy == "true");
                }
                if (parameters.Timeout) {
                    geoOptions.timeout = parseInt(parameters.Timeout, 10);
                }
                if (parameters.MaximumAge) {
                    geoOptions.maximumAge = parseInt(parameters.MaximumAge, 10);
                }
                navigator.geolocation.getCurrentPosition(function (pos) {
                    var proj = viewer.getProjection();
                    var txCoord = fact_1.transformCoordinateFromLonLat([pos.coords.longitude, pos.coords.latitude], proj);
                    var testCoord = fact_1.transformCoordinateFromLonLat([pos.coords.longitude, pos.coords.latitude], "EPSG:" + rtMap.CoordinateSystem.EpsgCode);
                    viewer.zoomToView(txCoord[0], txCoord[1], zoomScale_1);
                    var extents = [
                        rtMap.Extents.LowerLeftCoordinate.X,
                        rtMap.Extents.LowerLeftCoordinate.Y,
                        rtMap.Extents.UpperRightCoordinate.X,
                        rtMap.Extents.UpperRightCoordinate.Y
                    ];
                    if (fact_1.extentContainsXY(extents, testCoord[0], testCoord[1])) {
                        viewer.toastSuccess("geolocation", (0, i18n_1.tr)("GEOLOCATION_SUCCESS", locale));
                        //getTopToaster().show({ icon: "geolocation", message: tr("GEOLOCATION_SUCCESS", locale), intent: Intent.SUCCESS });
                    }
                    else {
                        viewer.toastWarning("warning-sign", (0, i18n_1.tr)("GEOLOCATION_WARN_OUTSIDE_MAP", locale));
                        //getTopToaster().show({ icon: "warning-sign", message: tr("GEOLOCATION_WARN_OUTSIDE_MAP", locale), intent: Intent.WARNING });
                    }
                }, function (err) {
                    viewer.toastError("error", (0, i18n_1.tr)("GEOLOCATION_ERROR", locale, { message: err.message, code: err.code }));
                    //getTopToaster().show({ icon: "error", message: tr("GEOLOCATION_ERROR", locale, { message: err.message, code: err.code }), intent: Intent.DANGER });
                }, geoOptions);
            }
        }
    });
    //Coordinate Tracker
    (0, command_1.registerCommand)(command_1.DefaultCommands.CoordinateTracker, {
        iconClass: assets_1.SPRITE_COORDINATE_TRACKER,
        selected: function () { return false; },
        enabled: function () { return true; },
        invoke: function (dispatch, getState, _viewer, parameters) {
            var config = getState().config;
            var url = "component://CoordinateTracker?" + (parameters.Projection || []).map(function (p) { return "projections=" + p; }).join("&");
            var cmdDef = buildTargetedCommand(config, parameters);
            (0, command_1.openUrlInTarget)(command_1.DefaultCommands.CoordinateTracker, cmdDef, config.capabilities.hasTaskPane, dispatch, url, (0, i18n_1.tr)("COORDTRACKER", config.locale));
        }
    });
    //External Layer Manager
    (0, command_1.registerCommand)(command_1.DefaultCommands.AddManageLayers, {
        iconClass: assets_1.SPRITE_LAYER_ADD,
        selected: function () { return false; },
        enabled: function () { return true; },
        invoke: function (dispatch, getState, _viewer, parameters) {
            var config = getState().config;
            var url = "component://" + component_1.DefaultComponentNames.AddManageLayers;
            var cmdDef = buildTargetedCommand(config, parameters);
            (0, command_1.openUrlInTarget)(command_1.DefaultCommands.AddManageLayers, cmdDef, config.capabilities.hasTaskPane, dispatch, url, (0, i18n_1.tr)("ADD_MANAGE_LAYERS", config.locale));
        }
    });
    //Print
    (0, command_1.registerCommand)(command_1.DefaultCommands.Print, {
        iconClass: assets_1.SPRITE_PRINT,
        selected: function () { return false; },
        enabled: function () { return true; },
        invoke: function (_dispatch, _getState, viewer, _parameters) {
            viewer === null || viewer === void 0 ? void 0 : viewer.exportImage({
                callback: function (image) {
                    var el = react_1.default.createElement("img", { src: image });
                    var printWindow = window.open();
                    if (printWindow) {
                        // Open and immediately close the document. This works around a problem in Firefox that is
                        // captured here: https://bugzilla.mozilla.org/show_bug.cgi?id=667227.
                        // Essentially, when we first create an iframe, it has no document loaded and asynchronously
                        // starts a load of "about:blank". If we access the document object and start manipulating it
                        // before that async load completes, a new document will be automatically created. But then
                        // when the async load completes, the original, automatically-created document gets unloaded
                        // and the new "about:blank" gets swapped in. End result: everything we add to the DOM before
                        // the async load complete gets lost and Firefox ends up printing a blank page.
                        // Explicitly opening and then closing a new document _seems_ to avoid this.
                        printWindow.document.open();
                        printWindow.document.close();
                        printWindow.document.head.innerHTML = "\n                                <meta charset=\"UTF-8\">\n                                <title>Print View</title>\n                                ";
                        printWindow.document.body.innerHTML = '<div id="print"></div>';
                        react_dom_1.default.render(el, printWindow.document.getElementById("print"));
                    }
                }
            });
        }
    });
    //Fusion template helper commands
    /*
    registerCommand("showOverview", {
        icon: "images/icons/invoke-script",
        selected: () => false,
        enabled: CommandConditions.isNotBusy,
        invoke: (dispatch, getState, viewer, parameters) => {

        }
    });
    */
    (0, command_1.registerCommand)("showTaskPane", {
        iconClass: assets_1.SPRITE_INVOKE_SCRIPT,
        selected: function () { return false; },
        enabled: command_1.CommandConditions.isNotBusy,
        invoke: function (dispatch, _getState) {
            dispatch((0, template_1.setTaskPaneVisibility)(true));
        }
    });
    (0, command_1.registerCommand)("showLegend", {
        iconClass: assets_1.SPRITE_INVOKE_SCRIPT,
        selected: function () { return false; },
        enabled: command_1.CommandConditions.isNotBusy,
        invoke: function (dispatch, _getState) {
            dispatch((0, template_1.setLegendVisibility)(true));
        }
    });
    (0, command_1.registerCommand)("showSelectionPanel", {
        iconClass: assets_1.SPRITE_INVOKE_SCRIPT,
        selected: function () { return false; },
        enabled: command_1.CommandConditions.isNotBusy,
        invoke: function (dispatch, _getState) {
            dispatch((0, template_1.setSelectionPanelVisibility)(true));
        }
    });
}
exports.initDefaultCommands = initDefaultCommands;


/***/ }),

/***/ "./src/api/default-components.tsx":
/*!****************************************!*\
  !*** ./src/api/default-components.tsx ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerDefaultComponents = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var mouse_coordinates_1 = __webpack_require__(/*! ../containers/mouse-coordinates */ "./src/containers/mouse-coordinates.tsx");
var navigator_1 = __webpack_require__(/*! ../containers/navigator */ "./src/containers/navigator.tsx");
var scale_display_1 = __webpack_require__(/*! ../containers/scale-display */ "./src/containers/scale-display.tsx");
var task_pane_1 = __webpack_require__(/*! ../containers/task-pane */ "./src/containers/task-pane.tsx");
var about_1 = __webpack_require__(/*! ../components/about */ "./src/components/about.tsx");
var measure_1 = __webpack_require__(/*! ../containers/measure */ "./src/containers/measure.tsx");
var base_layer_switcher_1 = __webpack_require__(/*! ../containers/base-layer-switcher */ "./src/containers/base-layer-switcher.tsx");
var map_menu_1 = __webpack_require__(/*! ../containers/map-menu */ "./src/containers/map-menu.tsx");
var coordinate_tracker_1 = __webpack_require__(/*! ../containers/coordinate-tracker */ "./src/containers/coordinate-tracker.tsx");
var add_manage_layers_1 = __webpack_require__(/*! ../containers/add-manage-layers */ "./src/containers/add-manage-layers.tsx");
var component_1 = __webpack_require__(/*! ../api/registry/component */ "./src/api/registry/component.tsx");
var view_size_1 = __webpack_require__(/*! ../containers/view-size */ "./src/containers/view-size.tsx");
var share_link_to_view_1 = __webpack_require__(/*! ../containers/share-link-to-view */ "./src/containers/share-link-to-view.tsx");
/**
 * Registers the default set of components
 *
 * @export
 */
function registerDefaultComponents() {
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.Navigator, function (props) { return React.createElement(navigator_1.NavigatorContainer, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.MouseCoordinates, function (props) { return React.createElement(mouse_coordinates_1.MouseCoordinatesContainer, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.ScaleDisplay, function (props) { return React.createElement(scale_display_1.ScaleDisplayContainer, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.TaskPane, function (props) { return React.createElement(task_pane_1.TaskPaneContainer, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.About, function (props) { return React.createElement(about_1.About, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.Measure, function (props) { return React.createElement(measure_1.MeasureContainer, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.BaseMapSwitcher, function (props) { return React.createElement(base_layer_switcher_1.BaseLayerSwitcherContainer, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.MapMenu, function (props) { return React.createElement(map_menu_1.MapMenuContainer, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.ViewSize, function (props) { return React.createElement(view_size_1.ViewSizeContainer, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.CoordinateTracker, function (props) { return React.createElement(coordinate_tracker_1.CoordinateTrackerContainer, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.AddManageLayers, function (props) { return React.createElement(add_manage_layers_1.AddManageLayersContainer, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.ShareLinkToView, function (props) { return React.createElement(share_link_to_view_1.ShareLinkToViewContainer, (0, tslib_1.__assign)({}, props)); });
}
exports.registerDefaultComponents = registerDefaultComponents;


/***/ }),

/***/ "./src/api/error.ts":
/*!**************************!*\
  !*** ./src/api/error.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSessionExpiredError = exports.MgError = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/**
 * The base of any viewer-related error
 *
 * @export
 * @class MgError
 * @extends {Error}
 */
var MgError = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(MgError, _super);
    function MgError(message) {
        var _this = _super.call(this, message) || this;
        _this.message = message;
        _this.name = "MgError";
        _this.message = message;
        _this.stack = new Error().stack;
        return _this;
    }
    return MgError;
}(Error));
exports.MgError = MgError;
/**
 * Indicates if this error is a session expired error
 *
 * @export
 * @param {MgError} err
 * @returns {boolean}
 */
function isSessionExpiredError(err) {
    return err.message.indexOf("MgSessionExpiredException") >= 0;
}
exports.isSessionExpiredError = isSessionExpiredError;


/***/ }),

/***/ "./src/api/expr-eval-context.ts":
/*!**************************************!*\
  !*** ./src/api/expr-eval-context.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExprEvalContext = void 0;
var expr_eval_1 = __webpack_require__(/*! expr-eval */ "./node_modules/expr-eval/dist/index.mjs");
var string_1 = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");
var ol_style_helpers_1 = __webpack_require__(/*! ./ol-style-helpers */ "./src/api/ol-style-helpers.ts");
var ExprEvalContext = /** @class */ (function () {
    function ExprEvalContext() {
        this.exprCache = {};
        this.filterCache = {};
        this.clusterExprCache = {};
        this.clusterFilterCache = {};
        this.parser = new expr_eval_1.Parser();
        this.parser.functions.agg_sum = function (collectionProperty, property) {
            if (Array.isArray(collectionProperty)) {
                var res = collectionProperty.reduce(function (running, currentItem) { var _a; return running + ((_a = currentItem.get(property)) !== null && _a !== void 0 ? _a : 0); }, 0);
                return res;
            }
            return undefined;
        };
        this.parser.functions.arr_size = function (collectionProperty) {
            if (Array.isArray(collectionProperty)) {
                return collectionProperty.length;
            }
            return 1;
        };
        this.parser.functions.feat_property = function (feature, name) {
            if (feature) {
                return feature.get(name);
            }
            else {
                return undefined;
            }
        };
    }
    ExprEvalContext.prototype.addFilter = function (expr) {
        if (!this.filterCache[expr]) {
            this.filterCache[expr] = this.parser.parse(expr);
        }
    };
    ExprEvalContext.prototype.addExpr = function (expr) {
        if (!this.exprCache[expr]) {
            this.exprCache[expr] = this.parser.parse(expr);
        }
    };
    ExprEvalContext.prototype.addClusterFilter = function (expr) {
        if (!this.clusterFilterCache[expr]) {
            this.clusterFilterCache[expr] = this.parser.parse(expr);
        }
    };
    ExprEvalContext.prototype.addClusterExpr = function (expr) {
        if (!this.clusterExprCache[expr]) {
            this.clusterExprCache[expr] = this.parser.parse(expr);
        }
    };
    ExprEvalContext.prototype.cleanValues = function (feat) {
        var vals = feat.getProperties();
        //UGLY: We have no guarantee that the properties in question will not have
        //spaces in them (that will break evaluation), so force the matter by replacing
        //spaces with underscores. What this means is if we find a property named "OFFICE TYPE", it
        //will be converted to "OFFICE_TYPE"
        var keys = Object.keys(vals);
        var cvals = {};
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var k = keys_1[_i];
            cvals[(0, string_1.strReplaceAll)(k, " ", "_")] = vals[k];
        }
        return cvals;
    };
    ExprEvalContext.prototype.evaluateFilter = function (feat) {
        var cvals = this.cleanValues(feat);
        var cache = (0, ol_style_helpers_1.isClusteredFeature)(feat) ? this.clusterFilterCache : this.filterCache;
        for (var filter in cache) {
            // Does this feature match an expression?
            if (cache[filter].evaluate(cvals) == true) {
                return filter;
            }
        }
        return undefined;
    };
    ExprEvalContext.prototype.evaluate = function (expr, feat) {
        var cvals = this.cleanValues(feat);
        if ((0, ol_style_helpers_1.isClusteredFeature)(feat)) {
            this.addClusterExpr(expr);
            return this.clusterExprCache[expr].evaluate(cvals);
        }
        else {
            this.addExpr(expr);
            return this.exprCache[expr].evaluate(cvals);
        }
    };
    return ExprEvalContext;
}());
exports.ExprEvalContext = ExprEvalContext;


/***/ }),

/***/ "./src/api/generic-layer-set.ts":
/*!**************************************!*\
  !*** ./src/api/generic-layer-set.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenericLayerSetOL = exports.DEFAULT_METERS_PER_UNIT = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var base_layer_set_1 = __webpack_require__(/*! ./base-layer-set */ "./src/api/base-layer-set.ts");
var Tile_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Tile */ "./node_modules/ol/layer/Tile.js"));
var Image_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Image */ "./node_modules/ol/layer/Image.js"));
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
var number_1 = __webpack_require__(/*! ../utils/number */ "./src/utils/number.ts");
exports.DEFAULT_METERS_PER_UNIT = 1.0;
var M_TO_IN = 39.37;
var DEFAULT_DPI = 96;
/**
 * @hidden
 */
var GenericLayerSetOL = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(GenericLayerSetOL, _super);
    function GenericLayerSetOL(view, subjectLayer, extent, externalBaseLayersGroup, projection, metersPerUnit, dpi) {
        if (metersPerUnit === void 0) { metersPerUnit = exports.DEFAULT_METERS_PER_UNIT; }
        if (dpi === void 0) { dpi = DEFAULT_DPI; }
        var _this = _super.call(this, externalBaseLayersGroup, projection, dpi, extent, M_TO_IN * metersPerUnit, view) || this;
        _this.subjectLayer = subjectLayer;
        return _this;
    }
    GenericLayerSetOL.prototype.getLayers = function () {
        var layers = [];
        if (this.externalBaseLayersGroup) {
            layers.push(this.externalBaseLayersGroup);
        }
        if (this.subjectLayer) {
            layers.push(this.subjectLayer);
        }
        return layers;
    };
    GenericLayerSetOL.prototype.getSourcesForProgressTracking = function () {
        var sources = [];
        if (this.externalBaseLayersGroup) {
            var bls = this.externalBaseLayersGroup.getLayersArray();
            for (var _i = 0, bls_1 = bls; _i < bls_1.length; _i++) {
                var bl = bls_1[_i];
                if (bl instanceof Image_1.default || bl instanceof Tile_1.default) {
                    sources.push(bl.getSource());
                }
            }
        }
        if (this.subjectLayer instanceof Image_1.default) {
            sources.push(this.subjectLayer.getSource());
        }
        else if (this.subjectLayer instanceof Tile_1.default) {
            sources.push(this.subjectLayer.getSource());
        }
        return sources;
    };
    GenericLayerSetOL.prototype.updateTransparency = function (trans) {
        //If no external layers defined, this won't be set
        if (this.externalBaseLayersGroup) {
            if (constants_1.LAYER_ID_BASE in trans) {
                this.externalBaseLayersGroup.setOpacity((0, number_1.restrictToRange)(trans[constants_1.LAYER_ID_BASE], 0, 1.0));
            }
            else {
                this.externalBaseLayersGroup.setOpacity(1.0);
            }
        }
        if (this.subjectLayer) {
            if (constants_1.LAYER_ID_MG_BASE in trans) {
                var opacity = (0, number_1.restrictToRange)(trans[constants_1.LAYER_ID_MG_BASE], 0, 1.0);
                this.subjectLayer.setOpacity(opacity);
            }
            else {
                this.subjectLayer.setOpacity(1.0);
            }
        }
    };
    GenericLayerSetOL.prototype.showActiveSelectedFeature = function (mapExtent, size, uri) {
        //throw new Error("Method not implemented.");
    };
    GenericLayerSetOL.prototype.update = function (showGroups, showLayers, hideGroups, hideLayers) {
        //throw new Error("Method not implemented.");
    };
    GenericLayerSetOL.prototype.updateSelectionColor = function (color) {
        //throw new Error("Method not implemented.");
    };
    return GenericLayerSetOL;
}(base_layer_set_1.BaseLayerSetOL));
exports.GenericLayerSetOL = GenericLayerSetOL;


/***/ }),

/***/ "./src/api/i18n.ts":
/*!*************************!*\
  !*** ./src/api/i18n.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tr = exports.fmt = exports.registerStringBundle = exports.DEFAULT_LOCALE = void 0;
var en_1 = __webpack_require__(/*! ../strings/en */ "./src/strings/en.ts");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
exports.DEFAULT_LOCALE = "en";
var STRINGS = {
    "en": en_1.STRINGS_EN
};
/**
 * Registers a string bundle for the given locale
 *
 * @export
 * @param {string} locale
 * @param {ILocalizedMessages} bundle
 */
function registerStringBundle(locale, bundle) {
    STRINGS[locale] = bundle;
}
exports.registerStringBundle = registerStringBundle;
/**
 * Formats the specified string and substitutes any placeholders (enclosed in {})
 * with the specified arguments
 *
 * @export
 * @param {string} format
 * @param {*} [args]
 * @returns {string}
 */
function fmt(format, args) {
    var str = format;
    if (args != null) {
        for (var p in args) {
            //str = str.replace(new RegExp(`\{${p}\}`, "g"), `${args[p]}`);
            str = str.split("{" + p + "}").join(args[p]);
        }
        return str;
    }
    ;
    return str;
}
exports.fmt = fmt;
/**
 * Returns the localized string for the given key
 *
 * @export
 * @param {keyof ILocalizedMessages} key Any property name of {@link ILocalizedMessages}
 * @param {string} [locale="en"]
 * @param {*} [args] If a localized string has placeholders, they will be replaced with the values defined here
 * @returns {string}
 */
function tr(key, locale, args) {
    if (locale === void 0) { locale = exports.DEFAULT_LOCALE; }
    var bundle = STRINGS[locale];
    if (!bundle) {
        (0, logger_1.warn)("No such string bundle for locale: " + locale);
        return key;
    }
    else {
        var str = bundle[key];
        if (!str) {
            (0, logger_1.warn)("String bundle for locale (" + locale + ") is missing localized string for key: " + key);
            return key;
        }
        else {
            if (args != null) {
                return fmt(str, args);
            }
            return str;
        }
    }
}
exports.tr = tr;


/***/ }),

/***/ "./src/api/layer-manager.ts":
/*!**********************************!*\
  !*** ./src/api/layer-manager.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LayerManager = exports.getLayerInfo = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var common_1 = __webpack_require__(/*! ./common */ "./src/api/common.ts");
var Vector_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/Vector */ "./node_modules/ol/source/Vector.js"));
var ol_style_helpers_1 = __webpack_require__(/*! ./ol-style-helpers */ "./src/api/ol-style-helpers.ts");
var Tile_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Tile */ "./node_modules/ol/layer/Tile.js"));
var Image_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Image */ "./node_modules/ol/layer/Image.js"));
var ImageWMS_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/ImageWMS */ "./node_modules/ol/source/ImageWMS.js"));
var TileWMS_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/TileWMS */ "./node_modules/ol/source/TileWMS.js"));
var Vector_2 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Vector */ "./node_modules/ol/layer/Vector.js"));
var Heatmap_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Heatmap */ "./node_modules/ol/layer/Heatmap.js"));
var driver_registry_1 = __webpack_require__(/*! ./layer-manager/driver-registry */ "./src/api/layer-manager/driver-registry.ts");
var i18n_1 = __webpack_require__(/*! ./i18n */ "./src/api/i18n.ts");
var ol_style_contracts_1 = __webpack_require__(/*! ./ol-style-contracts */ "./src/api/ol-style-contracts.ts");
var external_layer_factory_1 = __webpack_require__(/*! ../components/external-layer-factory */ "./src/components/external-layer-factory.ts");
var colorbrewer_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! colorbrewer */ "./node_modules/colorbrewer/index.es.js"));
var string_1 = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");
var color_brewer_1 = __webpack_require__(/*! ../components/layer-manager/color-brewer */ "./src/components/layer-manager/color-brewer.tsx");
function cloneObject(obj) {
    return JSON.parse(JSON.stringify(obj));
}
function clonePointWithFill(baseTemplate, fillColor) {
    if (!baseTemplate) {
        return undefined;
    }
    var clone = cloneObject(baseTemplate);
    switch (clone.type) {
        case "Circle":
            clone.fill.color = fillColor;
            break;
    }
    return clone;
}
function cloneLineWithFill(baseTemplate, fillColor) {
    if (!baseTemplate) {
        return undefined;
    }
    var clone = cloneObject(baseTemplate);
    clone.color = fillColor;
    return clone;
}
function clonePolyWithFill(baseTemplate, fillColor) {
    if (!baseTemplate) {
        return undefined;
    }
    var clone = cloneObject(baseTemplate);
    clone.fill.color = fillColor;
    return clone;
}
function ensureLabelText(style, expr, isLine) {
    if (isLine === void 0) { isLine = false; }
    if (!style.label) {
        style.label = {
            text: expr,
            textAlign: "left",
            offsetX: 15,
            fill: {
                color: "#000000",
                alpha: 255
            },
            stroke: {
                color: "#ffffff",
                alpha: 255,
                width: 3
            }
        };
        if (isLine) {
            style.label.placement = "line";
        }
    }
    else {
        style.label.text = expr;
    }
}
function ensureLabelTextForStyle(fstyle, expr) {
    if (fstyle.line) {
        ensureLabelText(fstyle.line, expr, true);
    }
    if (fstyle.point) {
        ensureLabelText(fstyle.point, expr);
    }
    if (fstyle.polygon) {
        ensureLabelText(fstyle.polygon, expr);
    }
}
function getLayerInfo(layer, isExternal) {
    var _a, _b;
    var vectorStyle;
    var cs;
    var ext;
    var hs;
    if (layer instanceof Image_1.default || layer instanceof Tile_1.default) {
        var source_1 = layer.getSource();
        if (layer.get(common_1.LayerProperty.HAS_WMS_LEGEND) == true && (source_1 instanceof ImageWMS_1.default || source_1 instanceof TileWMS_1.default)) {
            ext = {
                type: "WMS",
                getLegendUrl: function (res) { return source_1.getLegendUrl(res); }
            };
        }
    }
    if (layer instanceof Vector_2.default) {
        var vs = layer.get(common_1.LayerProperty.VECTOR_STYLE);
        if (vs) {
            vectorStyle = vs.toVectorLayerStyle();
            cs = vs.toClusterSettings();
        }
    }
    if (layer instanceof Heatmap_1.default) {
        hs = {
            blur: layer.getBlur(),
            radius: layer.getRadius()
        };
    }
    return {
        visible: layer.getVisible(),
        selectable: layer.get(common_1.LayerProperty.IS_SELECTABLE) == true,
        name: layer.get(common_1.LayerProperty.LAYER_NAME),
        displayName: (_a = layer.get(common_1.LayerProperty.LAYER_DISPLAY_NAME)) !== null && _a !== void 0 ? _a : layer.get(common_1.LayerProperty.LAYER_NAME),
        description: layer.get(common_1.LayerProperty.LAYER_DESCRIPTION),
        type: layer.get(common_1.LayerProperty.LAYER_TYPE),
        opacity: layer.getOpacity(),
        isExternal: isExternal,
        extensions: ext,
        vectorStyle: vectorStyle,
        cluster: cs,
        heatmap: hs,
        busyWorkerCount: (_b = layer.get(common_1.LayerProperty.BUSY_WORKER_COUNT)) !== null && _b !== void 0 ? _b : 0,
        metadata: layer.get(common_1.LayerProperty.LAYER_METADATA)
    };
}
exports.getLayerInfo = getLayerInfo;
var LayerManager = /** @class */ (function () {
    function LayerManager(map, layerSet) {
        this.map = map;
        this.layerSet = layerSet;
        this._olFormats = (0, driver_registry_1.getFormatDrivers)();
    }
    LayerManager.prototype.tryGetSubjectLayer = function () {
        return this.layerSet.tryGetSubjectLayer();
    };
    /**
     * INTERNAL API
     * @param {IInitialExternalLayer} extLayer
     * @returns
     * @memberof LayerManager
     */
    LayerManager.prototype.addExternalLayer = function (extLayer, onlyAddIfNotExists, appSettings) {
        if (onlyAddIfNotExists && this.hasLayer(extLayer.name)) {
            return undefined;
        }
        return this.layerSet.addExternalLayer(this.map, extLayer, appSettings);
    };
    LayerManager.prototype.getLayers = function () {
        return this.layerSet.getCustomLayers(this.map);
    };
    LayerManager.prototype.hasLayer = function (name) {
        return this.layerSet.hasLayer(name);
    };
    LayerManager.prototype.addLayer = function (name, layer, allowReplace) {
        return this.layerSet.addLayer(this.map, name, layer, allowReplace);
    };
    LayerManager.prototype.removeLayer = function (name) {
        return this.layerSet.removeLayer(this.map, name);
    };
    LayerManager.prototype.getLayer = function (name) {
        return this.layerSet.getLayer(name);
    };
    LayerManager.prototype.apply = function (layers) {
        this.layerSet.apply(this.map, layers);
    };
    LayerManager.prototype.parseFeaturesFromFile = function (options) {
        var file = options.file, layerName = options.name, locale = options.locale;
        var that = this;
        return new Promise(function (resolve, reject) {
            var reader = new FileReader();
            var handler = function (e) {
                var _a;
                return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
                    var result, formats, loadedType, bLoaded, i, ii, format, e_1;
                    return (0, tslib_1.__generator)(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                result = (_a = e.target) === null || _a === void 0 ? void 0 : _a.result;
                                if (!(result && typeof (result) == 'string')) return [3 /*break*/, 8];
                                formats = that._olFormats;
                                if (formats.length == 0) {
                                    reject(new Error((0, i18n_1.tr)("ADD_LOCAL_FILE_LAYER_FAILURE_NO_FORMATS", locale)));
                                }
                                loadedType = void 0;
                                bLoaded = false;
                                i = 0, ii = formats.length;
                                _b.label = 1;
                            case 1:
                                if (!(i < ii)) return [3 /*break*/, 7];
                                format = formats[i];
                                _b.label = 2;
                            case 2:
                                _b.trys.push([2, 4, , 5]);
                                return [4 /*yield*/, format.tryParse(file.size, result)];
                            case 3:
                                loadedType = _b.sent();
                                return [3 /*break*/, 5];
                            case 4:
                                e_1 = _b.sent();
                                return [3 /*break*/, 5];
                            case 5:
                                if (loadedType && loadedType.hasFeatures()) {
                                    loadedType.name = layerName;
                                    bLoaded = true;
                                    return [3 /*break*/, 7];
                                }
                                _b.label = 6;
                            case 6:
                                ++i;
                                return [3 /*break*/, 1];
                            case 7:
                                if (bLoaded && loadedType) {
                                    resolve(loadedType);
                                }
                                else {
                                    reject(new Error((0, i18n_1.tr)("ADD_LOCAL_FILE_LAYER_FAILURE", locale)));
                                }
                                return [3 /*break*/, 9];
                            case 8:
                                reject(new Error((0, i18n_1.tr)("ADD_LOCAL_FILE_LAYER_FAILURE_NOT_TEXT", locale)));
                                _b.label = 9;
                            case 9: return [2 /*return*/];
                        }
                    });
                });
            };
            reader.addEventListener("load", handler);
            reader.readAsText(file);
        });
    };
    LayerManager.prototype.addLayerFromParsedFeatures = function (options) {
        var _a, _b, _c;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var features, projection, defaultStyle, extraOptions, labelOnProperty, selectedPopupTemplate, metadata, defn, proj, view, source, csArgs, layer, clusterSettings, k, bStyle, values, baseTemplatePoint, baseTemplateLine, baseTemplatePoly, th, ramp, chosenRamp, ruleCount, palette, i, v, filter, style, layerInfo;
            return (0, tslib_1.__generator)(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        features = options.features, projection = options.projection, defaultStyle = options.defaultStyle, extraOptions = options.extraOptions, labelOnProperty = options.labelOnProperty, selectedPopupTemplate = options.selectedPopupTemplate, metadata = options.metadata, defn = options.defn;
                        proj = projection;
                        if (!proj) {
                            view = this.map.getView();
                            proj = view.getProjection();
                        }
                        source = new Vector_1.default();
                        source.set(common_1.SourceProperty.SUPPRESS_LOAD_EVENTS, true);
                        if ((extraOptions === null || extraOptions === void 0 ? void 0 : extraOptions.kind) == "Cluster") {
                            csArgs = {
                                distance: extraOptions.clusterDistance
                            };
                        }
                        if ((extraOptions === null || extraOptions === void 0 ? void 0 : extraOptions.kind) == "Heatmap") {
                            layer = new Heatmap_1.default({
                                source: source,
                                weight: extraOptions.weightProperty
                            });
                        }
                        else {
                            layer = new Vector_2.default({
                                source: (0, external_layer_factory_1.clusterSourceIfRequired)(source, { cluster: csArgs }),
                                className: "external-vector-layer",
                                declutter: true
                            });
                        }
                        return [4 /*yield*/, features.addTo(source, this.map.getView().getProjection(), proj)];
                    case 1:
                        _d.sent();
                        layer.set(common_1.LayerProperty.LAYER_NAME, features.name);
                        layer.set(common_1.LayerProperty.LAYER_DISPLAY_NAME, features.name);
                        layer.set(common_1.LayerProperty.LAYER_TYPE, features.type);
                        layer.set(common_1.LayerProperty.LAYER_DEFN, defn);
                        if ((extraOptions === null || extraOptions === void 0 ? void 0 : extraOptions.kind) == "Heatmap") {
                            layer.set(common_1.LayerProperty.IS_HEATMAP, true);
                        }
                        else {
                            layer.set(common_1.LayerProperty.IS_SELECTABLE, true);
                        }
                        layer.set(common_1.LayerProperty.IS_EXTERNAL, true);
                        layer.set(common_1.LayerProperty.IS_GROUP, false);
                        if (metadata) {
                            layer.set(common_1.LayerProperty.LAYER_METADATA, metadata);
                        }
                        if (selectedPopupTemplate) {
                            layer.set(common_1.LayerProperty.SELECTED_POPUP_CONFIGURATION, selectedPopupTemplate);
                        }
                        if ((extraOptions === null || extraOptions === void 0 ? void 0 : extraOptions.kind) == "Cluster") {
                            clusterSettings = {
                                distance: extraOptions.clusterDistance,
                                onClick: (_a = extraOptions.onClusterClickAction) !== null && _a !== void 0 ? _a : ol_style_contracts_1.ClusterClickAction.ShowPopup,
                                style: cloneObject((_c = (_b = extraOptions.clusterStyle) !== null && _b !== void 0 ? _b : defaultStyle) !== null && _c !== void 0 ? _c : ol_style_contracts_1.DEFAULT_CLUSTERED_LAYER_STYLE)
                            };
                            if (!(0, string_1.strIsNullOrEmpty)(labelOnProperty)) {
                                for (k in clusterSettings.style) {
                                    ensureLabelTextForStyle(clusterSettings.style[k], { expr: "if (arr_size(features) == 1, feat_property(features[0], '" + labelOnProperty + "'), '')" });
                                }
                            }
                        }
                        bStyle = defaultStyle !== null && defaultStyle !== void 0 ? defaultStyle : cloneObject(ol_style_contracts_1.DEFAULT_VECTOR_LAYER_STYLE);
                        if (!features.geometryTypes.includes("Point")) {
                            delete bStyle.default.point;
                            clusterSettings === null || clusterSettings === void 0 ? true : delete clusterSettings.style.default.point;
                        }
                        if (!features.geometryTypes.includes("LineString")) {
                            delete bStyle.default.line;
                            clusterSettings === null || clusterSettings === void 0 ? true : delete clusterSettings.style.default.line;
                        }
                        if (!features.geometryTypes.includes("Polygon")) {
                            delete bStyle.default.polygon;
                            clusterSettings === null || clusterSettings === void 0 ? true : delete clusterSettings.style.default.polygon;
                        }
                        if (!(0, string_1.strIsNullOrEmpty)(labelOnProperty)) {
                            ensureLabelTextForStyle(bStyle.default, { expr: labelOnProperty });
                        }
                        if (!((extraOptions === null || extraOptions === void 0 ? void 0 : extraOptions.kind) == "Theme")) return [3 /*break*/, 3];
                        return [4 /*yield*/, features.getDistinctValues(extraOptions.themeOnProperty)];
                    case 2:
                        values = _d.sent();
                        baseTemplatePoint = bStyle.default.point;
                        baseTemplateLine = bStyle.default.line;
                        baseTemplatePoly = bStyle.default.polygon;
                        th = extraOptions.colorBrewerTheme;
                        ramp = colorbrewer_1.default[th];
                        if (!ramp) {
                            ramp = colorbrewer_1.default.Blues;
                        }
                        chosenRamp = (0, color_brewer_1.getMaxRamp)(ramp);
                        ruleCount = Math.min(values.length, chosenRamp.length);
                        palette = ramp[ruleCount];
                        for (i = 0; i < ruleCount; i++) {
                            v = values[i];
                            filter = extraOptions.themeOnProperty + " == '" + v + "'";
                            style = {
                                label: v,
                                point: clonePointWithFill(baseTemplatePoint, palette[i]),
                                line: cloneLineWithFill(baseTemplateLine, palette[i]),
                                polygon: clonePolyWithFill(baseTemplatePoly, palette[i]),
                            };
                            if (!(0, string_1.strIsNullOrEmpty)(labelOnProperty)) {
                                ensureLabelTextForStyle(style, { expr: labelOnProperty });
                            }
                            bStyle[filter] = style;
                        }
                        _d.label = 3;
                    case 3:
                        if (layer instanceof Vector_2.default) {
                            (0, ol_style_helpers_1.setOLVectorLayerStyle)(layer, bStyle, clusterSettings);
                        }
                        layerInfo = this.addLayer(features.name, layer);
                        return [2 /*return*/, layerInfo];
                }
            });
        });
    };
    return LayerManager;
}());
exports.LayerManager = LayerManager;


/***/ }),

/***/ "./src/api/layer-manager/csv-driver.ts":
/*!*********************************************!*\
  !*** ./src/api/layer-manager/csv-driver.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CSV_COLUMN_ALIASES = exports.CsvFormatDriver = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var GeoJSON_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/format/GeoJSON */ "./node_modules/ol/format/GeoJSON.js"));
var parsed_features_1 = __webpack_require__(/*! ./parsed-features */ "./src/api/layer-manager/parsed-features.ts");
var string_1 = __webpack_require__(/*! ../../utils/string */ "./src/utils/string.ts");
var Papa = __webpack_require__(/*! papaparse */ "./node_modules/papaparse/papaparse.min.js");
var CsvFormatDriver = /** @class */ (function () {
    function CsvFormatDriver(aliases) {
        this.aliases = aliases;
        this.type = "CSV";
    }
    CsvFormatDriver.prototype.tryParse = function (size, text) {
        var aliases = this.aliases;
        var type = this.type;
        return new Promise(function (resolve, reject) {
            Papa.parse(text, {
                header: true,
                complete: function (results) {
                    var _this = this;
                    var _a, _b;
                    if (!results.data || results.data.length == 0) {
                        reject(new Error("No data parsed. Probably not a CSV file"));
                    }
                    else {
                        if (results.meta.fields) {
                            var parsed = void 0;
                            var _loop_1 = function (alias) {
                                if (parsed) {
                                    return "break";
                                }
                                var xc = (_a = results.meta.fields.filter(function (s) { return s.toLowerCase() == alias.xColumn.toLowerCase(); })) === null || _a === void 0 ? void 0 : _a[0];
                                var yc = (_b = results.meta.fields.filter(function (s) { return s.toLowerCase() == alias.yColumn.toLowerCase(); })) === null || _b === void 0 ? void 0 : _b[0];
                                // We found the columns, but before we accept this set, the columns
                                // in question must be numeric. Being CSV and all, we'll use the most
                                // scientific method to determine this: Sample the first row of data /s
                                if (!(0, string_1.strIsNullOrEmpty)(xc) && !(0, string_1.strIsNullOrEmpty)(yc)) {
                                    var first = results.data[0];
                                    var firstX = parseFloat(first[xc]);
                                    var firstY = parseFloat(first[yc]);
                                    if (first && !isNaN(firstX) && !isNaN(firstY)) {
                                        var json = {
                                            type: 'FeatureCollection',
                                            features: []
                                        };
                                        for (var _c = 0, _d = results.data; _c < _d.length; _c++) {
                                            var d = _d[_c];
                                            var x = parseFloat(d[xc]);
                                            var y = parseFloat(d[yc]);
                                            if (!isNaN(x) && !isNaN(y)) {
                                                var f = {
                                                    type: 'Feature',
                                                    geometry: {
                                                        coordinates: [x, y],
                                                        type: 'Point'
                                                    },
                                                    properties: d
                                                };
                                                delete f.properties[xc];
                                                delete f.properties[yc];
                                                json.features.push(f);
                                            }
                                        }
                                        var fmt = new GeoJSON_1.default();
                                        var features_1 = fmt.readFeatures(json);
                                        var propNames = [];
                                        if (features_1.length > 0) {
                                            var first_1 = features_1[0];
                                            for (var _e = 0, _f = first_1.getKeys(); _e < _f.length; _e++) {
                                                var k = _f[_e];
                                                if (k == first_1.getGeometryName()) {
                                                    continue;
                                                }
                                                propNames.push(k);
                                            }
                                        }
                                        var pfs = function () { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () { return (0, tslib_1.__generator)(this, function (_a) {
                                            return [2 /*return*/, features_1];
                                        }); }); };
                                        parsed = new parsed_features_1.ParsedFeatures(type, size, pfs, features_1.length > 0, ["Point"], propNames);
                                        return "break";
                                    }
                                }
                            };
                            //Run through the alias list and see if we get any matches
                            for (var _i = 0, aliases_1 = aliases; _i < aliases_1.length; _i++) {
                                var alias = aliases_1[_i];
                                var state_1 = _loop_1(alias);
                                if (state_1 === "break")
                                    break;
                            }
                            if (parsed) {
                                resolve(parsed);
                            }
                            else {
                                reject(new Error("Data successfully parsed as CSV, but coordinate columns could not be found"));
                            }
                        }
                        else {
                            reject(new Error("No fields found in CSV metadata"));
                        }
                    }
                }
            });
        });
    };
    return CsvFormatDriver;
}());
exports.CsvFormatDriver = CsvFormatDriver;
exports.CSV_COLUMN_ALIASES = [
    { xColumn: "lon", yColumn: "lat" },
    { xColumn: "lng", yColumn: "lat" },
    { xColumn: "longitude", yColumn: "latitude" },
    { xColumn: "x", yColumn: "y" },
    { xColumn: "easting", yColumn: "northing" }
];


/***/ }),

/***/ "./src/api/layer-manager/driver-registry.ts":
/*!**************************************************!*\
  !*** ./src/api/layer-manager/driver-registry.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addFormatDriver = exports.getFormatDrivers = void 0;
var _drivers = [];
function getFormatDrivers() { return _drivers; }
exports.getFormatDrivers = getFormatDrivers;
function addFormatDriver(driver) {
    _drivers.push(driver);
}
exports.addFormatDriver = addFormatDriver;


/***/ }),

/***/ "./src/api/layer-manager/format-driver.ts":
/*!************************************************!*\
  !*** ./src/api/layer-manager/format-driver.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormatDriver = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var parsed_features_1 = __webpack_require__(/*! ./parsed-features */ "./src/api/layer-manager/parsed-features.ts");
/**
 * A default format driver implementation primarily for interfacing with any
 * existing OpenLayers format driver instances
 *
 * @export
 * @class FormatDriver
 * @implements {IFormatDriver}
 * @since 0.13
 */
var FormatDriver = /** @class */ (function () {
    function FormatDriver(type, format, defaultProjection) {
        if (defaultProjection === void 0) { defaultProjection = null; }
        this.type = type;
        this.format = format;
        this.defaultProjection = defaultProjection;
    }
    FormatDriver.prototype.tryParse = function (size, text) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var fs, bHasPoint, bHasLine, bHasPoly, _i, fs_1, f, g, geomTypes, propNames, first, _a, _b, k, features;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_c) {
                fs = this.format.readFeatures(text);
                bHasPoint = false;
                bHasLine = false;
                bHasPoly = false;
                for (_i = 0, fs_1 = fs; _i < fs_1.length; _i++) {
                    f = fs_1[_i];
                    g = f.getGeometry();
                    switch (g === null || g === void 0 ? void 0 : g.getType()) {
                        case "Point":
                            bHasPoint = true;
                            break;
                        case "LineString":
                            bHasLine = true;
                            break;
                        case "LinearRing":
                            bHasLine = true;
                            break;
                        case "Polygon":
                            bHasPoly = true;
                            break;
                        case "MultiPoint":
                            bHasPoint = true;
                            break;
                        case "MultiLineString":
                            bHasLine = true;
                            break;
                        case "MultiPolygon":
                            bHasPoly = true;
                            break;
                        case "GeometryCollection":
                            bHasPoint = true;
                            break;
                        case "Circle":
                            bHasPoly = true;
                            break;
                    }
                }
                geomTypes = [];
                if (bHasPoint) {
                    geomTypes.push("Point");
                }
                if (bHasLine) {
                    geomTypes.push("LineString");
                }
                if (bHasPoly) {
                    geomTypes.push("Polygon");
                }
                propNames = [];
                if (fs.length > 0) {
                    first = fs[0];
                    for (_a = 0, _b = first.getKeys(); _a < _b.length; _a++) {
                        k = _b[_a];
                        if (k == first.getGeometryName()) {
                            continue;
                        }
                        propNames.push(k);
                    }
                }
                features = function () { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () { return (0, tslib_1.__generator)(this, function (_a) {
                    return [2 /*return*/, fs];
                }); }); };
                return [2 /*return*/, new parsed_features_1.ParsedFeatures(this.type, size, features, fs.length > 0, geomTypes, propNames, this.defaultProjection)];
            });
        });
    };
    return FormatDriver;
}());
exports.FormatDriver = FormatDriver;


/***/ }),

/***/ "./src/api/layer-manager/parsed-features.ts":
/*!**************************************************!*\
  !*** ./src/api/layer-manager/parsed-features.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParsedFeatures = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var string_1 = __webpack_require__(/*! ../../utils/string */ "./src/utils/string.ts");
var ParsedFeatures = /** @class */ (function () {
    function ParsedFeatures(type, size, features, hasFeaturesFlag, geometryTypes, propertyNames, projection) {
        if (projection === void 0) { projection = null; }
        this.type = type;
        this.size = size;
        this.features = features;
        this.hasFeaturesFlag = hasFeaturesFlag;
        this.geometryTypes = geometryTypes;
        this.propertyNames = propertyNames;
        this.projection = projection;
    }
    ParsedFeatures.prototype.hasFeatures = function () { return this.hasFeaturesFlag; };
    ParsedFeatures.prototype.addTo = function (source, mapProjection, dataProjection) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var features, _i, features_1, f, g, tg;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.features()];
                    case 1:
                        features = _a.sent();
                        if (dataProjection) {
                            for (_i = 0, features_1 = features; _i < features_1.length; _i++) {
                                f = features_1[_i];
                                g = f.getGeometry();
                                if (g) {
                                    tg = g.transform(dataProjection, mapProjection);
                                    f.setGeometry(tg);
                                }
                            }
                        }
                        source.addFeatures(features);
                        return [2 /*return*/];
                }
            });
        });
    };
    ParsedFeatures.prototype.getDistinctValues = function (propertyName) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var values, features, _i, features_2, f, v;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        values = [];
                        return [4 /*yield*/, this.features()];
                    case 1:
                        features = _a.sent();
                        for (_i = 0, features_2 = features; _i < features_2.length; _i++) {
                            f = features_2[_i];
                            v = f.get(propertyName);
                            if (!(0, string_1.strIsNullOrEmpty)(v) && !values.includes(v))
                                values.push(v);
                        }
                        return [2 /*return*/, values];
                }
            });
        });
    };
    return ParsedFeatures;
}());
exports.ParsedFeatures = ParsedFeatures;


/***/ }),

/***/ "./src/api/layer-set-group-base.ts":
/*!*****************************************!*\
  !*** ./src/api/layer-set-group-base.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LayerSetGroupBase = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var common_1 = __webpack_require__(/*! ./common */ "./src/api/common.ts");
var ol_mapguide_source_factory_1 = __webpack_require__(/*! ./ol-mapguide-source-factory */ "./src/api/ol-mapguide-source-factory.ts");
var layer_manager_1 = __webpack_require__(/*! ./layer-manager */ "./src/api/layer-manager.ts");
var error_1 = __webpack_require__(/*! ./error */ "./src/api/error.ts");
var i18n_1 = __webpack_require__(/*! ./i18n */ "./src/api/i18n.ts");
var ol_style_helpers_1 = __webpack_require__(/*! ./ol-style-helpers */ "./src/api/ol-style-helpers.ts");
var Vector_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Vector */ "./node_modules/ol/layer/Vector.js"));
var Vector_2 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/Vector */ "./node_modules/ol/source/Vector.js"));
var Image_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/Image */ "./node_modules/ol/source/Image.js"));
var TileImage_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/TileImage */ "./node_modules/ol/source/TileImage.js"));
var View_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/View */ "./node_modules/ol/View.js"));
var external_layer_factory_1 = __webpack_require__(/*! ../components/external-layer-factory */ "./src/components/external-layer-factory.ts");
var Tile_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Tile */ "./node_modules/ol/layer/Tile.js"));
var UrlTile_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/UrlTile */ "./node_modules/ol/source/UrlTile.js"));
var Image_2 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Image */ "./node_modules/ol/layer/Image.js"));
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
var Fill_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/Fill */ "./node_modules/ol/style/Fill.js"));
var Stroke_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/Stroke */ "./node_modules/ol/style/Stroke.js"));
var Style_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/Style */ "./node_modules/ol/style/Style.js"));
var Text_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/Text */ "./node_modules/ol/style/Text.js"));
var Heatmap_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Heatmap */ "./node_modules/ol/layer/Heatmap.js"));
var HIGHLIGHT_STYLE = new Style_1.default({
    stroke: new Stroke_1.default({
        color: '#f00',
        width: 3,
    }),
    fill: new Fill_1.default({
        color: 'rgba(255,0,0,0.1)',
    }),
    text: new Text_1.default({
        font: '12px Calibri,sans-serif',
        fill: new Fill_1.default({
            color: '#000',
        }),
        stroke: new Stroke_1.default({
            color: '#f00',
            width: 3,
        }),
    }),
});
var LayerSetGroupBase = /** @class */ (function () {
    function LayerSetGroupBase(callback) {
        var _this = this;
        this.callback = callback;
        this.updateTransparency = function (trans) { return _this.mainSet.updateTransparency(trans); };
        this.fitViewToExtent = function () { return _this.mainSet.view.fit(_this.mainSet.extent); };
        this.getView = function () { return _this.mainSet.view; };
        this.getDpi = function () { return _this.mainSet.dpi; };
        this.getExtent = function () { return _this.mainSet.extent; };
        this.getLayersForOverviewMap = function () { return _this.overviewSet.getLayers(); };
        this.getProjection = function () { return _this.mainSet.projection; };
        this.refreshMap = function (mode) { return _this.mainSet.refreshMap(mode); };
        this.showActiveSelectedFeature = function (mapExtent, size, uri) { return _this.mainSet.showActiveSelectedFeature(mapExtent, size, uri); };
        this.getMetersPerUnit = function () { return _this.mainSet.getMetersPerUnit(); };
        this.scaleToResolution = function (scale) { return _this.mainSet.scaleToResolution(scale); };
        this.resolutionToScale = function (resolution) { return _this.mainSet.resolutionToScale(resolution); };
        this._customLayers = {};
        this.scratchLayer = new Vector_1.default({
            source: new Vector_2.default()
        });
        this.scratchLayer.set(common_1.LayerProperty.LAYER_NAME, "__SCRATCH__"); //NOXLATE
        this.scratchLayer.set(common_1.LayerProperty.IS_SCRATCH, true);
        this.wmsSelOverlayLayer = new Vector_1.default({
            source: new Vector_2.default()
        });
        this.wmsSelOverlayLayer.set(common_1.LayerProperty.LAYER_NAME, "__WMS_SELECTION_OVERLAY__");
        this.wmsSelOverlayLayer.set(common_1.LayerProperty.IS_WMS_SELECTION_OVERLAY, true);
        this.hoverHighlightLayer = new Vector_1.default({
            source: new Vector_2.default(),
            style: function (feature) {
                return HIGHLIGHT_STYLE;
            }
        });
        this.hoverHighlightLayer.set(common_1.LayerProperty.LAYER_NAME, "__HOVER_HIGHLIGHT__"); //NOXLATE
        this.hoverHighlightLayer.set(common_1.LayerProperty.IS_HOVER_HIGHLIGHT, true);
    }
    LayerSetGroupBase.prototype.addHighlightedFeature = function (feature) {
        this.hoverHighlightLayer.getSource().addFeature(feature);
    };
    LayerSetGroupBase.prototype.removeHighlightedFeature = function (feature) {
        var hs = this.hoverHighlightLayer.getSource();
        if (hs.hasFeature(feature)) {
            hs.removeFeature(feature);
        }
    };
    LayerSetGroupBase.prototype.clearHighlightedFeatures = function () {
        this.hoverHighlightLayer.getSource().clear();
    };
    /**
     * @virtual
     * @returns {(LayerBase | undefined)}
     * @memberof LayerSetGroupBase
     */
    LayerSetGroupBase.prototype.tryGetSubjectLayer = function () { return undefined; };
    LayerSetGroupBase.prototype.addWmsSelectionOverlay = function (feat) {
        this.wmsSelOverlayLayer.getSource().addFeature(feat);
    };
    LayerSetGroupBase.prototype.clearWmsSelectionOverlay = function () {
        this.wmsSelOverlayLayer.getSource().clear();
    };
    LayerSetGroupBase.prototype.addScratchFeature = function (feat) {
        this.scratchLayer.getSource().addFeature(feat);
    };
    LayerSetGroupBase.prototype.clearScratchLayer = function () {
        this.scratchLayer.getSource().clear();
    };
    LayerSetGroupBase.prototype.registerSourceEvents = function (source) {
        if (source instanceof Image_1.default) {
            source.on("imageloadstart", this.callback.addImageLoading);
            //onImageError is a MapGuide-specific callback
            if ((0, ol_mapguide_source_factory_1.isMapGuideImageSource)(source)) {
                source.on("imageloaderror", this.callback.onImageError);
            }
            source.on("imageloaderror", this.callback.addImageLoaded);
            source.on("imageloadend", this.callback.addImageLoaded);
        }
        else if (source instanceof TileImage_1.default) {
            source.on("tileloadstart", this.callback.addImageLoading);
            source.on("tileloaderror", this.callback.addImageLoaded);
            source.on("tileloadend", this.callback.addImageLoaded);
        }
    };
    LayerSetGroupBase.prototype.updateExternalBaseLayers = function (externalBaseLayers) {
        this.mainSet.updateExternalBaseLayers(externalBaseLayers);
        this.overviewSet.updateExternalBaseLayers(externalBaseLayers);
    };
    LayerSetGroupBase.prototype.attach = function (map, ovMapControl, bSetLayers) {
        var _this = this;
        if (bSetLayers === void 0) { bSetLayers = true; }
        // To guard against the possibility that we may be attaching layers to a map that
        // already has layers (eg. Measurements), we reverse iterate all the layers we need to
        // add and insert them to the front one-by-one, ensuring all the layers we add will be
        // at the bottom of the draw order
        var layers = map.getLayers();
        // Attach hover layers
        layers.insertAt(0, this.hoverHighlightLayer);
        // Attach scratch layer
        layers.insertAt(0, this.scratchLayer);
        // Attach custom layers
        var customLayers = Object.keys(this._customLayers).map(function (k) { return _this._customLayers[k]; });
        customLayers.sort(function (a, b) {
            return a.order - b.order;
        });
        // External layers may have been pre-loaded, to clear out any existing external layers
        for (var _i = 0, customLayers_1 = customLayers; _i < customLayers_1.length; _i++) {
            var item = customLayers_1[_i];
            layers.remove(item.layer);
        }
        for (var _a = 0, customLayers_2 = customLayers; _a < customLayers_2.length; _a++) {
            var item = customLayers_2[_a];
            layers.insertAt(0, item.layer);
        }
        // Then the regular layers
        var allLayers = this.mainSet.getLayers();
        for (var i = allLayers.length - 1; i >= 0; i--) {
            layers.insertAt(0, allLayers[i]);
        }
        map.setView(this.mainSet.view);
        if (bSetLayers) {
            var ovMap = ovMapControl.getOverviewMap();
            var ovLayers = this.getLayersForOverviewMap();
            for (var _b = 0, ovLayers_1 = ovLayers; _b < ovLayers_1.length; _b++) {
                var layer = ovLayers_1[_b];
                ovMap.addLayer(layer);
            }
            //ol.View has immutable projection, so we have to replace the whole view on the OverviewMap
            var center = this.mainSet.view.getCenter();
            if (center) {
                ovMap.setView(new View_1.default({
                    center: [center[0], center[1]],
                    resolution: this.mainSet.view.getResolution(),
                    projection: this.mainSet.view.getProjection()
                }));
            }
            else {
                var view = new View_1.default({
                    projection: this.mainSet.view.getProjection()
                });
                ovMap.setView(view);
                view.fit(this.mainSet.extent, { size: ovMap.getSize() });
            }
        }
    };
    LayerSetGroupBase.prototype.detach = function (map, ovMapControl) {
        var allLayers = this.mainSet.getLayers();
        for (var _i = 0, allLayers_1 = allLayers; _i < allLayers_1.length; _i++) {
            var layer = allLayers_1[_i];
            map.removeLayer(layer);
        }
        //Detach custom layers
        for (var layerName in this._customLayers) {
            map.removeLayer(this._customLayers[layerName].layer);
        }
        //Detach scratch layer
        map.removeLayer(this.scratchLayer);
        //Detach hover highlight layer
        map.removeLayer(this.hoverHighlightLayer);
        var ovLayers = this.getLayersForOverviewMap();
        var ovMap = ovMapControl.getOverviewMap();
        for (var _a = 0, ovLayers_2 = ovLayers; _a < ovLayers_2.length; _a++) {
            var layer = ovLayers_2[_a];
            ovMap.removeLayer(layer);
        }
    };
    LayerSetGroupBase.prototype.getCustomLayers = function (map) {
        var _this = this;
        var larr = map.getLayers().getArray();
        var layers = larr
            .filter(function (l) { return _this._customLayers[l.get(common_1.LayerProperty.LAYER_NAME)] != null; })
            .map(function (l) { return ((0, tslib_1.__assign)((0, tslib_1.__assign)({}, (0, layer_manager_1.getLayerInfo)(l, true)), { 
            //Smuggle these values out for debugging purposes
            isSelectable: _this._customLayers[l.get(common_1.LayerProperty.LAYER_NAME)].layer.get(common_1.LayerProperty.IS_SELECTABLE) == true, order: _this._customLayers[l.get(common_1.LayerProperty.LAYER_NAME)].order })); });
        return layers.reverse();
    };
    LayerSetGroupBase.prototype.hasLayer = function (name) {
        return this._customLayers[name] != null;
    };
    LayerSetGroupBase.prototype.addExternalLayer = function (map, extLayer, appSettings) {
        var layer = (0, external_layer_factory_1.createOLLayerFromSubjectDefn)(extLayer, map.getView().getProjection(), true, appSettings);
        return this.addLayer(map, extLayer.name, layer);
    };
    LayerSetGroupBase.prototype.addLayer = function (map, name, layer, allowReplace) {
        var bAllow = !!allowReplace;
        if (this._customLayers[name]) {
            if (!bAllow) {
                throw new error_1.MgError((0, i18n_1.tr)("LAYER_NAME_EXISTS", this.callback.getLocale(), { name: name }));
            }
            else {
                //Remove the layer that is about to be replaced first 
                map.removeLayer(this._customLayers[name].layer);
            }
        }
        //These layer properties may have already been set, so only set if not set already (display name) or it is different (layer name)
        if (layer.get(common_1.LayerProperty.LAYER_NAME) != name)
            layer.set(common_1.LayerProperty.LAYER_NAME, name);
        if (!layer.get(common_1.LayerProperty.LAYER_DISPLAY_NAME))
            layer.set(common_1.LayerProperty.LAYER_DISPLAY_NAME, name);
        //console.log(`addLayer(): ${layer.get(LayerProperty.LAYER_NAME)}`);
        //HACK: For reasons unknown, measurement layers aren't being cleanly detached/attached during apply() so there is a possibility
        //we are re-adding this measurement layer (from measure context activation), and the layer is already there!
        //
        //So as a nuclear solution, remove the layer we're about to add (as un-intutitive as that sounds!)
        map.removeLayer(layer);
        map.addLayer(layer);
        this._customLayers[name] = { layer: layer, order: map.getLayers().getArray().indexOf(layer) };
        var tileLoaders = this.callback.getTileLoaders();
        for (var k in tileLoaders) {
            var func = tileLoaders[k];
            var layer_1 = this.getLayer(k);
            if (layer_1) {
                if (layer_1 instanceof Tile_1.default) {
                    var source = layer_1.getSource();
                    if (source instanceof UrlTile_1.default) {
                        source.setTileLoadFunction(func);
                        (0, logger_1.debug)("Added custom tile loader for layer: " + k);
                    } /* else {
                        warn(`Layer has a source is not a valid candidate for adding a custom tile loader: ${k}`);
                    }*/
                } /* else {
                    warn(`Layer is not a valid candidate for adding a custom tile loader: ${k}`);
                }*/
            }
        }
        var imageLoaders = this.callback.getImageLoaders();
        for (var k in imageLoaders) {
            var func = imageLoaders[k];
            var layer_2 = this.getLayer(k);
            if (layer_2) {
                if (layer_2 instanceof Image_2.default) {
                    var source = layer_2.getSource();
                    if (typeof (source.setImageLoadFunction) == 'function') {
                        source.setImageLoadFunction(func);
                        (0, logger_1.debug)("Added custom tile loader for layer: " + k);
                    } /* else {
                        warn(`Layer has a source is not a valid candidate for adding a custom tile loader: ${k}`);
                    }*/
                } /* else {
                    warn(`Layer is not a valid candidate for adding a custom tile loader: ${k}`);
                }*/
            }
        }
        return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, (0, layer_manager_1.getLayerInfo)(layer, true)), {
            isSelectable: this._customLayers[name].layer.get(common_1.LayerProperty.IS_SELECTABLE) == true,
            order: this._customLayers[name].order
        });
    };
    LayerSetGroupBase.prototype.removeLayer = function (map, name) {
        var layer;
        if (this._customLayers[name]) {
            layer = this._customLayers[name].layer;
            //console.log(`removeLayer(): ${layer.get(LayerProperty.LAYER_NAME)}`);
            map.removeLayer(layer);
            delete this._customLayers[name];
            return layer;
        }
    };
    LayerSetGroupBase.prototype.getLayer = function (name) {
        var _a;
        var layer;
        if (this._customLayers[name]) {
            layer = (_a = this._customLayers[name]) === null || _a === void 0 ? void 0 : _a.layer;
        }
        return layer;
    };
    LayerSetGroupBase.prototype.apply = function (map, layers) {
        var _a;
        var layersByName = layers.reduce(function (current, layer) {
            current[layer.name] = layer;
            return current;
        }, {});
        //Apply opacity/visibility/styling and other top-level properties
        for (var _i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
            var layer = layers_1[_i];
            var oll = (_a = this._customLayers[layer.name]) === null || _a === void 0 ? void 0 : _a.layer;
            if (oll) {
                oll.setVisible(layer.visible);
                oll.setOpacity(layer.opacity);
                oll.set(common_1.LayerProperty.BUSY_WORKER_COUNT, layer.busyWorkerCount);
                if (oll instanceof Vector_1.default && layer.vectorStyle) {
                    (0, ol_style_helpers_1.setOLVectorLayerStyle)(oll, layer.vectorStyle, layer.cluster);
                }
                if (layer.heatmap) {
                    if (oll instanceof Heatmap_1.default) {
                        oll.setBlur(layer.heatmap.blur);
                        oll.setRadius(layer.heatmap.radius);
                    }
                }
            }
        }
        //Measurement layer is hidden and is not tracked by the layer manager (in terms of round-tripped layer information)
        //so if it is present in our custom layers set, it may be removed. So if we find it, capture it for restoration
        var theMeasureLayer;
        //Apply removals 
        for (var layerName in this._customLayers) {
            if (!layersByName[layerName]) {
                var removed = this.removeLayer(map, layerName);
                if ((removed === null || removed === void 0 ? void 0 : removed.get(common_1.LayerProperty.IS_MEASURE)) === true) {
                    //console.log(`Removed measurement layer: ${removed.get(LayerProperty.LAYER_NAME)}`);
                    theMeasureLayer = removed;
                }
            }
        }
        //Fix order if required
        //First item, top-most
        //Last item, bottom-most
        var cCurrentLayers = map.getLayers();
        var aCurrentLayers = cCurrentLayers.getArray();
        var currentLayers = aCurrentLayers.map(function (l) { return ({
            name: l.get(common_1.LayerProperty.LAYER_NAME),
            type: l.get(common_1.LayerProperty.LAYER_TYPE),
            isExternal: l.get(common_1.LayerProperty.IS_EXTERNAL),
            isGroup: l.get(common_1.LayerProperty.IS_GROUP),
            layer: l
        }); }).filter(function (l) { return l.isExternal == true; });
        //console.assert(currentLayers.length == layers.length);
        //console.table(currentLayers);
        //console.table(layers);
        //If sizes don't match, do a full invalidation
        if (currentLayers.length != layers.length) {
            //Clear everything custom
            for (var _b = 0, currentLayers_1 = currentLayers; _b < currentLayers_1.length; _b++) {
                var toRemove = currentLayers_1[_b];
                map.removeLayer(toRemove.layer);
            }
            for (var rn in this._customLayers) {
                var toRemove = this._customLayers[rn];
                map.removeLayer(toRemove.layer);
            }
            //Re-add in order according to layers array
            for (var i = layers.length - 1; i >= 0; i--) {
                var item = this._customLayers[layers[i].name];
                if (item) {
                    map.addLayer(item.layer);
                    item.order = cCurrentLayers.getArray().indexOf(item.layer);
                }
            }
        }
        else { //Otherwise see if we need to re-order
            var bReorder = false;
            var ii = 0;
            for (var i = layers.length - 1; i >= 0; i--) {
                var layer = layers[i];
                //console.log(`Checking if layer (${layer.name}) needs re-ordering`);
                if (layer.name != currentLayers[ii].name) {
                    bReorder = true;
                    break;
                }
                ii++;
            }
            if (bReorder) {
                //console.log("Re-ordering layers");
                for (var _c = 0, currentLayers_2 = currentLayers; _c < currentLayers_2.length; _c++) {
                    var toRemove = currentLayers_2[_c];
                    map.removeLayer(toRemove.layer);
                }
                var _loop_1 = function (i) {
                    var toAdd = currentLayers.filter(function (l) { return l.name == layers[i].name; })[0];
                    map.addLayer(toAdd.layer);
                    var item = this_1._customLayers[layers[i].name];
                    if (item) {
                        item.order = cCurrentLayers.getArray().indexOf(toAdd.layer);
                    }
                };
                var this_1 = this;
                //Re-add in order according to layers array
                for (var i = layers.length - 1; i >= 0; i--) {
                    _loop_1(i);
                }
            }
        }
        // The scratch layer (where client-side selection overlays and other temp vector features reside) must always be topmost
        if (cCurrentLayers.item(cCurrentLayers.getLength() - 1) != this.scratchLayer) {
            map.removeLayer(this.scratchLayer);
            map.addLayer(this.scratchLayer);
            //const layers2 = cCurrentLayers.getArray();
            //console.log(layers2);
        }
        // And the wms selection overlay layer
        if (cCurrentLayers.item(cCurrentLayers.getLength() - 1) != this.wmsSelOverlayLayer) {
            map.removeLayer(this.wmsSelOverlayLayer);
            map.addLayer(this.wmsSelOverlayLayer);
            //const layers2 = cCurrentLayers.getArray();
            //console.log(layers2);
        }
        // And the hover highlight layer on top of that
        if (cCurrentLayers.item(cCurrentLayers.getLength() - 1) != this.hoverHighlightLayer) {
            map.removeLayer(this.hoverHighlightLayer);
            map.addLayer(this.hoverHighlightLayer);
            //const layers2 = cCurrentLayers.getArray();
            //console.log(layers2);
        }
        // And then the measurement layer, if present
        if (theMeasureLayer) {
            if (cCurrentLayers.item(cCurrentLayers.getLength() - 1) != theMeasureLayer) {
                map.removeLayer(theMeasureLayer);
                map.addLayer(theMeasureLayer);
                //console.log(`Re-adding measurement layer: ${theMeasureLayer.get(LayerProperty.LAYER_NAME)}`);
            }
        }
    };
    return LayerSetGroupBase;
}());
exports.LayerSetGroupBase = LayerSetGroupBase;


/***/ }),

/***/ "./src/api/layer-set.ts":
/*!******************************!*\
  !*** ./src/api/layer-set.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MgInnerLayerSetFactory = exports.MgLayerSetOL = exports.MgLayerSetMode = exports.mockMapGuideImageLoadFunction = exports.blankImageLoadFunction = exports.toProjUnit = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var common_1 = __webpack_require__(/*! ./common */ "./src/api/common.ts");
var Group_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Group */ "./node_modules/ol/layer/Group.js"));
var TileGrid_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/tilegrid/TileGrid */ "./node_modules/ol/tilegrid/TileGrid.js"));
var TileImage_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/TileImage */ "./node_modules/ol/source/TileImage.js"));
var ol_mapguide_source_factory_1 = __webpack_require__(/*! ./ol-mapguide-source-factory */ "./src/api/ol-mapguide-source-factory.ts");
var ImageStatic_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/ImageStatic */ "./node_modules/ol/source/ImageStatic.js"));
var number_1 = __webpack_require__(/*! ../utils/number */ "./src/utils/number.ts");
var View_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/View */ "./node_modules/ol/View.js"));
var olExtent = (0, tslib_1.__importStar)(__webpack_require__(/*! ol/extent */ "./node_modules/ol/extent.js"));
var Tile_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Tile */ "./node_modules/ol/layer/Tile.js"));
var Image_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Image */ "./node_modules/ol/layer/Image.js"));
var external_layer_factory_1 = __webpack_require__(/*! ../components/external-layer-factory */ "./src/components/external-layer-factory.ts");
var string_1 = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");
var url_1 = __webpack_require__(/*! ../utils/url */ "./src/utils/url.ts");
var i18n_1 = __webpack_require__(/*! ./i18n */ "./src/api/i18n.ts");
var olHas = (0, tslib_1.__importStar)(__webpack_require__(/*! ol/has */ "./node_modules/ol/has.js"));
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
var UrlTile_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/UrlTile */ "./node_modules/ol/source/UrlTile.js"));
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
var generic_layer_set_1 = __webpack_require__(/*! ./generic-layer-set */ "./src/api/generic-layer-set.ts");
var proj_1 = __webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js");
var type_guards_1 = __webpack_require__(/*! ../utils/type-guards */ "./src/utils/type-guards.ts");
var error_1 = __webpack_require__(/*! ./error */ "./src/api/error.ts");
var units_1 = __webpack_require__(/*! ../utils/units */ "./src/utils/units.tsx");
var DEFAULT_BOUNDS_3857 = [
    -20026376.39,
    -20048966.10,
    20026376.39,
    20048966.10
];
var DEFAULT_BOUNDS_4326 = [-180, -90, 180, 90];
function getMetersPerUnit(projection) {
    var proj = (0, proj_1.get)(projection);
    return proj.getMetersPerUnit();
}
function toProjUnit(unit) {
    switch (unit) {
        case common_1.UnitOfMeasure.Meters:
            return "m";
        case common_1.UnitOfMeasure.Feet:
            return "ft";
        case common_1.UnitOfMeasure.Inches:
            return "in";
        case common_1.UnitOfMeasure.Centimeters:
            return "cm";
        case common_1.UnitOfMeasure.Kilometers:
            return "km";
        case common_1.UnitOfMeasure.Yards:
            return "yd";
        case common_1.UnitOfMeasure.Millimeters:
            return "mm";
        case common_1.UnitOfMeasure.Miles:
            return "mi";
        case common_1.UnitOfMeasure.NauticalMiles:
            return "nm";
        case common_1.UnitOfMeasure.Pixels:
            return "px";
    }
}
exports.toProjUnit = toProjUnit;
function blankImageLoadFunction(image) {
    image.getImage().src = constants_1.BLANK_GIF_DATA_URI;
}
exports.blankImageLoadFunction = blankImageLoadFunction;
function mockMapGuideImageLoadFunction(image, src) {
    var el = document.getElementById("mg-debug-text-canvas");
    if (!el) {
        el = document.createElement("canvas");
        el.style.visibility = "hidden";
        el.id = "mg-debug-text-canvas";
        document.body.append(el);
    }
    var tCtx = el.getContext("2d");
    if (tCtx) {
        tCtx.clearRect(0, 0, tCtx.canvas.width, tCtx.canvas.height);
        var strings = [];
        var parsed = (0, url_1.parseUrl)(src);
        strings.push("[Mock MapGuide Map Image Request]");
        strings.push("Agent: " + parsed.url);
        var xoff = 10;
        var yoff = 30;
        var fontSize = 14;
        var mm = tCtx.measureText(strings[0]);
        var maxSize = mm.width + xoff;
        var ch = yoff + fontSize + 2;
        maxSize = Math.max(tCtx.measureText(strings[1]).width + xoff, maxSize);
        ch += (fontSize + 2);
        var keys = Object.keys(parsed.query);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var k = keys_1[_i];
            if (k == "MAPNAME" || k == "SETDISPLAYWIDTH" || k == "SETDISPLAYHEIGHT" || k == "SETVIEWCENTERX" || k == "SETVIEWCENTERY" || k == "SETVIEWSCALE") {
                if (!(0, string_1.strIsNullOrEmpty)(parsed.query[k])) {
                    var s = k + ": " + parsed.query[k];
                    strings.push(s);
                    maxSize = Math.max(tCtx.measureText(s).width + xoff, maxSize);
                    ch += (fontSize + 2);
                }
            }
        }
        tCtx.canvas.width = maxSize;
        tCtx.canvas.height = ch;
        tCtx.fillStyle = "rgba(255, 0, 0, 0.5)";
        tCtx.fillRect(0, 0, maxSize, ch);
        tCtx.fillStyle = "rgba(255, 255, 0, 1.0)";
        //console.log(`Canvas size: [${tCtx.canvas.width}, ${tCtx.canvas.height}]`);
        tCtx.font = fontSize + "px sans-serif";
        var y = yoff;
        for (var _a = 0, strings_1 = strings; _a < strings_1.length; _a++) {
            var str = strings_1[_a];
            //console.log(`Draw (${str}) at [10, ${y}]`);
            tCtx.fillText(str, 10, y);
            y += (fontSize + 1);
        }
        image.getImage().src = tCtx.canvas.toDataURL();
    }
}
exports.mockMapGuideImageLoadFunction = mockMapGuideImageLoadFunction;
var MgLayerSetMode;
(function (MgLayerSetMode) {
    MgLayerSetMode[MgLayerSetMode["Stateless"] = 0] = "Stateless";
    MgLayerSetMode[MgLayerSetMode["Stateful"] = 1] = "Stateful";
    MgLayerSetMode[MgLayerSetMode["OverviewMap"] = 2] = "OverviewMap";
})(MgLayerSetMode = exports.MgLayerSetMode || (exports.MgLayerSetMode = {}));
/**
 * @hidden
 */
var MgLayerSetOL = /** @class */ (function () {
    function MgLayerSetOL(mgTiledLayers, externalBaseLayersGroup, overlay, projection, dpi, extent, inPerUnit, view) {
        this.mgTiledLayers = mgTiledLayers;
        this.externalBaseLayersGroup = externalBaseLayersGroup;
        this.overlay = overlay;
        this.projection = projection;
        this.dpi = dpi;
        this.extent = extent;
        this.inPerUnit = inPerUnit;
        this.view = view;
    }
    MgLayerSetOL.prototype.getMetersPerUnit = function () {
        return this.inPerUnit / 39.37;
    };
    MgLayerSetOL.prototype.scaleToResolution = function (scale) {
        return (scale / this.inPerUnit / this.dpi) * olHas.DEVICE_PIXEL_RATIO;
    };
    MgLayerSetOL.prototype.resolutionToScale = function (resolution) {
        return (resolution * this.dpi * this.inPerUnit) / olHas.DEVICE_PIXEL_RATIO;
    };
    MgLayerSetOL.prototype.getSourcesForProgressTracking = function () {
        var sources = [];
        if (this.externalBaseLayersGroup) {
            var bls = this.externalBaseLayersGroup.getLayersArray();
            for (var _i = 0, bls_1 = bls; _i < bls_1.length; _i++) {
                var bl = bls_1[_i];
                if (bl instanceof Image_1.default || bl instanceof Tile_1.default) {
                    sources.push(bl.getSource());
                }
            }
        }
        for (var i = this.mgTiledLayers.length - 1; i >= 0; i--) {
            sources.push(this.mgTiledLayers[i].getSource());
        }
        sources.push(this.overlay.getSource());
        if (this.selectionOverlay) {
            sources.push(this.selectionOverlay.getSource());
        }
        if (this.activeSelectedFeatureOverlay) {
            sources.push(this.activeSelectedFeatureOverlay.getSource());
        }
        return sources;
    };
    MgLayerSetOL.prototype.getLayers = function () {
        var layers = [];
        if (this.externalBaseLayersGroup) {
            layers.push(this.externalBaseLayersGroup);
        }
        for (var i = this.mgTiledLayers.length - 1; i >= 0; i--) {
            layers.push(this.mgTiledLayers[i]);
        }
        layers.push(this.overlay);
        if (this.selectionOverlay) {
            layers.push(this.selectionOverlay);
        }
        if (this.activeSelectedFeatureOverlay) {
            layers.push(this.activeSelectedFeatureOverlay);
        }
        return layers;
    };
    MgLayerSetOL.prototype.update = function (showGroups, showLayers, hideGroups, hideLayers) {
        //Send the request
        var imgSource = this.overlay.getSource(); //olMapGuideSource;
        //NOTE: Even if these group ids being shown/hidden are MG base layer groups, it still has to be
        //done as the server-side snapshot of the runtime map needs to be aware as well. This will be
        //apparent if you were to plot a runtime-map server-side that has base layer groups.
        imgSource.updateParams({
            showlayers: showLayers,
            showgroups: showGroups,
            hidelayers: hideLayers,
            hidegroups: hideGroups
        });
        //As MG base layer groups are separate ol layer instances, we have to toggle them on the client-side as well
        if (showGroups && showGroups.length > 0) {
            var _loop_1 = function (groupId) {
                var match = this_1.mgTiledLayers.filter(function (l) { return l.get(common_1.LayerProperty.LAYER_NAME) === groupId; });
                if (match.length == 1) {
                    match[0].setVisible(true);
                }
            };
            var this_1 = this;
            for (var _i = 0, showGroups_1 = showGroups; _i < showGroups_1.length; _i++) {
                var groupId = showGroups_1[_i];
                _loop_1(groupId);
            }
        }
        if (hideGroups && hideGroups.length > 0) {
            var _loop_2 = function (groupId) {
                var match = this_2.mgTiledLayers.filter(function (l) { return l.get(common_1.LayerProperty.LAYER_NAME) === groupId; });
                if (match.length == 1) {
                    match[0].setVisible(false);
                }
            };
            var this_2 = this;
            for (var _a = 0, hideGroups_1 = hideGroups; _a < hideGroups_1.length; _a++) {
                var groupId = hideGroups_1[_a];
                _loop_2(groupId);
            }
        }
    };
    MgLayerSetOL.prototype.updateSelectionColor = function (color) {
        if (this.selectionOverlay) {
            var source = this.selectionOverlay.getSource(); // olMapGuideSource;
            source.updateParams({
                SELECTIONCOLOR: color
            });
        }
    };
    MgLayerSetOL.prototype.updateExternalBaseLayers = function (externalBaseLayers) {
        if (this.externalBaseLayersGroup) {
            var layers = this.externalBaseLayersGroup.getLayers();
            layers.forEach(function (l) {
                var match = (externalBaseLayers || []).filter(function (el) { return el.name === l.get("title"); });
                if (match.length == 1) {
                    l.setVisible(!!match[0].visible);
                }
                else {
                    l.setVisible(false);
                }
            });
        }
    };
    MgLayerSetOL.prototype.updateTransparency = function (trans) {
        //If no external layers defined, this won't be set
        if (this.externalBaseLayersGroup) {
            if (constants_1.LAYER_ID_BASE in trans) {
                this.externalBaseLayersGroup.setOpacity((0, number_1.restrictToRange)(trans[constants_1.LAYER_ID_BASE], 0, 1.0));
            }
            else {
                this.externalBaseLayersGroup.setOpacity(1.0);
            }
        }
        if (constants_1.LAYER_ID_MG_BASE in trans) {
            var opacity = (0, number_1.restrictToRange)(trans[constants_1.LAYER_ID_MG_BASE], 0, 1.0);
            this.overlay.setOpacity(opacity);
            for (var _i = 0, _a = this.mgTiledLayers; _i < _a.length; _i++) {
                var group = _a[_i];
                group.setOpacity(opacity);
            }
        }
        else {
            this.overlay.setOpacity(1.0);
            for (var _b = 0, _c = this.mgTiledLayers; _b < _c.length; _b++) {
                var group = _c[_b];
                group.setOpacity(1.0);
            }
        }
        if (this.selectionOverlay) {
            if (constants_1.LAYER_ID_MG_SEL_OVERLAY in trans) {
                this.selectionOverlay.setOpacity((0, number_1.restrictToRange)(trans[constants_1.LAYER_ID_MG_SEL_OVERLAY], 0, 1.0));
            }
            else {
                this.selectionOverlay.setOpacity(1.0);
            }
        }
    };
    MgLayerSetOL.prototype.refreshMap = function (mode) {
        if (mode === void 0) { mode = common_1.RefreshMode.LayersOnly | common_1.RefreshMode.SelectionOnly; }
        if ((mode & common_1.RefreshMode.LayersOnly) == common_1.RefreshMode.LayersOnly) {
            var imgSource = this.overlay.getSource(); // olMapGuideSource;
            imgSource.updateParams({
                seq: (new Date()).getTime()
            });
        }
        if (this.selectionOverlay) {
            if ((mode & common_1.RefreshMode.SelectionOnly) == common_1.RefreshMode.SelectionOnly) {
                var imgSource = this.selectionOverlay.getSource(); // olMapGuideSource;
                imgSource.updateParams({
                    seq: (new Date()).getTime()
                });
            }
        }
    };
    MgLayerSetOL.prototype.makeActiveSelectedFeatureSource = function (mapExtent, size, url) {
        if (url === void 0) { url = constants_1.BLANK_GIF_DATA_URI; }
        return new ImageStatic_1.default({
            imageExtent: mapExtent,
            imageSize: [size.w, size.h],
            url: url
        });
    };
    MgLayerSetOL.prototype.showActiveSelectedFeature = function (mapExtent, size, uri) {
        if (this.activeSelectedFeatureOverlay) {
            this.activeSelectedFeatureOverlay.setSource(this.makeActiveSelectedFeatureSource(mapExtent, size, uri));
            this.activeSelectedFeatureOverlay.setVisible(true);
        }
    };
    return MgLayerSetOL;
}());
exports.MgLayerSetOL = MgLayerSetOL;
var MgInnerLayerSetFactory = /** @class */ (function () {
    function MgInnerLayerSetFactory(callback, map, agentUri, imageFormat, selectionImageFormat, selectionColor) {
        this.callback = callback;
        this.map = map;
        this.agentUri = agentUri;
        if ((0, type_guards_1.isRuntimeMap)(map)) {
            this.dynamicOverlayParams = {
                MAPNAME: map.Name,
                FORMAT: imageFormat,
                SESSION: map.SessionId,
                BEHAVIOR: 2
            };
            this.staticOverlayParams = {
                MAPDEFINITION: map.MapDefinition,
                FORMAT: imageFormat,
                CLIENTAGENT: "ol.source.ImageMapGuide for OverviewMap",
                USERNAME: "Anonymous",
                VERSION: "3.0.0"
            };
            this.selectionOverlayParams = {
                MAPNAME: map.Name,
                FORMAT: selectionImageFormat || "PNG8",
                SESSION: map.SessionId,
                SELECTIONCOLOR: selectionColor,
                BEHAVIOR: 1 | 4 //selected features + include outside current scale
            };
        }
    }
    MgInnerLayerSetFactory.prototype.getTileUrlFunctionForGroup = function (resourceId, groupName, zOrigin) {
        var urlTemplate = this.callback.getClient().getTileTemplateUrl(resourceId, groupName, '{x}', '{y}', '{z}');
        return function (tileCoord) {
            var z = tileCoord[0];
            var x = tileCoord[1];
            var y = tileCoord[2]; //NOTE: tileCoord format changed in OL 6.0, no longer need to negate and subtract by 1
            return urlTemplate
                .replace('{z}', (zOrigin - z).toString())
                .replace('{x}', x.toString())
                .replace('{y}', (y).toString());
        };
    };
    MgInnerLayerSetFactory.prototype.create = function (locale, externalBaseLayers, mode, appSettings) {
        var _this = this;
        var _a;
        var _b = this, map = _b.map, agentUri = _b.agentUri;
        if ((0, type_guards_1.isRuntimeMap)(map)) {
            if ((0, string_1.strIsNullOrEmpty)(agentUri)) {
                throw new error_1.MgError("Expected agentUri to be set");
            }
            //If a tile set definition is defined it takes precedence over the map definition, this enables
            //this example to work with older releases of MapGuide where no such resource type exists.
            var resourceId = map.TileSetDefinition || map.MapDefinition;
            //On MGOS 2.6 or older, tile width/height is never returned, so default to 300x300
            var tileWidth = map.TileWidth || 300;
            var tileHeight = map.TileHeight || 300;
            var metersPerUnit = map.CoordinateSystem.MetersPerUnit;
            var finiteScales = [];
            if (map.FiniteDisplayScale) {
                for (var i = map.FiniteDisplayScale.length - 1; i >= 0; i--) {
                    finiteScales.push(map.FiniteDisplayScale[i]);
                }
            }
            var extent = [
                map.Extents.LowerLeftCoordinate.X,
                map.Extents.LowerLeftCoordinate.Y,
                map.Extents.UpperRightCoordinate.X,
                map.Extents.UpperRightCoordinate.Y
            ];
            var dpi = map.DisplayDpi;
            var inPerUnit = 39.37 * map.CoordinateSystem.MetersPerUnit;
            var resolutions = new Array(finiteScales.length);
            var projection = void 0;
            for (var i = 0; i < finiteScales.length; ++i) {
                resolutions[i] = finiteScales[i] / inPerUnit / dpi;
            }
            var parsedArb = (0, units_1.tryParseArbitraryCs)(map.CoordinateSystem.MentorCode);
            if (parsedArb) {
                projection = new proj_1.Projection({
                    code: parsedArb.code,
                    units: toProjUnit(parsedArb.units)
                });
            }
            else {
                if (map.CoordinateSystem.EpsgCode.length > 0) {
                    projection = "EPSG:" + map.CoordinateSystem.EpsgCode;
                }
            }
            var tileGrid = new TileGrid_1.default({
                origin: olExtent.getTopLeft(extent),
                resolutions: resolutions,
                tileSize: [tileWidth, tileHeight]
            });
            var zOrigin = finiteScales.length - 1;
            var mgTiledLayers = [];
            //const groupLayers = [] as TileLayer[];
            if (map.Group) {
                for (var i = 0; i < map.Group.length; i++) {
                    var group = map.Group[i];
                    if (group.Type != 2 && group.Type != 3) { //BaseMap or LinkedTileSet
                        continue;
                    }
                    var tileSource = new TileImage_1.default({
                        tileGrid: tileGrid,
                        projection: projection,
                        tileUrlFunction: this.getTileUrlFunctionForGroup(resourceId, group.Name, zOrigin),
                        wrapX: false
                    });
                    var tileLayer = new Tile_1.default({
                        //name: group.Name,
                        source: tileSource
                    });
                    tileLayer.set(common_1.LayerProperty.LAYER_NAME, group.ObjectId);
                    tileLayer.set(common_1.LayerProperty.LAYER_DISPLAY_NAME, group.ObjectId);
                    tileLayer.set(common_1.LayerProperty.LAYER_TYPE, common_1.MgLayerType.Tiled);
                    tileLayer.set(common_1.LayerProperty.IS_EXTERNAL, false);
                    tileLayer.set(common_1.LayerProperty.IS_GROUP, false);
                    tileLayer.setVisible(group.Visible);
                    //groupLayers.push(tileLayer);
                    mgTiledLayers.push(tileLayer);
                }
            }
            /*
            if (groupLayers.length > 0) {
                groupLayers.push(
                    new ol.layer.Tile({
                        source: new ol.source.TileDebug({
                            tileGrid: tileGrid,
                            projection: projection,
                            tileUrlFunction: function(tileCoord) {
                                const z = tileCoord[0];
                                const x = tileCoord[1];
                                const y = tileCoord[2]; //NOTE: tileCoord format changed in OL 6.0, no longer need to negate and subtract by 1
                                return urlTemplate
                                    .replace('{z}', (zOrigin - z).toString())
                                    .replace('{x}', x.toString())
                                    .replace('{y}', (y).toString());
                            },
                            wrapX: false
                        })
                    })
                );
            }
            */
            var overlay = this.createMgOverlayLayer(common_1.MgBuiltInLayers.Overlay, agentUri, locale, metersPerUnit, projection, mode == MgLayerSetMode.Stateful, mode == MgLayerSetMode.Stateful ? this.dynamicOverlayParams : this.staticOverlayParams);
            var selectionOverlay = void 0;
            var activeSelectedFeatureOverlay = void 0;
            if (mode == MgLayerSetMode.Stateful) {
                selectionOverlay = this.createMgOverlayLayer(common_1.MgBuiltInLayers.SelectionOverlay, agentUri, locale, metersPerUnit, projection, true, this.selectionOverlayParams);
            }
            if (mode == MgLayerSetMode.Stateful) {
                //NOTE: Not tracking this source atm
                activeSelectedFeatureOverlay = new Image_1.default({
                    //OL6: need to specify a source up-front otherwise it will error blindly
                    //trying to get a source out of this URL, so set up a source with an empty
                    //image data URI, it will be updated if we receive a request to show an
                    //active selected feature image
                    source: new ImageStatic_1.default({
                        imageExtent: extent,
                        imageSize: [common_1.BLANK_SIZE.w, common_1.BLANK_SIZE.h],
                        url: constants_1.BLANK_GIF_DATA_URI
                    })
                });
                activeSelectedFeatureOverlay.set(common_1.LayerProperty.LAYER_NAME, common_1.MgBuiltInLayers.ActiveFeatureSelectionOverlay);
                activeSelectedFeatureOverlay.set(common_1.LayerProperty.LAYER_DISPLAY_NAME, common_1.MgBuiltInLayers.ActiveFeatureSelectionOverlay);
                activeSelectedFeatureOverlay.set(common_1.LayerProperty.LAYER_TYPE, common_1.MG_LAYER_TYPE_NAME);
                activeSelectedFeatureOverlay.set(common_1.LayerProperty.IS_EXTERNAL, false);
                activeSelectedFeatureOverlay.set(common_1.LayerProperty.IS_GROUP, false);
            }
            var externalBaseLayersGroup = void 0;
            //NOTE: Don't bother adding external base layers for overview map as the main map in the
            //overview is rendered with GETMAPIMAGE and not GETDYNAMICMAPOVERLAYIMAGE meaning the background
            //is opaque and you won't be able to see the base layers underneath anyways.
            if (mode != MgLayerSetMode.OverviewMap && externalBaseLayers != null) {
                var groupOpts = {
                    title: (0, i18n_1.tr)("EXTERNAL_BASE_LAYERS", locale),
                    layers: externalBaseLayers.map(function (ext) {
                        var tl = _this.createExternalBaseLayer(ext);
                        return tl;
                    })
                };
                externalBaseLayersGroup = new Group_1.default(groupOpts);
                externalBaseLayersGroup.set(common_1.LayerProperty.LAYER_NAME, common_1.MG_BASE_LAYER_GROUP_NAME);
                externalBaseLayersGroup.set(common_1.LayerProperty.LAYER_DISPLAY_NAME, common_1.MG_BASE_LAYER_GROUP_NAME);
                externalBaseLayersGroup.set(common_1.LayerProperty.IS_EXTERNAL, false);
                externalBaseLayersGroup.set(common_1.LayerProperty.IS_GROUP, true);
            }
            (0, logger_1.debug)("Creating OL view with projection " + projection + " and " + resolutions.length + " resolutions");
            var view = void 0;
            if (resolutions.length == 0) {
                view = new View_1.default({
                    projection: projection
                });
            }
            else {
                view = new View_1.default({
                    projection: projection,
                    resolutions: resolutions
                });
            }
            var layerSet = new MgLayerSetOL(mgTiledLayers, externalBaseLayersGroup, overlay, projection, dpi, extent, inPerUnit, view);
            layerSet.selectionOverlay = selectionOverlay;
            layerSet.activeSelectedFeatureOverlay = activeSelectedFeatureOverlay;
            return layerSet;
        }
        else {
            var projection = (_a = map === null || map === void 0 ? void 0 : map.meta) === null || _a === void 0 ? void 0 : _a.projection;
            var bounds = void 0;
            var externalBaseLayersGroup = void 0;
            if (externalBaseLayers != null) {
                var groupOpts = {
                    title: (0, i18n_1.tr)("EXTERNAL_BASE_LAYERS", locale),
                    layers: externalBaseLayers.map(function (ext) {
                        var tl = _this.createExternalBaseLayer(ext);
                        return tl;
                    })
                };
                externalBaseLayersGroup = new Group_1.default(groupOpts);
                externalBaseLayersGroup.set(common_1.LayerProperty.LAYER_NAME, common_1.MG_BASE_LAYER_GROUP_NAME);
                externalBaseLayersGroup.set(common_1.LayerProperty.IS_EXTERNAL, false);
                externalBaseLayersGroup.set(common_1.LayerProperty.IS_GROUP, true);
                projection = "EPSG:3857";
                bounds = DEFAULT_BOUNDS_3857;
            }
            var subjectLayer = void 0;
            if (map) {
                subjectLayer = (0, external_layer_factory_1.createOLLayerFromSubjectDefn)(map, projection, false, appSettings);
                if (map.meta) {
                    projection = map.meta.projection;
                    bounds = map.meta.extents;
                }
            }
            if (!projection && !bounds) {
                projection = "EPSG:4326";
                bounds = DEFAULT_BOUNDS_4326;
            }
            var parsedArb = (0, units_1.tryParseArbitraryCs)(projection);
            var metersPerUnit = 1;
            if (parsedArb) {
                projection = new proj_1.Projection({
                    code: parsedArb.code,
                    units: toProjUnit(parsedArb.units),
                    extent: bounds
                });
            }
            else {
                metersPerUnit = getMetersPerUnit(projection);
            }
            var view = new View_1.default({
                projection: projection
            });
            return new generic_layer_set_1.GenericLayerSetOL(view, subjectLayer, bounds, externalBaseLayersGroup, projection, metersPerUnit);
        }
    };
    MgInnerLayerSetFactory.prototype.createExternalBaseLayer = function (ext) {
        var extSource = (0, external_layer_factory_1.createExternalSource)(ext);
        if (extSource instanceof UrlTile_1.default) {
            var loaders = this.callback.getBaseTileLoaders();
            if (loaders[ext.name])
                extSource.setTileLoadFunction(loaders[ext.name]);
        }
        var options = {
            title: ext.name,
            type: "base",
            visible: ext.visible === true,
            source: extSource
        };
        var tl = new Tile_1.default(options);
        tl.set(common_1.LayerProperty.LAYER_TYPE, ext.kind);
        tl.set(common_1.LayerProperty.LAYER_NAME, ext.name);
        tl.set(common_1.LayerProperty.LAYER_DISPLAY_NAME, ext.name);
        tl.set(common_1.LayerProperty.IS_EXTERNAL, false);
        tl.set(common_1.LayerProperty.IS_GROUP, false);
        return tl;
    };
    MgInnerLayerSetFactory.prototype.createMgOverlayLayer = function (layerName, agentUri, locale, metersPerUnit, projection, useImageOverlayOp, params) {
        var overlaySource = (0, ol_mapguide_source_factory_1.createMapGuideSource)({
            projection: projection,
            url: agentUri,
            useOverlay: useImageOverlayOp,
            metersPerUnit: metersPerUnit,
            params: params,
            ratio: 1,
            // For mobile devices with retina/hidpi displays, the default 96 DPI produces
            // really low quality map images. For such devices, the DPI should be some
            // function of the device pixel ratio reported. As this value can be fractional
            // round it down to the nearest integer
            displayDpi: Math.floor(olHas.DEVICE_PIXEL_RATIO) * 96
        });
        overlaySource.setAttributions((0, i18n_1.tr)("PBMG", locale !== null && locale !== void 0 ? locale : i18n_1.DEFAULT_LOCALE));
        var layer = new Image_1.default({
            //name: "MapGuide Dynamic Overlay",
            source: overlaySource
        });
        layer.set(common_1.LayerProperty.LAYER_NAME, layerName);
        layer.set(common_1.LayerProperty.LAYER_DISPLAY_NAME, layerName);
        layer.set(common_1.LayerProperty.LAYER_TYPE, common_1.MG_LAYER_TYPE_NAME);
        layer.set(common_1.LayerProperty.IS_EXTERNAL, false);
        layer.set(common_1.LayerProperty.IS_GROUP, false);
        return layer;
    };
    return MgInnerLayerSetFactory;
}());
exports.MgInnerLayerSetFactory = MgInnerLayerSetFactory;


/***/ }),

/***/ "./src/api/lazy.ts":
/*!*************************!*\
  !*** ./src/api/lazy.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsyncLazy = exports.Lazy = void 0;
var Lazy = /** @class */ (function () {
    function Lazy(value) {
        this.value = value;
    }
    Lazy.prototype.getValue = function () {
        if (!this._value) {
            this._value = this.value();
        }
        return this._value;
    };
    return Lazy;
}());
exports.Lazy = Lazy;
var AsyncLazy = /** @class */ (function () {
    function AsyncLazy(value) {
        this.value = value;
    }
    AsyncLazy.prototype.getValueAsync = function () {
        if (!this._value) {
            this._value = this.value();
        }
        return this._value;
    };
    return AsyncLazy;
}());
exports.AsyncLazy = AsyncLazy;


/***/ }),

/***/ "./src/api/mapguide-commands.ts":
/*!**************************************!*\
  !*** ./src/api/mapguide-commands.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initMapGuideCommands = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var command_1 = __webpack_require__(/*! ./registry/command */ "./src/api/registry/command.ts");
var assets_1 = __webpack_require__(/*! ../constants/assets */ "./src/constants/assets.ts");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var url_1 = __webpack_require__(/*! ../utils/url */ "./src/utils/url.ts");
var common_1 = __webpack_require__(/*! ./common */ "./src/api/common.ts");
var runtime_1 = __webpack_require__(/*! ./runtime */ "./src/api/runtime.ts");
var i18n_1 = __webpack_require__(/*! ./i18n */ "./src/api/i18n.ts");
var default_commands_1 = __webpack_require__(/*! ./default-commands */ "./src/api/default-commands.ts");
var viewer_shim_1 = __webpack_require__(/*! ../containers/viewer-shim */ "./src/containers/viewer-shim.tsx");
var olExtent = (0, tslib_1.__importStar)(__webpack_require__(/*! ol/extent */ "./node_modules/ol/extent.js"));
var composite_selection_1 = __webpack_require__(/*! ./composite-selection */ "./src/api/composite-selection.ts");
function initMapGuideCommands() {
    //Feature Tooltips
    (0, command_1.registerCommand)(command_1.DefaultCommands.MapTip, {
        iconClass: assets_1.SPRITE_MAPTIP,
        selected: function (state) {
            return state.featureTooltipsEnabled === true;
        },
        enabled: function (state) { return !state.stateless; },
        invoke: function (dispatch, getState) {
            var enabled = getState().viewer.featureTooltipsEnabled;
            return dispatch((0, map_1.setFeatureTooltipsEnabled)(!enabled));
        }
    });
    //Quick Plot
    (0, command_1.registerCommand)(command_1.DefaultCommands.QuickPlot, {
        iconClass: assets_1.SPRITE_PRINT,
        selected: function () { return false; },
        enabled: function (state) { return !state.stateless; },
        invoke: function (dispatch, getState, _viewer, parameters) {
            var config = getState().config;
            var url = "component://QuickPlot";
            var cmdDef = (0, default_commands_1.buildTargetedCommand)(config, parameters);
            (0, command_1.openUrlInTarget)(command_1.DefaultCommands.QuickPlot, cmdDef, config.capabilities.hasTaskPane, dispatch, url);
        }
    });
    //Viewer Options
    (0, command_1.registerCommand)(command_1.DefaultCommands.ViewerOptions, {
        iconClass: assets_1.SPRITE_OPTIONS,
        selected: function () { return false; },
        enabled: function () { return true; },
        invoke: function (dispatch, getState, _viewer, parameters) {
            var config = getState().config;
            var url = "component://ViewerOptions";
            var cmdDef = (0, default_commands_1.buildTargetedCommand)(config, parameters);
            (0, command_1.openUrlInTarget)(command_1.DefaultCommands.ViewerOptions, cmdDef, config.capabilities.hasTaskPane, dispatch, url, (0, i18n_1.tr)("VIEWER_OPTIONS", config.locale));
        }
    });
    //Select Radius
    (0, command_1.registerCommand)(command_1.DefaultCommands.SelectRadius, {
        iconClass: assets_1.SPRITE_SELECT_RADIUS,
        selected: function () { return false; },
        enabled: function (state) { return !state.stateless; },
        invoke: function (_dispatch, _getState, viewer, parameters) {
            if (viewer) {
                var selMethod_1 = parameters.SelectionType || "INTERSECTS";
                viewer.digitizeCircle(function (circle) {
                    var _a;
                    var fact = viewer.getOLFactory();
                    var geom = fact.createGeomPolygonFromCircle(circle);
                    (_a = viewer.mapguideSupport()) === null || _a === void 0 ? void 0 : _a.selectByGeometry(geom, selMethod_1);
                });
            }
        }
    });
    //Select Polygon
    (0, command_1.registerCommand)(command_1.DefaultCommands.SelectPolygon, {
        iconClass: assets_1.SPRITE_SELECT_POLYGON,
        selected: function () { return false; },
        enabled: function (state) { return !state.stateless; },
        invoke: function (_dispatch, _getState, viewer, parameters) {
            if (viewer) {
                var selMethod_2 = parameters.SelectionType || "INTERSECTS";
                viewer.digitizePolygon(function (geom) {
                    var _a;
                    (_a = viewer.mapguideSupport()) === null || _a === void 0 ? void 0 : _a.selectByGeometry(geom, selMethod_2);
                });
            }
        }
    });
    //Clear Selection
    (0, command_1.registerCommand)(command_1.DefaultCommands.ClearSelection, {
        iconClass: assets_1.SPRITE_SELECT_CLEAR,
        selected: function () { return false; },
        enabled: function (state) { return command_1.CommandConditions.hasSelection(state) || command_1.CommandConditions.hasClientSelection(state); },
        invoke: function (dispatch, getState, viewer) {
            var _a;
            var st = getState();
            if (st.config.activeMapName) {
                dispatch((0, map_1.clearClientSelection)(st.config.activeMapName));
            }
            (_a = viewer === null || viewer === void 0 ? void 0 : viewer.mapguideSupport()) === null || _a === void 0 ? void 0 : _a.clearSelection();
        }
    });
    //Zoom to Selection
    (0, command_1.registerCommand)(command_1.DefaultCommands.ZoomToSelection, {
        iconClass: assets_1.SPRITE_ICON_ZOOMSELECT,
        selected: function () { return false; },
        enabled: function (state) { return command_1.CommandConditions.hasSelection(state) || command_1.CommandConditions.hasClientSelection(state); },
        invoke: function (dispatch, getState, viewer) {
            if (viewer) {
                var fact = viewer.getOLFactory();
                var st = getState();
                var selection = (0, common_1.getSelectionSet)(st);
                var cs = void 0;
                if (st.config.activeMapName) {
                    cs = st.mapState[st.config.activeMapName].clientSelection;
                }
                var compSel = new composite_selection_1.CompositeSelection(selection === null || selection === void 0 ? void 0 : selection.SelectedFeatures, cs);
                var bounds = compSel.getBounds();
                if (bounds) {
                    var view = viewer.getViewForExtent(bounds);
                    dispatch((0, map_1.setCurrentView)(view));
                }
            }
        }
    });
    //Buffer
    (0, command_1.registerCommand)(command_1.DefaultCommands.Buffer, {
        iconClass: assets_1.SPRITE_BUFFER,
        selected: function () { return false; },
        enabled: function (state) { return !state.stateless && command_1.CommandConditions.hasSelection(state); },
        invoke: function (dispatch, getState, _viewer, parameters) {
            var state = getState();
            var map = (0, common_1.getRuntimeMap)(state);
            var config = state.config;
            if (map) {
                var url = (0, url_1.ensureParameters)((0, runtime_1.getFusionRoot)() + "/widgets/BufferPanel/BufferPanel.php", map.Name, map.SessionId, config.locale, false);
                url += "&popup=false&us=0";
                var cmdDef = (0, default_commands_1.buildTargetedCommand)(config, parameters);
                (0, command_1.openUrlInTarget)(command_1.DefaultCommands.Buffer, cmdDef, config.capabilities.hasTaskPane, dispatch, url);
            }
        }
    });
    //Select Within
    (0, command_1.registerCommand)(command_1.DefaultCommands.SelectWithin, {
        iconClass: assets_1.SPRITE_SELECT_FEATURES,
        selected: function () { return false; },
        enabled: function (state, parameters) { return !state.stateless && !command_1.CommandConditions.disabledIfEmptySelection(state, parameters); },
        invoke: function (dispatch, getState, _viewer, parameters) {
            var state = getState();
            var map = (0, common_1.getRuntimeMap)(state);
            var config = state.config;
            if (map) {
                var url = (0, url_1.ensureParameters)((0, runtime_1.getFusionRoot)() + "/widgets/SelectWithin/SelectWithinPanel.php", map.Name, map.SessionId, config.locale, false);
                url += "&popup=false";
                var cmdDef = (0, default_commands_1.buildTargetedCommand)(config, parameters);
                (0, command_1.openUrlInTarget)(command_1.DefaultCommands.SelectWithin, cmdDef, config.capabilities.hasTaskPane, dispatch, url);
            }
        }
    });
    //Redline
    (0, command_1.registerCommand)(command_1.DefaultCommands.Redline, {
        iconClass: assets_1.SPRITE_REDLINE,
        selected: function () { return false; },
        enabled: function (state) { return !state.stateless && command_1.CommandConditions.isNotBusy(state); },
        invoke: function (dispatch, getState, viewer, parameters) {
            var state = getState();
            var map = (0, common_1.getRuntimeMap)(state);
            var config = state.config;
            if (map) {
                var bUseAdvancedStylization = true;
                var defaultDataStoreFormat = null;
                var defaultRedlineGeometryType = 0;
                var bCreateOnStartup = false;
                if (parameters.AutogenerateLayerNames)
                    if (parameters.StylizationType)
                        bUseAdvancedStylization = (parameters.StylizationType == "advanced");
                if (parameters.DataStoreFormat && parameters.RedlineGeometryFormat) {
                    if (parameters.DataStoreFormat == "SDF" ||
                        parameters.DataStoreFormat == "SHP" ||
                        parameters.DataStoreFormat == "SQLite") {
                        var geomTypes = parseInt(parameters.RedlineGeometryFormat);
                        if (parameters.DataStoreFormat == "SHP") {
                            //Only accept if geometry type is singular
                            if (geomTypes == 1 || geomTypes == 2 || geomTypes == 4) {
                                defaultDataStoreFormat = parameters.DataStoreFormat;
                                defaultRedlineGeometryType = geomTypes;
                                if (parameters.AutoCreateOnStartup)
                                    bCreateOnStartup = (parameters.AutoCreateOnStartup == "true");
                            }
                        }
                        else {
                            defaultDataStoreFormat = parameters.DataStoreFormat;
                            defaultRedlineGeometryType = geomTypes;
                            if (parameters.AutoCreateOnStartup)
                                bCreateOnStartup = (parameters.AutoCreateOnStartup == "true");
                        }
                    }
                }
                (0, viewer_shim_1.enableRedlineMessagePrompt)(parameters.UseMapMessage == "true");
                var url = (0, url_1.ensureParameters)((0, runtime_1.getFusionRoot)() + "/widgets/Redline/markupmain.php", map.Name, map.SessionId, config.locale, true);
                url += "&POPUP=false";
                if (defaultDataStoreFormat != null && defaultRedlineGeometryType > 0) {
                    url += "&REDLINEFORMAT=" + defaultDataStoreFormat;
                    url += "&REDLINEGEOMTYPE=" + defaultRedlineGeometryType;
                    url += "&AUTOCREATE=" + (bCreateOnStartup ? "1" : "0");
                }
                url += "&REDLINESTYLIZATION=" + (bUseAdvancedStylization ? "ADVANCED" : "BASIC");
                var cmdDef = (0, default_commands_1.buildTargetedCommand)(config, parameters);
                (0, command_1.openUrlInTarget)(command_1.DefaultCommands.Redline, cmdDef, config.capabilities.hasTaskPane, dispatch, url);
            }
        }
    });
    //Feature Info
    (0, command_1.registerCommand)(command_1.DefaultCommands.FeatureInfo, {
        iconClass: assets_1.SPRITE_FEATURE_INFO,
        selected: function () { return false; },
        enabled: function (state) { return !state.stateless && command_1.CommandConditions.isNotBusy(state); },
        invoke: function (dispatch, getState, _viewer, parameters) {
            var state = getState();
            var map = (0, common_1.getRuntimeMap)(state);
            var config = state.config;
            if (map) {
                var url = (0, url_1.ensureParameters)((0, runtime_1.getFusionRoot)() + "/widgets/FeatureInfo/featureinfomain.php", map.Name, map.SessionId, config.locale, true);
                var cmdDef = (0, default_commands_1.buildTargetedCommand)(config, parameters);
                (0, command_1.openUrlInTarget)(command_1.DefaultCommands.FeatureInfo, cmdDef, config.capabilities.hasTaskPane, dispatch, url);
            }
        }
    });
    //Query
    (0, command_1.registerCommand)(command_1.DefaultCommands.Query, {
        iconClass: assets_1.SPRITE_QUERY,
        selected: function () { return false; },
        enabled: function (state) { return !state.stateless && command_1.CommandConditions.isNotBusy(state); },
        invoke: function (dispatch, getState, _viewer, parameters) {
            var state = getState();
            var map = (0, common_1.getRuntimeMap)(state);
            var config = state.config;
            if (map) {
                var url = (0, url_1.ensureParameters)((0, runtime_1.getFusionRoot)() + "/widgets/Query/querymain.php", map.Name, map.SessionId, config.locale, true);
                var cmdDef = (0, default_commands_1.buildTargetedCommand)(config, parameters);
                (0, command_1.openUrlInTarget)(command_1.DefaultCommands.Query, cmdDef, config.capabilities.hasTaskPane, dispatch, url);
            }
        }
    });
    //Theme
    (0, command_1.registerCommand)(command_1.DefaultCommands.Theme, {
        iconClass: assets_1.SPRITE_THEME,
        selected: function () { return false; },
        enabled: function (state) { return !state.stateless && command_1.CommandConditions.isNotBusy(state); },
        invoke: function (dispatch, getState, _viewer, parameters) {
            var state = getState();
            var map = (0, common_1.getRuntimeMap)(state);
            var config = state.config;
            if (map) {
                var url = (0, url_1.ensureParameters)((0, runtime_1.getFusionRoot)() + "/widgets/Theme/thememain.php", map.Name, map.SessionId, config.locale, true);
                var cmdDef = (0, default_commands_1.buildTargetedCommand)(config, parameters);
                (0, command_1.openUrlInTarget)(command_1.DefaultCommands.Theme, cmdDef, config.capabilities.hasTaskPane, dispatch, url);
            }
        }
    });
    //Center Selection
    (0, command_1.registerCommand)(command_1.DefaultCommands.CenterSelection, {
        iconClass: assets_1.SPRITE_SELECT_CENTRE,
        selected: function () { return false; },
        enabled: function (state) { return !state.stateless && command_1.CommandConditions.hasSelection(state); },
        invoke: function (dispatch, getState, viewer) {
            var _a, _b;
            var state = getState();
            var mapName = state.config.activeMapName;
            if (mapName && viewer) {
                var mapState = state.mapState[mapName];
                var sf = (_b = (_a = mapState === null || mapState === void 0 ? void 0 : mapState.mapguide) === null || _a === void 0 ? void 0 : _a.selectionSet) === null || _b === void 0 ? void 0 : _b.SelectedFeatures;
                if (sf) {
                    var bbox = void 0;
                    for (var _i = 0, _c = sf.SelectedLayer; _i < _c.length; _i++) {
                        var layer = _c[_i];
                        for (var _d = 0, _e = layer.Feature.filter(function (f) { return f.Bounds != null; }); _d < _e.length; _d++) {
                            var f = _e[_d];
                            var b = f.Bounds.split(" ").map(function (s) { return parseFloat(s); });
                            if (!bbox) {
                                bbox = b;
                            }
                            else {
                                bbox = olExtent.extend(bbox, b);
                            }
                        }
                    }
                    if (bbox) {
                        var view = viewer.getViewForExtent(bbox);
                        dispatch((0, map_1.setCurrentView)(view));
                    }
                }
            }
        }
    });
}
exports.initMapGuideCommands = initMapGuideCommands;


/***/ }),

/***/ "./src/api/mapguide-components.tsx":
/*!*****************************************!*\
  !*** ./src/api/mapguide-components.tsx ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerMapGuideComponents = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var legend_1 = __webpack_require__(/*! ../containers/legend */ "./src/containers/legend.tsx");
var selected_feature_count_1 = __webpack_require__(/*! ../containers/selected-feature-count */ "./src/containers/selected-feature-count.tsx");
var selection_panel_1 = __webpack_require__(/*! ../containers/selection-panel */ "./src/containers/selection-panel.tsx");
var pbmg_1 = __webpack_require__(/*! ../components/pbmg */ "./src/components/pbmg.tsx");
var session_expired_1 = __webpack_require__(/*! ../components/session-expired */ "./src/components/session-expired.tsx");
var viewer_options_1 = __webpack_require__(/*! ../containers/viewer-options */ "./src/containers/viewer-options.tsx");
var quick_plot_1 = __webpack_require__(/*! ../containers/quick-plot */ "./src/containers/quick-plot.tsx");
var component_1 = __webpack_require__(/*! ../api/registry/component */ "./src/api/registry/component.tsx");
function registerMapGuideComponents() {
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.Legend, function (props) { return React.createElement(legend_1.LegendContainer, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.SelectionPanel, function (props) { return React.createElement(selection_panel_1.SelectionPanelContainer, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.SelectedFeatureCount, function (props) { return React.createElement(selected_feature_count_1.SelectedFeatureCountContainer, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.PoweredByMapGuide, function (props) { return React.createElement(pbmg_1.PoweredByMapGuide, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.SessionExpired, function (props) { return React.createElement(session_expired_1.SessionExpired, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.ViewerOptions, function (props) { return React.createElement(viewer_options_1.ViewerOptions, (0, tslib_1.__assign)({}, props)); });
    (0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.QuickPlot, function (props) { return React.createElement(quick_plot_1.QuickPlotContainer, (0, tslib_1.__assign)({}, props)); });
}
exports.registerMapGuideComponents = registerMapGuideComponents;


/***/ }),

/***/ "./src/api/mg-layer-set-group.ts":
/*!***************************************!*\
  !*** ./src/api/mg-layer-set-group.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MgLayerSetGroup = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var common_1 = __webpack_require__(/*! ./common */ "./src/api/common.ts");
var Image_1 = __webpack_require__(/*! ol/source/Image */ "./node_modules/ol/source/Image.js");
var ImageMapGuide_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/ImageMapGuide */ "./node_modules/ol/source/ImageMapGuide.js"));
var Image_2 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Image */ "./node_modules/ol/layer/Image.js"));
var never_1 = __webpack_require__(/*! ../utils/never */ "./src/utils/never.ts");
var layer_set_group_base_1 = __webpack_require__(/*! ./layer-set-group-base */ "./src/api/layer-set-group-base.ts");
var layer_set_1 = __webpack_require__(/*! ./layer-set */ "./src/api/layer-set.ts");
var mapguide_debug_context_1 = __webpack_require__(/*! ../components/mapguide-debug-context */ "./src/components/mapguide-debug-context.ts");
var type_guards_1 = __webpack_require__(/*! ../utils/type-guards */ "./src/utils/type-guards.ts");
var string_1 = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");
var error_1 = __webpack_require__(/*! ./error */ "./src/api/error.ts");
var generic_layer_set_1 = __webpack_require__(/*! ./generic-layer-set */ "./src/api/generic-layer-set.ts");
var Image_3 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Image */ "./node_modules/ol/layer/Image.js"));
var Tile_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Tile */ "./node_modules/ol/layer/Tile.js"));
var TileWMS_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/TileWMS */ "./node_modules/ol/source/TileWMS.js"));
var ImageWMS_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/ImageWMS */ "./node_modules/ol/source/ImageWMS.js"));
var MgLayerSetGroup = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(MgLayerSetGroup, _super);
    function MgLayerSetGroup(props, callback) {
        var _this = _super.call(this, callback) || this;
        _this.updateSelectionColor = function (color) { return _this.mainSet.updateSelectionColor(color); };
        _this.update = function (showGroups, showLayers, hideGroups, hideLayers) { return _this.mainSet.update(showGroups, showLayers, hideGroups, hideLayers); };
        var map = props.map, agentUri = props.agentUri;
        var isRtMap = (0, type_guards_1.isRuntimeMap)(map);
        var hasAgentUri = (0, string_1.strIsNullOrEmpty)(agentUri);
        if (isRtMap) {
            if (hasAgentUri) {
                throw new error_1.MgError("Expected agentUri to be set");
            }
        }
        var factory = new layer_set_1.MgInnerLayerSetFactory(callback, map, agentUri, props.imageFormat, props.selectionImageFormat, props.selectionColor);
        //NOTE: MapGuide does not like concurrent map rendering operations of the same mapname/session pair, which
        //this will do when the MG overlay is shared between the main viewer and the overview map. This is probably
        //because the concurrent requests both have SET[X/Y/SCALE/DPI/etc] parameters attached, so there is concurrent
        //requests to modify and persist the runtime map state (in addition to the rendering) and there is most likely
        //server-side lock contention to safely update the map state. Long story short: re-using the main overlay for the
        //OverviewMap control IS A BAD THING. Same thing happens with selection overlays
        //
        //As of OL6, this unwanted behavior from shared layers extends to all layer types, so what this means is that
        //we have to create 2 sets of layers, one for the main map and one for the overview map. We CANNOT and DO NOT share
        //any of these layer instances between the main map and the overview map!
        _this.mainSet = factory.create(props.locale, props.externalBaseLayers, props.stateless ? layer_set_1.MgLayerSetMode.Stateless : layer_set_1.MgLayerSetMode.Stateful, props.appSettings);
        _this.overviewSet = factory.create(props.locale, props.externalBaseLayers, layer_set_1.MgLayerSetMode.OverviewMap, props.appSettings);
        var progressNotifySources = _this.mainSet.getSourcesForProgressTracking();
        /*
        console.log("Draw Order:");
        for (let i = 0; i < layers.length; i++) {
            console.log(" " + layers[i].get(LayerProperty.LAYER_NAME));
        }
        */
        for (var _i = 0, progressNotifySources_1 = progressNotifySources; _i < progressNotifySources_1.length; _i++) {
            var src = progressNotifySources_1[_i];
            var suppress = src.get(common_1.SourceProperty.SUPPRESS_LOAD_EVENTS);
            if (!(suppress == true))
                _this.registerSourceEvents(src);
        }
        return _this;
    }
    /**
     * @override
     */
    MgLayerSetGroup.prototype.tryGetSubjectLayer = function () {
        if (this.mainSet instanceof generic_layer_set_1.GenericLayerSetOL) {
            return this.mainSet.subjectLayer;
        }
        else if (this.mainSet instanceof layer_set_1.MgLayerSetOL) {
            return this.mainSet.overlay;
        }
        return undefined;
    };
    /**
     * @override
     * @returns
     * @memberof MgLayerSetGroup
     */
    MgLayerSetGroup.prototype.tryGetWmsSource = function () {
        var subjectLayer = this.tryGetSubjectLayer();
        if (subjectLayer instanceof Image_3.default || subjectLayer instanceof Tile_1.default) {
            var source = subjectLayer.getSource();
            if (source instanceof ImageWMS_1.default || source instanceof TileWMS_1.default) {
                return [subjectLayer, source];
            }
        }
        return undefined;
    };
    MgLayerSetGroup.prototype.setMapGuideMocking = function (mock) {
        var allLayers = this.mainSet.getLayers();
        for (var _i = 0, allLayers_1 = allLayers; _i < allLayers_1.length; _i++) {
            var layer = allLayers_1[_i];
            if (layer instanceof Image_2.default) {
                var source = layer.getSource();
                if (source instanceof ImageMapGuide_1.default) {
                    if (typeof (mock) != 'undefined') {
                        switch (mock) {
                            case mapguide_debug_context_1.MapGuideMockMode.RenderPlaceholder:
                                source.setImageLoadFunction(layer_set_1.mockMapGuideImageLoadFunction);
                                break;
                            case mapguide_debug_context_1.MapGuideMockMode.DoNotRender:
                                source.setImageLoadFunction(layer_set_1.blankImageLoadFunction);
                                break;
                            default:
                                (0, never_1.assertNever)(mock);
                                break;
                        }
                    }
                    else {
                        source.setImageLoadFunction(Image_1.defaultImageLoadFunction);
                    }
                }
            }
        }
    };
    return MgLayerSetGroup;
}(layer_set_group_base_1.LayerSetGroupBase));
exports.MgLayerSetGroup = MgLayerSetGroup;


/***/ }),

/***/ "./src/api/ol-factory.ts":
/*!*******************************!*\
  !*** ./src/api/ol-factory.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OLFactory = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var Point_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/Point */ "./node_modules/ol/geom/Point.js"));
var LineString_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/LineString */ "./node_modules/ol/geom/LineString.js"));
var Circle_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/Circle */ "./node_modules/ol/geom/Circle.js"));
var Polygon_1 = (0, tslib_1.__importStar)(__webpack_require__(/*! ol/geom/Polygon */ "./node_modules/ol/geom/Polygon.js"));
var LinearRing_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/LinearRing */ "./node_modules/ol/geom/LinearRing.js"));
var MultiLineString_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/MultiLineString */ "./node_modules/ol/geom/MultiLineString.js"));
var MultiPoint_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/MultiPoint */ "./node_modules/ol/geom/MultiPoint.js"));
var MultiPolygon_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/MultiPolygon */ "./node_modules/ol/geom/MultiPolygon.js"));
var GeometryCollection_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/GeometryCollection */ "./node_modules/ol/geom/GeometryCollection.js"));
var Overlay_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/Overlay */ "./node_modules/ol/Overlay.js"));
var olExtent = (0, tslib_1.__importStar)(__webpack_require__(/*! ol/extent */ "./node_modules/ol/extent.js"));
var olProj = (0, tslib_1.__importStar)(__webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js"));
var Projection_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/proj/Projection */ "./node_modules/ol/proj/Projection.js"));
var Vector_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Vector */ "./node_modules/ol/layer/Vector.js"));
var Vector_2 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/Vector */ "./node_modules/ol/source/Vector.js"));
var Collection_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/Collection */ "./node_modules/ol/Collection.js"));
var Feature_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/Feature */ "./node_modules/ol/Feature.js"));
var Extent_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/Extent */ "./node_modules/ol/interaction/Extent.js"));
var Snap_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/Snap */ "./node_modules/ol/interaction/Snap.js"));
var Draw_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/Draw */ "./node_modules/ol/interaction/Draw.js"));
var Translate_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/Translate */ "./node_modules/ol/interaction/Translate.js"));
var Modify_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/Modify */ "./node_modules/ol/interaction/Modify.js"));
var Select_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/Select */ "./node_modules/ol/interaction/Select.js"));
var GeoJSON_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/format/GeoJSON */ "./node_modules/ol/format/GeoJSON.js"));
var WKT_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/format/WKT */ "./node_modules/ol/format/WKT.js"));
var Style_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/Style */ "./node_modules/ol/style/Style.js"));
var Icon_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/Icon */ "./node_modules/ol/style/Icon.js"));
var RegularShape_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/RegularShape */ "./node_modules/ol/style/RegularShape.js"));
var Text_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/Text */ "./node_modules/ol/style/Text.js"));
var Fill_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/Fill */ "./node_modules/ol/style/Fill.js"));
var Stroke_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/Stroke */ "./node_modules/ol/style/Stroke.js"));
var Circle_2 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/Circle */ "./node_modules/ol/style/Circle.js"));
/**
 * Creates various OpenLayers types used by the viewer
 *
 * @export
 * @class OLFactory
 * @implements {IOLFactory}
 */
var OLFactory = /** @class */ (function () {
    function OLFactory() {
    }
    OLFactory.prototype.createStyle = function (options) {
        return new Style_1.default(options);
    };
    OLFactory.prototype.createStyleFill = function (options) {
        return new Fill_1.default(options);
    };
    OLFactory.prototype.createStyleStroke = function (options) {
        return new Stroke_1.default(options);
    };
    OLFactory.prototype.createStyleCircle = function (options) {
        return new Circle_2.default(options);
    };
    OLFactory.prototype.createFeatureCollection = function () {
        return new Collection_1.default();
    };
    OLFactory.prototype.extentContainsXY = function (extent, x, y) {
        return olExtent.containsXY(extent, x, y);
    };
    OLFactory.prototype.extendExtent = function (extent, other) {
        return olExtent.extend(extent, other);
    };
    OLFactory.prototype.createProjection = function (options) {
        return new Projection_1.default(options);
    };
    OLFactory.prototype.transformCoordinateFromLonLat = function (lonlat, proj) {
        return olProj.fromLonLat(lonlat, proj);
    };
    OLFactory.prototype.transformCoordinate = function (coordinate, source, target) {
        return olProj.transform(coordinate, source, target);
    };
    OLFactory.prototype.transformExtent = function (extent, source, target) {
        return olProj.transformExtent(extent, source, target);
    };
    OLFactory.prototype.createGeomPoint = function (coordinates) {
        return new Point_1.default(coordinates);
    };
    OLFactory.prototype.createGeomLineString = function (coordinates) {
        return new LineString_1.default(coordinates);
    };
    OLFactory.prototype.createGeomCircle = function (center, radius) {
        return new Circle_1.default(center, radius);
    };
    OLFactory.prototype.createGeomLinearRing = function (coordinates) {
        return new LinearRing_1.default(coordinates);
    };
    OLFactory.prototype.createGeomPolygon = function (coordinates) {
        return new Polygon_1.default(coordinates);
    };
    OLFactory.prototype.createGeomPolygonFromCircle = function (circle) {
        return (0, Polygon_1.fromCircle)(circle);
    };
    OLFactory.prototype.createGeomMultiLineString = function (coordinates) {
        return new MultiLineString_1.default(coordinates);
    };
    OLFactory.prototype.createGeomMultiPoint = function (coordinates) {
        return new MultiPoint_1.default(coordinates);
    };
    OLFactory.prototype.createGeomMultiPolygon = function (coordinates) {
        return new MultiPolygon_1.default(coordinates);
    };
    OLFactory.prototype.createGeomCollection = function (geometries) {
        return new GeometryCollection_1.default(geometries);
    };
    OLFactory.prototype.createVectorSource = function (options) {
        return new Vector_2.default(options);
    };
    OLFactory.prototype.createVectorLayer = function (options) {
        return new Vector_1.default(options);
    };
    OLFactory.prototype.createOverlay = function (options) {
        return new Overlay_1.default(options);
    };
    OLFactory.prototype.createInteractionDraw = function (options) {
        return new Draw_1.default(options);
    };
    OLFactory.prototype.createInteractionExtent = function (options) {
        return new Extent_1.default(options);
    };
    OLFactory.prototype.createInteractionTranslate = function (options) {
        return new Translate_1.default(options);
    };
    OLFactory.prototype.createInteractionSnap = function (options) {
        return new Snap_1.default(options);
    };
    OLFactory.prototype.createInteractionModify = function (options) {
        return new Modify_1.default(options);
    };
    OLFactory.prototype.createInteractionSelect = function (options) {
        return new Select_1.default(options);
    };
    OLFactory.prototype.createFeature = function (geomOrProps) {
        return new Feature_1.default(geomOrProps);
    };
    OLFactory.prototype.createFormatGeoJSON = function (options) {
        return new GeoJSON_1.default(options);
    };
    OLFactory.prototype.createFormatWKT = function (options) {
        return new WKT_1.default(options);
    };
    /**
     * @since 0.12.6
     */
    OLFactory.prototype.createStyleIcon = function (options) {
        return new Icon_1.default(options);
    };
    /**
     * @since 0.12.6
     */
    OLFactory.prototype.createStyleRegularShape = function (options) {
        return new RegularShape_1.default(options);
    };
    /**
     * @since 0.12.6
     */
    OLFactory.prototype.createStyleText = function (options) {
        return new Text_1.default(options);
    };
    return OLFactory;
}());
exports.OLFactory = OLFactory;


/***/ }),

/***/ "./src/api/ol-mapguide-source-factory.ts":
/*!***********************************************!*\
  !*** ./src/api/ol-mapguide-source-factory.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMapGuideSource = exports.isMapGuideImageSource = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
//import { MapGuideImageSource } from "./ol-mapguide-source";
var ImageMapGuide_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/ImageMapGuide */ "./node_modules/ol/source/ImageMapGuide.js"));
/**
 * @hidden
 */
function isMapGuideImageSource(arg) {
    return typeof (arg.updateParams) != 'undefined';
}
exports.isMapGuideImageSource = isMapGuideImageSource;
/**
 * @hidden
 */
function createMapGuideSource(options) {
    //const ctor: any = MapGuideImageSource;
    //const source = new ctor(options);
    var source = new ImageMapGuide_1.default(options);
    return source;
}
exports.createMapGuideSource = createMapGuideSource;


/***/ }),

/***/ "./src/api/ol-style-builders.ts":
/*!**************************************!*\
  !*** ./src/api/ol-style-builders.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tryBuildTextStyle = exports.buildFill = exports.buildStroke = exports.evalFeature = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var ol_style_contracts_1 = __webpack_require__(/*! ./ol-style-contracts */ "./src/api/ol-style-contracts.ts");
var Text_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/Text */ "./node_modules/ol/style/Text.js"));
var Stroke_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/Stroke */ "./node_modules/ol/style/Stroke.js"));
var Fill_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/Fill */ "./node_modules/ol/style/Fill.js"));
var color_1 = __webpack_require__(/*! ol/color */ "./node_modules/ol/color.js");
function toOLColor(color, alpha) {
    var c = (0, color_1.asArray)(color);
    if (typeof (alpha) != 'undefined') {
        c[3] = (alpha / 255);
    }
    return c;
}
function evalFeature(expr, feat, context) {
    if (!(0, ol_style_contracts_1.isEvaluatable)(expr)) {
        return expr;
    }
    else if (feat && context) {
        try {
            return context.evaluate(expr.expr, feat);
        }
        catch (e) {
            return undefined;
        }
    }
    else {
        return undefined;
    }
}
exports.evalFeature = evalFeature;
function setIfNotUndefined(obj, prop, value) {
    if (typeof (value) != 'undefined') {
        obj[prop] = value;
    }
}
function buildStroke(stroke, feat, context) {
    return new Stroke_1.default({
        color: toOLColor(evalFeature(stroke.color, feat, context), evalFeature(stroke.alpha, feat, context)),
        width: evalFeature(stroke.width, feat, context)
    });
}
exports.buildStroke = buildStroke;
function buildFill(fill, feat, context) {
    return new Fill_1.default({
        color: toOLColor(evalFeature(fill.color, feat, context), evalFeature(fill.alpha, feat, context))
    });
}
exports.buildFill = buildFill;
function tryBuildTextStyle(style, feat, context) {
    var label = style.label;
    if (label) {
        var textOpts = {};
        setIfNotUndefined(textOpts, "font", evalFeature(label.font, feat, context));
        setIfNotUndefined(textOpts, "maxAngle", evalFeature(label.maxAngle, feat, context));
        setIfNotUndefined(textOpts, "offsetX", evalFeature(label.offsetX, feat, context));
        setIfNotUndefined(textOpts, "offsetY", evalFeature(label.offsetY, feat, context));
        setIfNotUndefined(textOpts, "overflow", evalFeature(label.overflow, feat, context));
        setIfNotUndefined(textOpts, "placement", evalFeature(label.placement, feat, context));
        setIfNotUndefined(textOpts, "rotateWithView", evalFeature(label.rotateWithView, feat, context));
        setIfNotUndefined(textOpts, "rotation", evalFeature(label.rotation, feat, context));
        setIfNotUndefined(textOpts, "scale", evalFeature(label.scale, feat, context));
        var txt = evalFeature(label.text, feat, context);
        if (typeof (txt) != 'undefined') {
            textOpts.text = "" + txt; //Need to stringify this
        }
        setIfNotUndefined(textOpts, "textAlign", evalFeature(label.textAlign, feat, context));
        setIfNotUndefined(textOpts, "textBaseline", evalFeature(label.textBaseline, feat, context));
        var text = new Text_1.default(textOpts);
        if (label.padding) {
            text.setPadding(label.padding);
        }
        if (label.fill) {
            var f = buildFill(label.fill, feat, context);
            text.setFill(f);
        }
        if (label.backgroundFill) {
            var f = buildFill(label.backgroundFill, feat, context);
            text.setBackgroundFill(f);
        }
        if (label.stroke) {
            var s = buildStroke(label.stroke, feat, context);
            text.setStroke(s);
        }
        if (label.backgroundStroke) {
            var s = buildStroke(label.backgroundStroke, feat, context);
            text.setBackgroundStroke(s);
        }
        return text;
    }
    return undefined;
}
exports.tryBuildTextStyle = tryBuildTextStyle;


/***/ }),

/***/ "./src/api/ol-style-contracts.ts":
/*!***************************************!*\
  !*** ./src/api/ol-style-contracts.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_CLUSTERED_LAYER_STYLE = exports.DEFAULT_VECTOR_LAYER_STYLE = exports.DEFAULT_POLY_STYLE = exports.DEFAULT_LINE_STYLE = exports.DEFAULT_COLOR = exports.DEFAULT_POINT_ICON_STYLE = exports.DEFAULT_CLUSTERED_POINT_CIRCLE_STYLE = exports.DEFAULT_POINT_CIRCLE_STYLE = exports.isEvaluatable = exports.ClusterClickAction = exports.VectorStyleSource = void 0;
var assets_1 = __webpack_require__(/*! ../constants/assets */ "./src/constants/assets.ts");
/**
 * The source of a vector layer style
 *
 * @since 0.14
 */
var VectorStyleSource;
(function (VectorStyleSource) {
    /**
     * The base vector layer style
     */
    VectorStyleSource[VectorStyleSource["Base"] = 0] = "Base";
    /**
     * The clustered layer style
     */
    VectorStyleSource[VectorStyleSource["Cluster"] = 1] = "Cluster";
})(VectorStyleSource = exports.VectorStyleSource || (exports.VectorStyleSource = {}));
/**
 * @since 0.14
 */
var ClusterClickAction;
(function (ClusterClickAction) {
    ClusterClickAction["ZoomToClusterExtents"] = "ZoomToClusterExtents";
    ClusterClickAction["ShowPopup"] = "ShowPopup";
})(ClusterClickAction = exports.ClusterClickAction || (exports.ClusterClickAction = {}));
/**
 * @since 0.14
 */
function isEvaluatable(arg) {
    return typeof (arg === null || arg === void 0 ? void 0 : arg.expr) == 'string';
}
exports.isEvaluatable = isEvaluatable;
/**
 * The default style for point features
 * @since 0.13
 * @since 0.14 Made deep const immutable
 */
exports.DEFAULT_POINT_CIRCLE_STYLE = {
    type: "Circle",
    fill: {
        color: "#ff0000",
        alpha: 255
    },
    radius: 5,
    stroke: {
        color: "#0000ff",
        alpha: 255,
        width: 1
    }
};
/**
 * The default style for clustered point features
 * @since 0.14
 */
exports.DEFAULT_CLUSTERED_POINT_CIRCLE_STYLE = {
    type: "Circle",
    fill: {
        color: "#ff0000",
        alpha: 255
    },
    radius: { expr: "min(arr_size(features) + 4, 25)" },
    /*
    label: {
        text: expr("if(arr_size(features) > 1, '', arr_size(features))"),
    },*/
    stroke: {
        color: "#0000ff",
        alpha: 255,
        width: 1
    }
};
/**
 * The default icon style for point features
 * @since 0.13
 * @since 0.14 Made deep const immutable
 */
exports.DEFAULT_POINT_ICON_STYLE = {
    type: "Icon",
    anchor: [0.5, 0.5],
    src: assets_1.MAP_MARKER_ICON,
    //size: [24, 24],
    rotateWithView: false,
    rotation: 0,
    //opacity: 255,
    scale: 1
};
/**
 * The default color
 * @since 0.13
 */
exports.DEFAULT_COLOR = "#000000";
/**
 * The default style for line features
 * @since 0.13
 * @since 0.14 Made deep const immutable
 */
exports.DEFAULT_LINE_STYLE = {
    color: "#0000ff",
    alpha: 255,
    width: 1
};
/**
 * The default style for polygon features
 * @since 0.13
 * @since 0.14 Made deep const immutable
 */
exports.DEFAULT_POLY_STYLE = {
    fill: {
        color: "#00ff00",
        alpha: 255
    },
    stroke: {
        color: exports.DEFAULT_COLOR,
        alpha: 255,
        width: 1
    }
};
/**
 * The default vector layer style
 * @since 0.14
 */
exports.DEFAULT_VECTOR_LAYER_STYLE = {
    default: {
        point: exports.DEFAULT_POINT_CIRCLE_STYLE,
        line: exports.DEFAULT_LINE_STYLE,
        polygon: exports.DEFAULT_POLY_STYLE
    }
};
/**
 * The default vector layer style for clustered points
 * @since 0.14
 */
exports.DEFAULT_CLUSTERED_LAYER_STYLE = {
    default: {
        point: exports.DEFAULT_CLUSTERED_POINT_CIRCLE_STYLE
    }
};


/***/ }),

/***/ "./src/api/ol-style-helpers.ts":
/*!*************************************!*\
  !*** ./src/api/ol-style-helpers.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOLStyleFunction = exports.setOLVectorLayerStyle = exports.getClusterSubFeatures = exports.isClusteredFeature = exports.DEFAULT_STYLE_KEY = void 0;
var ol_style_map_set_1 = __webpack_require__(/*! ./ol-style-map-set */ "./src/api/ol-style-map-set.ts");
var common_1 = __webpack_require__(/*! ./common */ "./src/api/common.ts");
/**
 * @since 0.14
 */
exports.DEFAULT_STYLE_KEY = "default";
function isClusteredFeature(feature) {
    var _a;
    if ((_a = getClusterSubFeatures(feature)) === null || _a === void 0 ? void 0 : _a.length) {
        return true;
    }
    return false;
}
exports.isClusteredFeature = isClusteredFeature;
function getClusterSubFeatures(feature) {
    return feature.get("features");
}
exports.getClusterSubFeatures = getClusterSubFeatures;
/**
 * Sets the vector layer style for the given OpenLayers vector layer
 *
 * @since 0.13
 * @since 0.14 style now takes IVectorLayerStyle instead of IVectorFeatureStyle and accepts an optional cluster style
 * and layer can be either a vector layer or a vector tile layer
 */
function setOLVectorLayerStyle(layer, style, clusterStyle) {
    var olstyles = new ol_style_map_set_1.OLStyleMapSet(style, clusterStyle);
    layer.set(common_1.LayerProperty.VECTOR_STYLE, olstyles);
    var layerStyleFunc = function (feature) {
        //TODO: Perf opportunity, cache styles by type_filter|default. Of course, if we ever
        //decide to go for fully dynamic styles (where any property could be an expression to evaluate)
        //such styles are not candidates for caching.
        var sset = this;
        return sset.evaluateStyle(feature);
    }.bind(olstyles);
    layer.setStyle(layerStyleFunc);
}
exports.setOLVectorLayerStyle = setOLVectorLayerStyle;
/**
 * Gets the OL style function for the given style
 *
 * @param style
 * @param clusterStyle
 * @returns
 * @since 0.14
 */
function getOLStyleFunction(style, clusterStyle) {
    var olstyles = new ol_style_map_set_1.OLStyleMapSet(style, clusterStyle);
    var layerStyleFunc = function (feature) {
        //TODO: Perf opportunity, cache styles by type_filter|default. Of course, if we ever
        //decide to go for fully dynamic styles (where any property could be an expression to evaluate)
        //such styles are not candidates for caching.
        var sset = this;
        return sset.evaluateStyle(feature);
    }.bind(olstyles);
    return layerStyleFunc;
}
exports.getOLStyleFunction = getOLStyleFunction;


/***/ }),

/***/ "./src/api/ol-style-map-set.ts":
/*!*************************************!*\
  !*** ./src/api/ol-style-map-set.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OLStyleMapSet = exports.vectorStyleToStyleMap = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var ol_style_helpers_1 = __webpack_require__(/*! ./ol-style-helpers */ "./src/api/ol-style-helpers.ts");
var expr_eval_context_1 = __webpack_require__(/*! ./expr-eval-context */ "./src/api/expr-eval-context.ts");
var ol_style_contracts_1 = __webpack_require__(/*! ./ol-style-contracts */ "./src/api/ol-style-contracts.ts");
var Style_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/Style */ "./node_modules/ol/style/Style.js"));
var Circle_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/Circle */ "./node_modules/ol/style/Circle.js"));
var ol_style_builders_1 = __webpack_require__(/*! ./ol-style-builders */ "./src/api/ol-style-builders.ts");
var Icon_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/style/Icon */ "./node_modules/ol/style/Icon.js"));
var shortid = (0, tslib_1.__importStar)(__webpack_require__(/*! shortid */ "./node_modules/shortid/index.js"));
var number_1 = __webpack_require__(/*! ../utils/number */ "./src/utils/number.ts");
function isDynamicStroke(stroke) {
    if (!stroke) {
        return false;
    }
    return (0, ol_style_contracts_1.isEvaluatable)(stroke.alpha)
        || (0, ol_style_contracts_1.isEvaluatable)(stroke.color)
        || (0, ol_style_contracts_1.isEvaluatable)(stroke.width);
}
function isDynamicFill(fill) {
    if (!fill) {
        return false;
    }
    return (0, ol_style_contracts_1.isEvaluatable)(fill.alpha)
        || (0, ol_style_contracts_1.isEvaluatable)(fill.color);
}
function isDynamicLabel(labelSettings) {
    var label = labelSettings.label;
    if (!label) {
        return false;
    }
    return isDynamicFill(label.backgroundFill)
        || isDynamicStroke(label.backgroundStroke)
        || isDynamicFill(label.fill)
        || (0, ol_style_contracts_1.isEvaluatable)(label.font)
        || (0, ol_style_contracts_1.isEvaluatable)(label.maxAngle)
        || (0, ol_style_contracts_1.isEvaluatable)(label.offsetX)
        || (0, ol_style_contracts_1.isEvaluatable)(label.offsetY)
        || (0, ol_style_contracts_1.isEvaluatable)(label.overflow)
        || (0, ol_style_contracts_1.isEvaluatable)(label.padding)
        || (0, ol_style_contracts_1.isEvaluatable)(label.placement)
        || (0, ol_style_contracts_1.isEvaluatable)(label.rotateWithView)
        || (0, ol_style_contracts_1.isEvaluatable)(label.rotation)
        || (0, ol_style_contracts_1.isEvaluatable)(label.scale)
        || isDynamicStroke(label.stroke)
        || (0, ol_style_contracts_1.isEvaluatable)(label.text)
        || (0, ol_style_contracts_1.isEvaluatable)(label.textAlign)
        || (0, ol_style_contracts_1.isEvaluatable)(label.textBaseline);
}
function isDynamicPointStyle(style) {
    var apts = style;
    var isBaseDynamic = (0, ol_style_contracts_1.isEvaluatable)(apts.radius)
        || isDynamicFill(apts.fill)
        || isDynamicStroke(apts.stroke);
    if (isBaseDynamic) {
        return true;
    }
    return isDynamicLabel(style);
}
function isDynamicLineStyle(style) {
    return isDynamicStroke(style)
        || isDynamicLabel(style);
}
function isDynamicPolygonStyle(style) {
    return isDynamicStroke(style.stroke)
        || isDynamicFill(style.fill)
        || isDynamicLabel(style);
}
function buildStyleMap(pts, lns, pls) {
    //For GeometryCollection, combine point and polygon styles
    var cpts = pts.clone();
    var cpls = pls.clone();
    var gcs = new Style_1.default({
        image: cpts.getImage(),
        stroke: cpls.getStroke(),
        fill: cpls.getFill()
    });
    return {
        id: shortid.generate(),
        Point: pts,
        MultiPoint: pts,
        LineString: lns,
        MultiLineString: lns,
        Polygon: pls,
        MultiPolygon: pls,
        Circle: pls,
        GeometryCollection: gcs
    };
}
function vectorStyleToStyleMap(style) {
    var _a, _b, _c;
    var ptStyle = (_a = style.point) !== null && _a !== void 0 ? _a : ol_style_contracts_1.DEFAULT_POINT_CIRCLE_STYLE;
    var lnStyle = (_b = style.line) !== null && _b !== void 0 ? _b : ol_style_contracts_1.DEFAULT_LINE_STYLE;
    var plStyle = (_c = style.polygon) !== null && _c !== void 0 ? _c : ol_style_contracts_1.DEFAULT_POLY_STYLE;
    var builder = function (feat, context) {
        var pts = new Style_1.default();
        if (ptStyle.type == "Circle") {
            pts.setImage(new Circle_1.default({
                radius: (0, ol_style_builders_1.evalFeature)(ptStyle.radius, feat, context),
                fill: (0, ol_style_builders_1.buildFill)(ptStyle.fill, feat, context),
                stroke: (0, ol_style_builders_1.buildStroke)(ptStyle.stroke, feat, context)
            }));
        }
        else {
            pts.setImage(new Icon_1.default({
                anchor: ptStyle.anchor,
                src: (0, ol_style_builders_1.evalFeature)(ptStyle.src, feat, context),
                rotateWithView: (0, ol_style_builders_1.evalFeature)(ptStyle.rotateWithView, feat, context),
                rotation: (0, number_1.deg2rad)((0, ol_style_builders_1.evalFeature)(ptStyle.rotation, feat, context)),
                scale: (0, ol_style_builders_1.evalFeature)(ptStyle.scale, feat, context)
            }));
        }
        var lns = new Style_1.default({
            stroke: (0, ol_style_builders_1.buildStroke)(lnStyle, feat, context)
        });
        var pls = new Style_1.default({
            stroke: (0, ol_style_builders_1.buildStroke)(plStyle.stroke, feat, context),
            fill: (0, ol_style_builders_1.buildFill)(plStyle.fill, feat, context)
        });
        var ptText = (0, ol_style_builders_1.tryBuildTextStyle)(ptStyle, feat, context);
        var lnText = (0, ol_style_builders_1.tryBuildTextStyle)(lnStyle, feat, context);
        var plsText = (0, ol_style_builders_1.tryBuildTextStyle)(plStyle, feat, context);
        if (ptText) {
            pts.setText(ptText);
        }
        if (lnText) {
            lns.setText(lnText);
        }
        if (plsText) {
            pls.setText(plsText);
        }
        return buildStyleMap(pts, lns, pls);
    };
    var isDynamic = isDynamicPointStyle(ptStyle)
        || isDynamicLineStyle(lnStyle)
        || isDynamicPolygonStyle(plStyle);
    if (isDynamic) {
        return builder;
    }
    else {
        return builder(undefined, undefined);
    }
}
exports.vectorStyleToStyleMap = vectorStyleToStyleMap;
/**
 * @since 0.14
 */
var OLStyleMapSet = /** @class */ (function () {
    function OLStyleMapSet(origStyleDef, clusterStyleDef) {
        this.origStyleDef = origStyleDef;
        this.clusterStyleDef = clusterStyleDef;
        this.rules = {
            default: vectorStyleToStyleMap(origStyleDef.default)
        };
        this.exprContext = new expr_eval_context_1.ExprEvalContext();
        for (var k in origStyleDef) {
            if (k != ol_style_helpers_1.DEFAULT_STYLE_KEY && origStyleDef[k]) {
                this.rules[k] = vectorStyleToStyleMap(origStyleDef[k]);
            }
            if (k != ol_style_helpers_1.DEFAULT_STYLE_KEY) {
                this.exprContext.addFilter(k);
            }
        }
        if (clusterStyleDef === null || clusterStyleDef === void 0 ? void 0 : clusterStyleDef.style) {
            var style = clusterStyleDef.style;
            this.clusterRules = {
                default: vectorStyleToStyleMap(style.default)
            };
            for (var k in style) {
                if (k != ol_style_helpers_1.DEFAULT_STYLE_KEY && style[k]) {
                    this.clusterRules[k] = vectorStyleToStyleMap(style[k]);
                }
                if (k != ol_style_helpers_1.DEFAULT_STYLE_KEY) {
                    this.exprContext.addClusterFilter(k);
                }
            }
        }
        this.defaultStyleMap = vectorStyleToStyleMap({});
    }
    OLStyleMapSet.prototype.toVectorLayerStyle = function () {
        return this.origStyleDef;
    };
    OLStyleMapSet.prototype.toClusterSettings = function () {
        return this.clusterStyleDef;
    };
    OLStyleMapSet.prototype.getClusterClickAction = function () {
        var _a;
        return (_a = this.clusterStyleDef) === null || _a === void 0 ? void 0 : _a.onClick;
    };
    OLStyleMapSet.prototype.evaluateStyle = function (feature) {
        var _a, _b;
        try {
            var g = feature.getGeometry();
            if (!g) {
                return null;
            }
            var gt = g.getType();
            var filter = this.exprContext.evaluateFilter(feature);
            var matchingStyle = void 0;
            var r = (0, ol_style_helpers_1.isClusteredFeature)(feature) ? this.clusterRules : this.rules;
            if (filter) {
                matchingStyle = (_a = r === null || r === void 0 ? void 0 : r[filter]) !== null && _a !== void 0 ? _a : this.defaultStyleMap;
            }
            else {
                //Fallback to default
                matchingStyle = (_b = r === null || r === void 0 ? void 0 : r.default) !== null && _b !== void 0 ? _b : this.defaultStyleMap;
            }
            if (typeof (matchingStyle) == 'function') {
                var esm = matchingStyle(feature, this.exprContext);
                return esm[gt];
            }
            else {
                return matchingStyle[gt];
            }
        }
        catch (e) {
            console.error(e);
            return null;
        }
    };
    return OLStyleMapSet;
}());
exports.OLStyleMapSet = OLStyleMapSet;


/***/ }),

/***/ "./src/api/registry/command-spec.ts":
/*!******************************************!*\
  !*** ./src/api/registry/command-spec.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareSubMenus = exports.parseCommandsInWebLayout = exports.parseWidgetsInAppDef = exports.convertWebLayoutUIItems = exports.convertFlexLayoutUIItems = exports.isFlyoutSpec = exports.isUIWidget = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var command_1 = __webpack_require__(/*! ./command */ "./src/api/registry/command.ts");
var shortid = (0, tslib_1.__importStar)(__webpack_require__(/*! shortid */ "./node_modules/shortid/index.js"));
var component_1 = __webpack_require__(/*! ./component */ "./src/api/registry/component.tsx");
var i18n_1 = __webpack_require__(/*! ../i18n */ "./src/api/i18n.ts");
var never_1 = __webpack_require__(/*! ../../utils/never */ "./src/utils/never.ts");
var string_1 = __webpack_require__(/*! ../../utils/string */ "./src/utils/string.ts");
var logger_1 = __webpack_require__(/*! ../../utils/logger */ "./src/utils/logger.ts");
var weblayout_1 = __webpack_require__(/*! ../contracts/weblayout */ "./src/api/contracts/weblayout.ts");
var init_command_1 = __webpack_require__(/*! ../../actions/init-command */ "./src/actions/init-command.ts");
var assets_1 = __webpack_require__(/*! ../../constants/assets */ "./src/constants/assets.ts");
var constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
function isCommandSpec(cmd) {
    return !(0, string_1.strIsNullOrEmpty)(cmd.command);
}
function isUIWidget(widget) {
    return widget.WidgetType === "UiWidgetType";
}
exports.isUIWidget = isUIWidget;
/**
 * @hidden
 */
function isFlyoutSpec(item) {
    return typeof (item.children) != 'undefined';
}
exports.isFlyoutSpec = isFlyoutSpec;
function makeCommand(widget, noToolbarLabels, cmdType) {
    return { icon: widget.ImageUrl, spriteClass: widget.ImageClass, command: cmdType, label: (noToolbarLabels ? null : widget.Label), tooltip: widget.Tooltip, parameters: widget.Extension };
}
function convertWidget(widget, locale, noToolbarLabels) {
    switch (widget.Type) {
        case "Select":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.Select);
        case "Pan":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.Pan);
        //case "PanQuery":
        //case "PanOnClick":
        case "Zoom":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.Zoom);
        case "ZoomOnClick": //Covers in and out. Look at Factor parameter
            {
                var factor = parseFloat(widget.Extension.Factor);
                if (factor >= 1.0) {
                    return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.ZoomIn);
                }
                else {
                    return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.ZoomOut);
                }
            }
        case "InitialMapView":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.ZoomExtents);
        case "ZoomToSelection":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.ZoomToSelection);
        case "ExtentHistory": //Covers prev and next. Look at Direction parameter
            {
                if (widget.Extension.Direction == "previous") {
                    return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.PreviousView);
                }
                else {
                    return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.NextView);
                }
            }
        case "CenterSelection":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.CenterSelection);
        case "About":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.About);
        case "BufferPanel":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.Buffer);
        case "ClearSelection":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.ClearSelection);
        //case "ColorPicker":
        case "CoordinateTracker":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.CoordinateTracker);
        case "FeatureInfo":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.FeatureInfo);
        case "Geolocation":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.Geolocation);
        //case "GoogleStreetViewer":
        case "Help":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.Help);
        case "Maptip":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.MapTip);
        case "MapMenu":
            return { icon: widget.ImageUrl, spriteClass: widget.ImageClass, label: (noToolbarLabels ? null : widget.Label), tooltip: widget.Tooltip, componentName: component_1.DefaultComponentNames.MapMenu, flyoutId: component_1.DefaultComponentNames.MapMenu + "_" + shortid.generate(), parameters: widget.Extension };
        case "Query":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.Query);
        case "QuickPlot":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.QuickPlot);
        case "Redline":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.Redline);
        case "RefreshMap":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.RefreshMap);
        //case "SaveMap":
        case "InvokeURL": //Commands with this name would've been registered beforehand
        case "Search":
            return { icon: widget.ImageUrl, spriteClass: widget.ImageClass, command: widget.Name, label: (noToolbarLabels ? null : widget.Label), tooltip: widget.Tooltip, parameters: widget.Extension };
        case "SelectPolygon":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.SelectPolygon);
        case "SelectRadius":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.SelectRadius);
        //case "SelectRadiusValue":
        case "SelectWithin":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.SelectWithin);
        case "Theme":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.Theme);
        case "ViewOptions":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.ViewerOptions);
        case "ZoomToSelection":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.ZoomToSelection);
        case "Measure":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.Measure);
        case "Print":
            return makeCommand(widget, noToolbarLabels, command_1.DefaultCommands.Print);
        case "BasemapSwitcher":
            return { icon: widget.ImageUrl, spriteClass: widget.ImageClass, label: (noToolbarLabels ? null : widget.Label), tooltip: widget.Tooltip, componentName: component_1.DefaultComponentNames.BaseMapSwitcher, flyoutId: component_1.DefaultComponentNames.BaseMapSwitcher + "_" + shortid.generate(), parameters: widget.Extension };
        case "InvokeScript":
            return { icon: widget.ImageUrl, spriteClass: widget.ImageClass, command: widget.Name, label: (noToolbarLabels ? null : widget.Label), tooltip: widget.Tooltip, parameters: widget.Extension };
        default:
            return { error: (0, i18n_1.tr)("UNKNOWN_WIDGET", locale, { widget: widget.Type }) };
    }
}
/**
 * @hidden
 *
 * @param isStateless
 * @param items
 * @param widgetsByKey
 * @param locale
 * @param noToolbarLabels
 * @returns
 */
function convertFlexLayoutUIItems(isStateless, items, widgetsByKey, locale, noToolbarLabels) {
    if (noToolbarLabels === void 0) { noToolbarLabels = false; }
    var converted = items.map(function (item) {
        switch (item.Function) {
            case "Widget":
                {
                    var widget = widgetsByKey[item.Widget];
                    if (widget && isUIWidget(widget)) {
                        var cmd = convertWidget(widget, locale, noToolbarLabels);
                        if (isStateless && isCommandSpec(cmd) && !(0, command_1.isSupportedCommandInStatelessMode)(cmd.command)) {
                            console.warn("The widget (" + widget.Name + ") references a command (" + cmd.command + ") that is not supported in stateless mode. This widget will always be disabled");
                        }
                        return cmd;
                    }
                }
            case "Separator":
                return { isSeparator: true };
            case "Flyout":
                return {
                    label: item.Label,
                    tooltip: item.Tooltip,
                    icon: item.ImageUrl,
                    spriteClass: item.ImageClass,
                    children: convertFlexLayoutUIItems(isStateless, item.Item, widgetsByKey, locale)
                };
            default:
                (0, never_1.assertNever)(item);
        }
        return null;
    })
        .filter(function (i) { return i != null; })
        .map(function (i) { return i; });
    return converted;
}
exports.convertFlexLayoutUIItems = convertFlexLayoutUIItems;
function tryTranslateImageUrlToSpriteClass(imageUrl) {
    switch (imageUrl) {
        case "../stdicons/icon_invokeurl.gif":
            return assets_1.SPRITE_INVOKE_URL;
        case "../stdicons/icon_invokescript.gif":
            return assets_1.SPRITE_INVOKE_SCRIPT;
    }
}
/**
 * @hidden
 *
 * @param items
 * @param cmdsByKey
 * @param locale
 * @param noToolbarLabels
 * @returns
 */
function convertWebLayoutUIItems(items, cmdsByKey, locale, noToolbarLabels) {
    if (noToolbarLabels === void 0) { noToolbarLabels = true; }
    var converted = (items || []).map(function (item) {
        if ((0, weblayout_1.isCommandItem)(item)) {
            var cmdDef = cmdsByKey[item.Command];
            if (!cmdDef) {
                (0, logger_1.warn)("Invalid reference to command: " + item.Command);
                return { error: (0, i18n_1.tr)("UNKNOWN_COMMAND_REFERENCE", locale, { command: item.Command }) };
            }
            else if (cmdDef.TargetViewer != "Dwf") {
                var icon = {};
                if (cmdDef.ImageURL) {
                    icon.spriteClass = tryTranslateImageUrlToSpriteClass(cmdDef.ImageURL);
                    if (!icon.spriteClass) {
                        icon.icon = cmdDef.ImageURL;
                    }
                }
                var commonParams = {};
                if ((0, weblayout_1.isTargetedCommand)(cmdDef)) {
                    commonParams.Target = cmdDef.Target;
                    commonParams.TargetFrame = cmdDef.TargetFrame;
                }
                if ((0, weblayout_1.isBasicCommand)(cmdDef)) {
                    var action = cmdDef.Action;
                    if (action == "ZoomRectangle") {
                        action = command_1.DefaultCommands.Zoom;
                    }
                    else if (action == "FitToWindow") {
                        action = command_1.DefaultCommands.ZoomExtents;
                    }
                    else if (action == "Refresh") {
                        action = command_1.DefaultCommands.RefreshMap;
                    }
                    return (0, tslib_1.__assign)({ command: action, label: (noToolbarLabels ? null : cmdDef.Label), tooltip: cmdDef.Tooltip, parameters: commonParams }, icon);
                }
                else {
                    switch (cmdDef["@xsi:type"]) {
                        case "ViewOptionsCommandType":
                            return { command: command_1.DefaultCommands.ViewerOptions, label: (noToolbarLabels ? null : cmdDef.Label), tooltip: cmdDef.Tooltip, parameters: commonParams };
                        case "MeasureCommandType":
                            return { command: command_1.DefaultCommands.Measure, label: (noToolbarLabels ? null : cmdDef.Label), tooltip: cmdDef.Tooltip, parameters: commonParams };
                        case "HelpCommandType":
                            return { command: command_1.DefaultCommands.Help, label: (noToolbarLabels ? null : cmdDef.Label), tooltip: cmdDef.Tooltip, parameters: commonParams };
                        case "BufferCommandType":
                            return { command: command_1.DefaultCommands.Buffer, label: (noToolbarLabels ? null : cmdDef.Label), tooltip: cmdDef.Tooltip, parameters: commonParams };
                        case "SelectWithinCommandType":
                            return { command: command_1.DefaultCommands.SelectWithin, label: (noToolbarLabels ? null : cmdDef.Label), tooltip: cmdDef.Tooltip, parameters: commonParams };
                        case "GetPrintablePageCommandType":
                            return { command: command_1.DefaultCommands.QuickPlot, label: (noToolbarLabels ? null : cmdDef.Label), tooltip: cmdDef.Tooltip, parameters: commonParams };
                        default:
                            return (0, tslib_1.__assign)({ command: cmdDef.Name, label: (noToolbarLabels ? null : cmdDef.Label), tooltip: cmdDef.Tooltip, parameters: commonParams }, icon);
                    }
                }
            }
        }
        else if ((0, weblayout_1.isSeparatorItem)(item)) {
            return { isSeparator: true };
        }
        else if ((0, weblayout_1.isFlyoutItem)(item)) {
            return {
                label: item.Label,
                tooltip: item.Tooltip,
                children: convertWebLayoutUIItems(item.SubItem, cmdsByKey, locale, false)
            };
        }
        else {
            (0, never_1.assertNever)(item);
        }
        return null;
    })
        .filter(function (i) { return i != null; })
        .map(function (i) { return i; });
    return converted;
}
exports.convertWebLayoutUIItems = convertWebLayoutUIItems;
function convertToCommandTarget(fusionCmdTarget) {
    //Treat empty/undefined target as new window
    if ((0, string_1.strIsNullOrEmpty)(fusionCmdTarget)) {
        return "NewWindow";
    }
    switch (fusionCmdTarget) {
        case "SearchWindow":
        case "InvokeUrlWindow":
            return "NewWindow";
        case "TaskPane":
            return "TaskPane";
        default:
            return "SpecifiedFrame";
    }
}
function parseWidgetsInAppDef(appDef, cmdRegister) {
    var taskPane;
    var viewSize;
    var hasLegend = false;
    var hasStatus = false;
    var hasNavigator = false;
    var hasSelectionPanel = false;
    var hasTaskBar = false;
    var initialTask;
    var isStatelessAppDef = (0, init_command_1.isStateless)(appDef);
    var widgetsByKey = {};
    //Register any InvokeURL and Search commands. Also set capabilities along the way
    for (var _i = 0, _a = appDef.WidgetSet; _i < _a.length; _i++) {
        var widgetSet = _a[_i];
        for (var _b = 0, _c = widgetSet.Widget; _b < _c.length; _b++) {
            var widget = _c[_b];
            var cmd = widget.Extension;
            switch (widget.Type) {
                case "TaskPane":
                    taskPane = widget;
                    break;
                case "ViewSize":
                    viewSize = widget;
                    break;
                case "Legend":
                    hasLegend = true;
                    break;
                case "SelectionPanel":
                    hasSelectionPanel = true;
                    break;
                case "CursorPosition":
                case "SelectionInfo":
                    hasStatus = true;
                    break;
                case "Navigator":
                    hasNavigator = true;
                    break;
                case "Search":
                    cmdRegister(widget.Name, {
                        layer: cmd.Layer,
                        prompt: cmd.Prompt,
                        resultColumns: cmd.ResultColumns,
                        filter: cmd.Filter,
                        matchLimit: cmd.MatchLimit,
                        title: (cmd.Title || (isUIWidget(widget) ? widget.Label : undefined)),
                        target: convertToCommandTarget(cmd.Target),
                        targetFrame: cmd.Target
                    });
                    if (isStatelessAppDef) {
                        console.warn("The search command (" + widget.Name + ") is not supported in stateless mode. This widget will always be disabled");
                    }
                    break;
                case "InvokeURL":
                    cmdRegister(widget.Name, {
                        url: cmd.Url,
                        disableIfSelectionEmpty: cmd.DisableIfSelectionEmpty,
                        target: convertToCommandTarget(cmd.Target),
                        targetFrame: cmd.Target,
                        parameters: (cmd.AdditionalParameter || []).map(function (p) {
                            return { name: p.Key, value: p.Value };
                        }),
                        title: isUIWidget(widget) ? widget.Label : undefined
                    }); /*
                        if (config.isStateless && !strStartsWith(cmd.Url, "component://")) {
                            console.warn(`The InvokeURL command (${widget.Name}) is not supported in stateless mode. This widget will always be disabled`);
                        }*/
                    break;
            }
            widgetsByKey[widget.Name] = widget;
        }
    }
    if (taskPane) {
        hasTaskBar = true; //Fusion flex layouts can't control the visiblity of this
        initialTask = taskPane.Extension.InitialTask || "server/TaskPane.html";
    }
    else {
        initialTask = "server/TaskPane.html";
    }
    return {
        taskPane: taskPane,
        viewSize: viewSize,
        initialTask: initialTask,
        hasLegend: hasLegend,
        hasStatus: hasStatus,
        hasNavigator: hasNavigator,
        hasSelectionPanel: hasSelectionPanel,
        hasTaskBar: hasTaskBar,
        isStateless: isStatelessAppDef,
        widgetsByKey: widgetsByKey
    };
}
exports.parseWidgetsInAppDef = parseWidgetsInAppDef;
function parseCommandsInWebLayout(webLayout, cmdRegister) {
    var cmdsByKey = {};
    //Register any InvokeURL and Search commands
    for (var _i = 0, _a = webLayout.CommandSet.Command; _i < _a.length; _i++) {
        var cmd = _a[_i];
        if ((0, weblayout_1.isInvokeURLCommand)(cmd)) {
            cmdRegister(cmd.Name, {
                url: cmd.URL,
                disableIfSelectionEmpty: cmd.DisableIfSelectionEmpty,
                target: cmd.Target,
                targetFrame: cmd.TargetFrame,
                parameters: (cmd.AdditionalParameter || []).map(function (p) {
                    return { name: p.Key, value: p.Value };
                }),
                title: cmd.Label
            });
        }
        else if ((0, weblayout_1.isSearchCommand)(cmd)) {
            cmdRegister(cmd.Name, {
                layer: cmd.Layer,
                prompt: cmd.Prompt,
                target: cmd.Target,
                targetFrame: cmd.TargetFrame,
                resultColumns: cmd.ResultColumns,
                filter: cmd.Filter,
                matchLimit: cmd.MatchLimit,
                title: cmd.Label
            });
        }
        cmdsByKey[cmd.Name] = cmd;
    }
    return cmdsByKey;
}
exports.parseCommandsInWebLayout = parseCommandsInWebLayout;
/**
 * @hidden
 *
 * @param tbConf
 * @returns
 */
function prepareSubMenus(tbConf) {
    var prepared = {
        toolbars: {},
        flyouts: {}
    };
    var bFoundContextMenu = false;
    for (var key in tbConf) {
        if (key == constants_1.WEBLAYOUT_CONTEXTMENU) {
            bFoundContextMenu = true;
        }
        //Special cases: Task pane and Context Menu. Transfer all to flyout
        if (key == constants_1.WEBLAYOUT_TASKMENU || key == constants_1.WEBLAYOUT_CONTEXTMENU) {
            var flyoutId = key;
            prepared.flyouts[flyoutId] = {
                children: tbConf[key].items
            };
        }
        else {
            prepared.toolbars[key] = {
                items: []
            };
            for (var _i = 0, _a = tbConf[key].items; _i < _a.length; _i++) {
                var item = _a[_i];
                //Special case: contextmenu is all inline
                if (isFlyoutSpec(item) && key != constants_1.WEBLAYOUT_CONTEXTMENU) {
                    var flyoutId = item.label + "_" + shortid.generate();
                    prepared.toolbars[key].items.push({
                        label: item.label,
                        tooltip: item.tooltip,
                        icon: item.icon,
                        spriteClass: item.spriteClass,
                        flyoutId: flyoutId
                    });
                    prepared.flyouts[flyoutId] = {
                        children: item.children
                    };
                }
                else {
                    prepared.toolbars[key].items.push(item);
                }
            }
        }
    }
    return [prepared, bFoundContextMenu];
}
exports.prepareSubMenus = prepareSubMenus;


/***/ }),

/***/ "./src/api/registry/command.ts":
/*!*************************************!*\
  !*** ./src/api/registry/command.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCommand = exports.registerCommand = exports.openUrlInTarget = exports.isSupportedCommandInStatelessMode = exports.DefaultCommands = exports.CommandConditions = exports.reduceAppToToolbarState = exports.mapToolbarReference = exports.mergeInvokeUrlParameters = void 0;
var common_1 = __webpack_require__(/*! ../../api/common */ "./src/api/common.ts");
var runtime_1 = __webpack_require__(/*! ../../api/runtime */ "./src/api/runtime.ts");
var i18n_1 = __webpack_require__(/*! ../i18n */ "./src/api/i18n.ts");
var asset_1 = __webpack_require__(/*! ../../utils/asset */ "./src/utils/asset.ts");
var assets_1 = __webpack_require__(/*! ../../constants/assets */ "./src/constants/assets.ts");
var never_1 = __webpack_require__(/*! ../../utils/never */ "./src/utils/never.ts");
var url_1 = __webpack_require__(/*! ../../utils/url */ "./src/utils/url.ts");
var actions_1 = __webpack_require__(/*! ../../constants/actions */ "./src/constants/actions.ts");
var modal_1 = __webpack_require__(/*! ../../actions/modal */ "./src/actions/modal.ts");
var logger_1 = __webpack_require__(/*! ../../utils/logger */ "./src/utils/logger.ts");
var FUSION_ICON_REGEX = /images\/icons\/[a-zA-Z\-]*.png/;
function fixIconPath(path) {
    if (FUSION_ICON_REGEX.test(path)) {
        return ((0, asset_1.getAssetRoot)() + "/" + path).replace(/\/\//g, "/");
    }
    return path;
}
function fusionFixSpriteClass(tb, cmd) {
    if (tb.spriteClass) {
        return tb.spriteClass;
    }
    if (cmd && cmd.iconClass) {
        return cmd.iconClass;
    }
    return undefined;
}
/**
 * @hidden
 */
function mergeInvokeUrlParameters(currentParameters, extraParameters) {
    var currentP = currentParameters.reduce(function (prev, current, i, arr) {
        prev[current.name] = current.value;
        return prev;
    }, {});
    if (extraParameters) {
        var keys = Object.keys(extraParameters);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var k = keys_1[_i];
            currentP[k] = extraParameters[k];
        }
    }
    var merged = [];
    var mkeys = Object.keys(currentP);
    for (var _a = 0, mkeys_1 = mkeys; _a < mkeys_1.length; _a++) {
        var k = mkeys_1[_a];
        merged.push({ name: k, value: currentP[k] });
    }
    return merged;
}
exports.mergeInvokeUrlParameters = mergeInvokeUrlParameters;
function fixChildItems(childItems, state, commandInvoker) {
    return childItems
        .map(function (tb) { return mapToolbarReference(tb, state, commandInvoker); })
        .filter(function (tb) { return tb != null; });
}
//TODO: This function should be its own react hook that layers on top of the
//useDispatch() and useSelector() hooks provided by react-redux
/**
 * @hidden
 */
function mapToolbarReference(tb, state, commandInvoker) {
    if (tb.error) {
        var cmdItem = {
            iconClass: assets_1.SPRITE_ICON_ERROR,
            tooltip: tb.error,
            label: (0, i18n_1.tr)("ERROR"),
            selected: common_1.ALWAYS_FALSE,
            enabled: common_1.ALWAYS_FALSE,
            invoke: common_1.NOOP
        };
        return cmdItem;
    }
    else if (tb.componentName) {
        return {
            icon: tb.icon,
            iconClass: fusionFixSpriteClass(tb),
            flyoutId: tb.flyoutId,
            tooltip: tb.tooltip,
            label: tb.label,
            componentName: tb.componentName,
            componentProps: tb.componentProps
        };
    }
    else if (tb.isSeparator === true) {
        return { isSeparator: true };
    }
    else if (tb.command) {
        var cmd_1 = getCommand(tb.command);
        if (cmd_1 != null) {
            var cmdItem = {
                icon: fixIconPath(tb.icon || cmd_1.icon),
                iconClass: fusionFixSpriteClass(tb, cmd_1),
                tooltip: tb.tooltip,
                label: tb.label,
                selected: function () { return cmd_1.selected(state); },
                enabled: function () { return cmd_1.enabled(state, tb.parameters); },
                invoke: function () { return commandInvoker(cmd_1, tb.parameters); }
            };
            return cmdItem;
        }
    }
    else if (tb.children) {
        var childItems = tb.children;
        return {
            icon: fixIconPath(tb.icon),
            iconClass: fusionFixSpriteClass(tb),
            label: tb.label,
            tooltip: tb.tooltip,
            childItems: fixChildItems(childItems, state, commandInvoker)
        };
    }
    else if (tb.label && tb.flyoutId) {
        return {
            icon: fixIconPath(tb.icon),
            iconClass: fusionFixSpriteClass(tb),
            label: tb.label,
            tooltip: tb.tooltip,
            flyoutId: tb.flyoutId
        };
    }
    return null;
}
exports.mapToolbarReference = mapToolbarReference;
/**
 * Helper function to reduce full application state to state relevant for toolbar items
 *
 * @param state The full application state
 * @since 0.13
 */
function reduceAppToToolbarState(state) {
    var _a;
    var hasSelection = false;
    var hasClientSelection = false;
    var hasPreviousView = false;
    var hasNextView = false;
    var visibleWmsLayerCount = 0;
    var selection = (0, common_1.getSelectionSet)(state);
    hasSelection = (selection != null && selection.SelectedFeatures != null);
    if (state.config.activeMapName) {
        hasClientSelection = state.mapState[state.config.activeMapName].clientSelection != null;
        hasPreviousView = state.mapState[state.config.activeMapName].historyIndex > 0;
        hasNextView = state.mapState[state.config.activeMapName].historyIndex < state.mapState[state.config.activeMapName].history.length - 1;
        visibleWmsLayerCount = ((_a = state.mapState[state.config.activeMapName].layers) !== null && _a !== void 0 ? _a : []).filter(function (l) { return l.visible && l.selectable && l.type == "WMS"; }).length;
    }
    return {
        stateless: state.config.viewer.isStateless,
        visibleAndSelectableWmsLayerCount: visibleWmsLayerCount,
        busyWorkerCount: state.viewer.busyCount,
        hasSelection: hasSelection,
        hasClientSelection: hasClientSelection,
        hasPreviousView: hasPreviousView,
        hasNextView: hasNextView,
        activeTool: state.viewer.tool,
        featureTooltipsEnabled: state.viewer.featureTooltipsEnabled
    };
}
exports.reduceAppToToolbarState = reduceAppToToolbarState;
/**
 * Common command condition evaluators
 *
 * @export
 * @class CommandConditions
 */
var CommandConditions = /** @class */ (function () {
    function CommandConditions() {
    }
    /**
     * The viewer is not busy
     *
     * @static
     * @param {Readonly<IToolbarAppState>} state
     * @returns {boolean}
     *
     * @memberof CommandConditions
     */
    CommandConditions.isNotBusy = function (state) {
        return state.busyWorkerCount == 0;
    };
    /**
     * The viewer has a MapGuide selection set
     *
     * @static
     * @param {Readonly<IToolbarAppState>} state
     * @returns {boolean}
     *
     * @memberof CommandConditions
     */
    CommandConditions.hasSelection = function (state) {
        return state.hasSelection;
    };
    /**
     * The viewer has a client-side selection set
     *
     * @static
     * @param state
     * @returns
     *
     * @since 0.14
     */
    CommandConditions.hasClientSelection = function (state) {
        return state.hasClientSelection;
    };
    /**
     * The command is set to be disabled if selection is empty
     *
     * @static
     * @param {*} [parameters]
     * @returns {boolean}
     *
     * @memberof CommandConditions
     */
    CommandConditions.disabledIfEmptySelection = function (state, parameters) {
        if (!state.hasSelection) {
            return (parameters != null && (parameters.DisableIfSelectionEmpty == "true" || parameters.DisableIfSelectionEmpty == true));
        }
        else
            return false;
    };
    /**
     * The viewer has a previous view in the view navigation stack
     *
     * @static
     * @param {Readonly<IToolbarAppState>} state
     * @returns {boolean}
     *
     * @memberof CommandConditions
     */
    CommandConditions.hasPreviousView = function (state) {
        return state.hasPreviousView;
    };
    /**
     * The viewer has a next view in the view navigation stack
     *
     * @static
     * @param {Readonly<IToolbarAppState>} state
     * @returns {boolean}
     *
     * @memberof CommandConditions
     */
    CommandConditions.hasNextView = function (state) {
        return state.hasNextView;
    };
    return CommandConditions;
}());
exports.CommandConditions = CommandConditions;
/**
 * The set of default command names
 *
 * @export
 * @class DefaultCommands
 */
var DefaultCommands;
(function (DefaultCommands) {
    DefaultCommands["Select"] = "Select";
    DefaultCommands["Pan"] = "Pan";
    DefaultCommands["Zoom"] = "Zoom";
    DefaultCommands["MapTip"] = "MapTip";
    DefaultCommands["ZoomIn"] = "ZoomIn";
    DefaultCommands["ZoomOut"] = "ZoomOut";
    DefaultCommands["RestoreView"] = "RestoreView";
    DefaultCommands["ZoomExtents"] = "ZoomExtents";
    DefaultCommands["SelectRadius"] = "SelectRadius";
    DefaultCommands["SelectPolygon"] = "SelectPolygon";
    DefaultCommands["ClearSelection"] = "ClearSelection";
    DefaultCommands["ZoomToSelection"] = "ZoomToSelection";
    DefaultCommands["PanLeft"] = "PanLeft";
    DefaultCommands["PanRight"] = "PanRight";
    DefaultCommands["PanUp"] = "PanUp";
    DefaultCommands["PanDown"] = "PanDown";
    DefaultCommands["RefreshMap"] = "RefreshMap";
    DefaultCommands["PreviousView"] = "PreviousView";
    DefaultCommands["NextView"] = "NextView";
    DefaultCommands["About"] = "About";
    DefaultCommands["Help"] = "Help";
    DefaultCommands["Measure"] = "Measure";
    DefaultCommands["ViewerOptions"] = "ViewerOptions";
    DefaultCommands["Buffer"] = "Buffer";
    DefaultCommands["SelectWithin"] = "SelectWithin";
    DefaultCommands["QuickPlot"] = "QuickPlot";
    DefaultCommands["Redline"] = "Redline";
    DefaultCommands["FeatureInfo"] = "FeatureInfo";
    DefaultCommands["Theme"] = "Theme";
    DefaultCommands["Query"] = "Query";
    DefaultCommands["Geolocation"] = "Geolocation";
    DefaultCommands["CoordinateTracker"] = "CoordinateTracker";
    /**
     * @since 0.11
     */
    DefaultCommands["AddManageLayers"] = "AddManageLayers";
    /**
     * @since 0.11
     */
    DefaultCommands["CenterSelection"] = "CenterSelection";
    /**
     * @since 0.14
     */
    DefaultCommands["Print"] = "Print";
})(DefaultCommands = exports.DefaultCommands || (exports.DefaultCommands = {}));
var commands = {};
function isInvokeUrlCommand(cmdDef) {
    return typeof cmdDef.url !== 'undefined';
}
function isSearchCommand(cmdDef) {
    return typeof cmdDef.layer !== 'undefined';
}
function openModalUrl(name, dispatch, url, modalTitle) {
    dispatch((0, modal_1.showModalUrl)({
        modal: {
            title: modalTitle || (0, i18n_1.tr)(name),
            backdrop: false,
            size: common_1.DEFAULT_MODAL_SIZE,
            overflowYScroll: true
        },
        name: name,
        url: url
    }));
}
function isSupportedCommandInStatelessMode(name) {
    switch (name) {
        case DefaultCommands.Select:
        case DefaultCommands.MapTip:
        case DefaultCommands.QuickPlot:
        case DefaultCommands.SelectRadius:
        case DefaultCommands.SelectPolygon:
        case DefaultCommands.ClearSelection:
        case DefaultCommands.ZoomToSelection:
        case DefaultCommands.Buffer:
        case DefaultCommands.SelectWithin:
        case DefaultCommands.Redline:
        case DefaultCommands.FeatureInfo:
        case DefaultCommands.Query:
        case DefaultCommands.Theme:
        case DefaultCommands.CenterSelection:
            return false;
    }
    return true;
}
exports.isSupportedCommandInStatelessMode = isSupportedCommandInStatelessMode;
/**
 * Opens the given URL in the specified target
 *
 * @hidden
 * @param name
 * @param cmdDef
 * @param dispatch
 * @param url
 */
function openUrlInTarget(name, cmdDef, hasTaskPane, dispatch, url, modalTitle) {
    var target = cmdDef.target;
    if (target == "TaskPane") {
        //If there's no actual task pane, fallback to modal dialog
        if (!hasTaskPane) {
            openModalUrl(name, dispatch, url, modalTitle);
        }
        else {
            dispatch({
                type: actions_1.ActionType.TASK_INVOKE_URL,
                payload: {
                    url: url
                }
            });
        }
    }
    else if (target == "NewWindow") {
        openModalUrl(name, dispatch, url, modalTitle);
    }
    else if (target == "SpecifiedFrame") {
        if (cmdDef.targetFrame) {
            var frames_1 = window.frames;
            var bInvoked = false;
            for (var i = 0; i < frames_1.length; i++) {
                if (frames_1[i].name == cmdDef.targetFrame) {
                    frames_1[i].location = url;
                    bInvoked = true;
                    break;
                }
            }
            if (!bInvoked) {
                (0, logger_1.error)("Frame not found: " + cmdDef.targetFrame);
            }
        }
        else {
            (0, logger_1.error)("Command " + name + " has a target of \"SpecifiedFrame\", but does not specify a target frame");
        }
    }
    else {
        (0, never_1.assertNever)(target);
    }
}
exports.openUrlInTarget = openUrlInTarget;
/**
 * Registers a viewer command
 *
 * @export
 * @param {string} name
 * @param {(ICommand | IInvokeUrlCommand | ISearchCommand)} cmdDef
 */
function registerCommand(name, cmdDef) {
    var cmd;
    if (isInvokeUrlCommand(cmdDef)) {
        cmd = {
            icon: cmdDef.icon,
            iconClass: cmdDef.iconClass,
            title: cmdDef.title,
            enabled: function (state) {
                if (cmdDef.disableIfSelectionEmpty === true) {
                    return CommandConditions.hasSelection(state);
                }
                return true;
            },
            selected: function () { return false; },
            invoke: function (dispatch, getState, viewer, parameters) {
                var state = getState();
                var config = state.config;
                var map = (0, common_1.getRuntimeMap)(state);
                var params = mergeInvokeUrlParameters(cmdDef.parameters, parameters);
                var url = (0, url_1.ensureParameters)(cmdDef.url, map === null || map === void 0 ? void 0 : map.Name, map === null || map === void 0 ? void 0 : map.SessionId, config.locale, true, params);
                openUrlInTarget(name, cmdDef, config.capabilities.hasTaskPane, dispatch, url, cmd.title);
            }
        };
    }
    else if (isSearchCommand(cmdDef)) {
        cmd = {
            icon: cmdDef.icon,
            iconClass: cmdDef.iconClass,
            title: cmdDef.title,
            enabled: function (state) { return !state.stateless; },
            selected: function () { return false; },
            invoke: function (dispatch, getState, viewer, parameters) {
                var state = getState();
                var config = state.config;
                var map = (0, common_1.getRuntimeMap)(state);
                if (map) {
                    var url = (0, url_1.ensureParameters)((0, runtime_1.getFusionRoot)() + "/widgets/Search/SearchPrompt.php", map.Name, map.SessionId, config.locale, false)
                        + "&popup=0"
                        + "&target=TaskPane"
                        + ("&title=" + encodeURIComponent(cmdDef.title))
                        + ("&prompt=" + encodeURIComponent(cmdDef.prompt))
                        + ("&layer=" + encodeURIComponent(cmdDef.layer))
                        + ("&pointZoomLevel=" + parameters.PointZoomLevel)
                        + (cmdDef.filter ? "&filter=" + encodeURIComponent(cmdDef.filter) : '')
                        + ("&limit=" + cmdDef.matchLimit)
                        + ("&properties=" + (cmdDef.resultColumns.Column || []).map(function (col) { return col.Property; }).join(","))
                        + ("&propNames=" + (cmdDef.resultColumns.Column || []).map(function (col) { return col.Name; }).join(","));
                    openUrlInTarget(name, cmdDef, config.capabilities.hasTaskPane, dispatch, url, cmd.title);
                }
            }
        };
    }
    else {
        cmd = cmdDef;
    }
    commands[name] = cmd;
}
exports.registerCommand = registerCommand;
/**
 * Gets a registered viewer command by its name
 *
 * @export
 * @param {string} name
 * @returns {(ICommand | undefined)}
 */
function getCommand(name) {
    return commands[name];
}
exports.getCommand = getCommand;


/***/ }),

/***/ "./src/api/registry/component.tsx":
/*!****************************************!*\
  !*** ./src/api/registry/component.tsx ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlaceholderComponent = exports.getComponentFactory = exports.registerComponentFactory = exports.DefaultComponentNames = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var error_1 = __webpack_require__(/*! ../../components/error */ "./src/components/error.tsx");
var i18n_1 = __webpack_require__(/*! ../i18n */ "./src/api/i18n.ts");
/**
 * The default set of component names
 *
 * @export
 * @class DefaultComponentNames
 */
var DefaultComponentNames;
(function (DefaultComponentNames) {
    DefaultComponentNames["Legend"] = "Legend";
    DefaultComponentNames["SelectionPanel"] = "SelectionPanel";
    DefaultComponentNames["Map"] = "Map";
    DefaultComponentNames["Navigator"] = "Navigator";
    DefaultComponentNames["MouseCoordinates"] = "MouseCoordinates";
    DefaultComponentNames["ScaleDisplay"] = "ScaleDisplay";
    DefaultComponentNames["SelectedFeatureCount"] = "SelectedFeatureCount";
    DefaultComponentNames["PoweredByMapGuide"] = "PoweredByMapGuide";
    DefaultComponentNames["TaskPane"] = "TaskPane";
    DefaultComponentNames["About"] = "About";
    DefaultComponentNames["SessionExpired"] = "SessionExpired";
    DefaultComponentNames["Measure"] = "Measure";
    DefaultComponentNames["ViewerOptions"] = "ViewerOptions";
    DefaultComponentNames["QuickPlot"] = "QuickPlot";
    DefaultComponentNames["BaseMapSwitcher"] = "BaseMapSwitcher";
    DefaultComponentNames["MapMenu"] = "MapMenu";
    DefaultComponentNames["ViewSize"] = "ViewSize";
    DefaultComponentNames["CoordinateTracker"] = "CoordinateTracker";
    DefaultComponentNames["AddManageLayers"] = "AddManageLayers";
    DefaultComponentNames["ShareLinkToView"] = "ShareLinkToView";
})(DefaultComponentNames = exports.DefaultComponentNames || (exports.DefaultComponentNames = {}));
var components = {};
/**
 * Registers a react component factory function for the given component id
 *
 * @export
 * @param {string} id
 * @param {ComponentFactory} factory
 */
function registerComponentFactory(id, factory) {
    components[id] = factory;
}
exports.registerComponentFactory = registerComponentFactory;
/**
 * Gets the registered component factory function for the given component id
 *
 * @export
 * @param {string} id
 * @returns {ComponentFactory}
 */
function getComponentFactory(id) {
    return components[id];
}
exports.getComponentFactory = getComponentFactory;
/**
 * A component placeholder
 *
 * @export
 * @class PlaceholderComponent
 * @extends {React.Component<IPlaceholderComponentProps, any>}
 */
var PlaceholderComponent = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(PlaceholderComponent, _super);
    function PlaceholderComponent(props) {
        return _super.call(this, props) || this;
    }
    PlaceholderComponent.prototype.render = function () {
        var _a = this.props, id = _a.id, componentProps = _a.componentProps;
        var factory = getComponentFactory(id);
        if (factory) {
            return factory(componentProps);
        }
        else {
            return React.createElement(error_1.Error, { error: (0, i18n_1.tr)("ERR_UNREGISTERED_COMPONENT", this.props.locale, { componentId: id }) });
        }
    };
    return PlaceholderComponent;
}(React.Component));
exports.PlaceholderComponent = PlaceholderComponent;


/***/ }),

/***/ "./src/api/registry/external-layer.ts":
/*!********************************************!*\
  !*** ./src/api/registry/external-layer.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExternalLayerFactoryRegistry = void 0;
/**
 * Defines a registry of custom vector layer source drivers
 */
var ExternalLayerFactoryRegistry = /** @class */ (function () {
    function ExternalLayerFactoryRegistry() {
        this._vectorCreators = {};
        if (ExternalLayerFactoryRegistry._instance) {
            throw new Error("Error: Instantiation failed: Use ExternalLayerFactoryRegistry.getInstance() instead of new.");
        }
        ExternalLayerFactoryRegistry._instance = this;
    }
    /**
     * Gets the registry instance
     * @since 0.14
     */
    ExternalLayerFactoryRegistry.getInstance = function () {
        return ExternalLayerFactoryRegistry._instance;
    };
    /**
     * Registers the given external vector layer factory method
     *
     * @param driverName
     * @param creator
     * @since 0.14
     */
    ExternalLayerFactoryRegistry.prototype.registerExternalVectorLayerCreator = function (driverName, creator) {
        this._vectorCreators[driverName] = creator;
    };
    /**
     * Gets the external vector layer factory method for the given driver
     *
     * @param driverName
     */
    ExternalLayerFactoryRegistry.prototype.getExternalVectorLayerCreator = function (driverName) {
        return this._vectorCreators[driverName];
    };
    ExternalLayerFactoryRegistry._instance = new ExternalLayerFactoryRegistry();
    return ExternalLayerFactoryRegistry;
}());
exports.ExternalLayerFactoryRegistry = ExternalLayerFactoryRegistry;


/***/ }),

/***/ "./src/api/registry/layout.ts":
/*!************************************!*\
  !*** ./src/api/registry/layout.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLayout = exports.registerLayout = exports.getLayoutCapabilities = void 0;
var layouts = {};
var layoutCaps = {};
/**
 * Gets the capabilities of the given layout template
 *
 * @param name
 * @returns
 * @since 0.14
 */
function getLayoutCapabilities(name) {
    return layoutCaps[name];
}
exports.getLayoutCapabilities = getLayoutCapabilities;
/**
 * Register the given react layout template component factory function for the given
 * template name
 *
 * @export
 * @param {string} name
 * @param {LayoutFactory} factory
 * @param caps The capabilities of this template
 * @since 0.14
 */
function registerLayout(name, factory, caps) {
    layouts[name] = factory;
    layoutCaps[name] = caps;
}
exports.registerLayout = registerLayout;
/**
 * Gets the registerd react layout template component factory function for the given
 * template name
 *
 * @export
 * @param {string} name
 * @returns {LayoutFactory}
 */
function getLayout(name) {
    return layouts[name];
}
exports.getLayout = getLayout;


/***/ }),

/***/ "./src/api/registry/projections.ts":
/*!*****************************************!*\
  !*** ./src/api/registry/projections.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ensureProjection = exports.resolveProjectionFromEpsgIoAsync = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var proj4_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! proj4 */ "./node_modules/proj4/lib/index.js"));
var error_1 = __webpack_require__(/*! ../error */ "./src/api/error.ts");
var i18n_1 = __webpack_require__(/*! ../i18n */ "./src/api/i18n.ts");
var string_1 = __webpack_require__(/*! ../../utils/string */ "./src/utils/string.ts");
var proj4_2 = __webpack_require__(/*! ol/proj/proj4 */ "./node_modules/ol/proj/proj4.js");
var logger_1 = __webpack_require__(/*! ../../utils/logger */ "./src/utils/logger.ts");
/**
 * Performs a projection definititon lookup at epsg.io for the given EPSG code
 *
 * @export
 * @param {string | number} epsg
 * @param {string} locale
 * @param {string} mapDef
 * @returns {Promise<any>}
 * @since 0.13
 */
function resolveProjectionFromEpsgIoAsync(epsg, locale, mapDef) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var r, resp;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fetch("//epsg.io?format=json&q=" + epsg)];
                case 1:
                    r = _a.sent();
                    return [4 /*yield*/, r.json()];
                case 2:
                    resp = _a.sent();
                    if (resp.results && resp.results.length > 0) {
                        proj4_1.default.defs("EPSG:" + epsg, resp.results[0].proj4);
                        (0, logger_1.debug)("Registered projection EPSG:" + epsg + " from epsg.io");
                        return [2 /*return*/, proj4_1.default.defs["EPSG:" + epsg]];
                    }
                    else {
                        throw new error_1.MgError((0, i18n_1.tr)("INIT_ERROR_UNREGISTERED_EPSG_CODE", locale, { epsg: epsg, mapDefinition: mapDef }));
                    }
                    return [2 /*return*/];
            }
        });
    });
}
exports.resolveProjectionFromEpsgIoAsync = resolveProjectionFromEpsgIoAsync;
/**
 * Ensures the given projection (by EPSG code) exists and if not invokes the given factory function (or does an epsg.io lookup)
 * to fetch the definition to be registered.
 *
 * Once registered, it will update the projection set within OpenLayers
 *
 * @export
 * @param {number} epsgCode
 * @param {() => Promise<string>} [factoryIfNotFound] A custom factory function to provide the required proj4js string for this projection. If not specified, a lookup to epsg.io will be done instead
 * @param {string} alias
 * @returns {Promise<string>}
 * @since 0.13
 */
function ensureProjection(epsgCode, locale, alias, factoryIfNotFound) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var resolvedName, bAdded, name;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    bAdded = false;
                    name = "EPSG:" + epsgCode;
                    if (!proj4_1.default.defs[name]) return [3 /*break*/, 1];
                    resolvedName = name;
                    return [3 /*break*/, 4];
                case 1:
                    if (!factoryIfNotFound) return [3 /*break*/, 2];
                    proj4_1.default.defs[name] = factoryIfNotFound();
                    bAdded = true;
                    resolvedName = name;
                    return [3 /*break*/, 4];
                case 2: return [4 /*yield*/, resolveProjectionFromEpsgIoAsync(epsgCode, locale, "")];
                case 3:
                    _a.sent();
                    resolvedName = name;
                    _a.label = 4;
                case 4:
                    //Register the alias if specified
                    if (!(0, string_1.strIsNullOrEmpty)(alias) && !proj4_1.default.defs[alias]) {
                        proj4_1.default.defs[alias] = proj4_1.default.defs[resolvedName];
                        bAdded = true;
                    }
                    //Need to call re-register if proj4.defs got changed so OL can pick it up
                    if (bAdded) {
                        (0, proj4_2.register)(proj4_1.default);
                    }
                    return [2 /*return*/, [epsgCode, resolvedName]];
            }
        });
    });
}
exports.ensureProjection = ensureProjection;


/***/ }),

/***/ "./src/api/request-builder.ts":
/*!************************************!*\
  !*** ./src/api/request-builder.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequestBuilder = exports.QueryFeaturesSet = exports.RuntimeMapFeatureFlags = void 0;
/**
 * Bitmask describing what data to return when creating a runtime map
 *
 * @export
 * @enum {number}
 */
var RuntimeMapFeatureFlags;
(function (RuntimeMapFeatureFlags) {
    /**
     * Include data about layers and groups
     */
    RuntimeMapFeatureFlags[RuntimeMapFeatureFlags["LayersAndGroups"] = 1] = "LayersAndGroups";
    /**
     * Include layer icons
     */
    RuntimeMapFeatureFlags[RuntimeMapFeatureFlags["LayerIcons"] = 2] = "LayerIcons";
    /**
     * Include data about layer feature sources
     */
    RuntimeMapFeatureFlags[RuntimeMapFeatureFlags["LayerFeatureSources"] = 4] = "LayerFeatureSources";
})(RuntimeMapFeatureFlags = exports.RuntimeMapFeatureFlags || (exports.RuntimeMapFeatureFlags = {}));
/**
 * A bitmask indicating what to return when querying map features
 *
 * @export
 * @enum {number}
 */
var QueryFeaturesSet;
(function (QueryFeaturesSet) {
    /**
     * Include attributes of selected features
     */
    QueryFeaturesSet[QueryFeaturesSet["Attributes"] = 1] = "Attributes";
    /**
     * Include an inline image of the selected features
     */
    QueryFeaturesSet[QueryFeaturesSet["InlineSelection"] = 2] = "InlineSelection";
    /**
     * Include tooltips for the first matching feature
     */
    QueryFeaturesSet[QueryFeaturesSet["Tooltip"] = 4] = "Tooltip";
    /**
     * Include hyperlink for the first matching feature
     */
    QueryFeaturesSet[QueryFeaturesSet["Hyperlink"] = 8] = "Hyperlink";
})(QueryFeaturesSet = exports.QueryFeaturesSet || (exports.QueryFeaturesSet = {}));
/**
 * An abstract MapGuide service client
 *
 * @export
 * @abstract
 * @class RequestBuilder
 * @implements {IMapGuideClient}
 */
var RequestBuilder = /** @class */ (function () {
    function RequestBuilder(agentUri) {
        this.agentUri = agentUri;
    }
    return RequestBuilder;
}());
exports.RequestBuilder = RequestBuilder;


/***/ }),

/***/ "./src/api/runtime.ts":
/*!****************************!*\
  !*** ./src/api/runtime.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getViewer = exports.isReady = exports.setViewer = exports.getFusionRoot = exports.setFusionRoot = void 0;
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
var _fusionRoot;
var _viewer;
/**
 * Sets the Fusion base URL
 *
 * @export
 * @param {string} root
 */
function setFusionRoot(root) {
    _fusionRoot = root;
    (0, logger_1.debug)("Fusion root set to: " + root + ". Access to Fusion backend services and widget content will be relative to this value");
}
exports.setFusionRoot = setFusionRoot;
/**
 * Gets the Fusion base URL
 *
 * @export
 * @returns {string}
 */
function getFusionRoot() {
    return _fusionRoot || "../fusion";
}
exports.getFusionRoot = getFusionRoot;
/**
 * Sets the viewer instance. Called by the map viewer component when it has mounted.
 *
 * DO NOT CALL DIRECTLY
 *
 * @hidden
 * @param {IMapViewer} viewer
 */
function setViewer(viewer) {
    _viewer = viewer;
}
exports.setViewer = setViewer;
/**
 * Gets whether the runtime environment is ready
 *
 * @export
 * @returns {boolean}
 */
function isReady() {
    return _viewer != null;
}
exports.isReady = isReady;
/**
 * Gets the map viewer in this runtime environment
 *
 * @export
 * @returns {IMapViewer}
 * @deprecated You should be using the map provider context accessed via the {@link useMapProviderContext} hook where possible
 */
function getViewer() {
    return _viewer;
}
exports.getViewer = getViewer;


/***/ }),

/***/ "./src/api/selection-count.ts":
/*!************************************!*\
  !*** ./src/api/selection-count.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.countSelection = void 0;
function isSelectedFeatureSet(ss) {
    return ss.SelectedLayer;
}
function countSelection(mgSelection, clientSelection) {
    var _a, _b, _c, _d, _e, _f, _g;
    var summary = { total: 0, layerCount: 0 };
    if (mgSelection) {
        if (isSelectedFeatureSet(mgSelection)) {
            summary.layerCount = mgSelection.SelectedLayer.length;
            for (var _i = 0, _h = mgSelection.SelectedLayer; _i < _h.length; _i++) {
                var lyr = _h[_i];
                summary.total += (_b = (_a = lyr.Feature) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
            }
        }
        else {
            summary.layerCount = mgSelection.Layer.length;
            for (var _j = 0, _k = mgSelection.Layer; _j < _k.length; _j++) {
                var lyr = _k[_j];
                summary.total += (_e = (_d = (_c = lyr.Class) === null || _c === void 0 ? void 0 : _c.ID) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0;
            }
        }
    }
    if (clientSelection) {
        summary.layerCount = clientSelection.layers.length;
        for (var _l = 0, _m = clientSelection.layers; _l < _m.length; _l++) {
            var lyr = _m[_l];
            summary.total += (_g = (_f = lyr.features) === null || _f === void 0 ? void 0 : _f.length) !== null && _g !== void 0 ? _g : 0;
        }
    }
    if (summary.total == 0 && summary.layerCount == 0) {
        return undefined;
    }
    return summary;
}
exports.countSelection = countSelection;


/***/ }),

/***/ "./src/api/session-store.ts":
/*!**********************************!*\
  !*** ./src/api/session-store.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.retrieveSelectionSetFromLocalStorage = exports.persistSelectionSetToLocalStorage = exports.clearSessionStore = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var string_1 = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");
/**
 * session-store.ts
 *
 * A thin-wrapper layer over local storage for storing any data related to viewer sessions
 */
/**
 * @since 0.12
 */
function clearSessionStore() {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var key;
        return (0, tslib_1.__generator)(this, function (_a) {
            try {
                for (key in window.localStorage) {
                    if ((0, string_1.strStartsWith)(key, "selection_")) {
                        window.localStorage.removeItem(key);
                    }
                }
            }
            catch (e) {
            }
            return [2 /*return*/];
        });
    });
}
exports.clearSessionStore = clearSessionStore;
function encodeKey(sessionId, mapName) {
    return "selection_" + sessionId + "_" + mapName;
}
function persistSelectionSetToLocalStorage(sessionId, mapName, resp) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var key, value;
        return (0, tslib_1.__generator)(this, function (_a) {
            key = encodeKey(sessionId, mapName);
            value = JSON.stringify(resp);
            try {
                window.localStorage.setItem(key, value);
            }
            catch (e) {
            }
            return [2 /*return*/];
        });
    });
}
exports.persistSelectionSetToLocalStorage = persistSelectionSetToLocalStorage;
function retrieveSelectionSetFromLocalStorage(sessionId, mapName) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var key, _a, content;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = encodeKey;
                    return [4 /*yield*/, sessionId.getValueAsync()];
                case 1:
                    key = _a.apply(void 0, [_b.sent(), mapName]);
                    content = window.localStorage.getItem(key);
                    if (content) {
                        return [2 /*return*/, JSON.parse(content)];
                    }
                    return [2 /*return*/];
            }
        });
    });
}
exports.retrieveSelectionSetFromLocalStorage = retrieveSelectionSetFromLocalStorage;


/***/ }),

/***/ "./src/components/about.tsx":
/*!**********************************!*\
  !*** ./src/components/about.tsx ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.About = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
/**
 * The About component displays information about this viewer
 * @param props
 */
var About = function (props) {
    return React.createElement("div", { className: "component-about-dialog-content" },
        React.createElement("h4", null, "mapguide-react-layout"),
        React.createElement("hr", null),
        React.createElement("p", null,
            "Hash: ",
            "9ba843ebe95dcf3ac9771d7556189003a442ca9b"),
        React.createElement("hr", null),
        React.createElement("p", null,
            React.createElement("a", { target: "_blank", href: "https://github.com/jumpinjackie/mapguide-react-layout" }, "GitHub")),
        React.createElement("p", null,
            React.createElement("a", { target: "_blank", href: "https://github.com/jumpinjackie/mapguide-react-layout/issues" }, "Issues")),
        React.createElement("p", null,
            "Uses icons from the ",
            React.createElement("a", { target: "_blank", href: "http://p.yusukekamiyamane.com/" }, "Fugue icon set by Yusuke Kamiyamane")));
};
exports.About = About;


/***/ }),

/***/ "./src/components/accordion.tsx":
/*!**************************************!*\
  !*** ./src/components/accordion.tsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Accordion = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var PANEL_HEADER_HEIGHT = 24;
function validatePanelId(panels, id) {
    if (!id) {
        return null;
    }
    var panel = panels.filter(function (p) { return p.id == id; })[0];
    if (panel) {
        return id;
    }
    return null;
}
/**
 * A generic, reusable Accordion component
 * @param props
 */
var Accordion = function (props) {
    var style = props.style, panels = props.panels, isResizing = props.isResizing, onActivePanelChanged = props.onActivePanelChanged;
    var activeId = validatePanelId(props.panels, props.activePanelId);
    var _a = React.useState({
        width: -1,
        height: -1
    }), dim = _a[0], setDim = _a[1];
    var _b = React.useState(activeId || panels[panels.length - 1].id), openPanel = _b[0], setOpenPanel = _b[1];
    React.useEffect(function () {
        setOpenPanel(activeId || panels[panels.length - 1].id);
    }, [activeId]);
    var onResize = function (entries) {
        setDim(entries[0].contentRect);
    };
    var onTogglePanel = function (e) {
        var id = e.currentTarget.attributes["data-accordion-panel-id"].value;
        if (openPanel != id) {
            setOpenPanel(id);
            onActivePanelChanged === null || onActivePanelChanged === void 0 ? void 0 : onActivePanelChanged(id);
        }
    };
    return React.createElement(core_1.ResizeSensor, { onResize: onResize },
        React.createElement("div", { style: style, className: "component-accordion" }, panels.map(function (p) {
            var isOpen = (p.id == openPanel);
            return React.createElement("div", { key: p.id, className: "component-accordion-panel" },
                React.createElement("div", { className: "component-accordion-panel-header", style: { height: PANEL_HEADER_HEIGHT }, "data-accordion-panel-id": p.id, onClick: onTogglePanel },
                    React.createElement(core_1.Icon, { icon: isOpen ? "chevron-up" : "chevron-down" }),
                    " ",
                    p.title),
                React.createElement(core_1.Collapse, { isOpen: isOpen }, p.contentRenderer({ width: dim.width, height: (dim.height - (panels.length * PANEL_HEADER_HEIGHT)) }, isResizing)));
        })));
};
exports.Accordion = Accordion;


/***/ }),

/***/ "./src/components/base-layer-switcher.tsx":
/*!************************************************!*\
  !*** ./src/components/base-layer-switcher.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseLayerSwitcher = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var string_1 = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
/**
 * The BaseLayerSwitcher component provides a user interface for switching the active external
 * base layer of the current map
 * @param props
 */
var BaseLayerSwitcher = function (props) {
    var locale = props.locale, externalBaseLayers = props.externalBaseLayers;
    var visLayers = externalBaseLayers.filter(function (layer) { return layer.visible === true; });
    var _a = React.useState(visLayers.length == 1 ? visLayers[0].name : string_1.STR_EMPTY), selected = _a[0], setSelected = _a[1];
    var onBaseLayerChanged = function (e) {
        var _a;
        var value = e.currentTarget.value;
        setSelected(value);
        (_a = props.onBaseLayerChanged) === null || _a === void 0 ? void 0 : _a.call(props, value);
    };
    React.useEffect(function () {
        setSelected(visLayers.length == 1 ? visLayers[0].name : string_1.STR_EMPTY);
    }, [visLayers]);
    return React.createElement("div", null,
        React.createElement("div", { className: "base-layer-switcher-item-container" },
            React.createElement("label", { className: "bp3-control bp3-radio" },
                React.createElement("input", { className: "base-layer-switcher-option", type: "radio", value: string_1.STR_EMPTY, checked: (0, string_1.strIsNullOrEmpty)(selected), onChange: onBaseLayerChanged }),
                React.createElement("span", { className: "bp3-control-indicator" }),
                (0, i18n_1.tr)("NONE", locale))),
        externalBaseLayers.map(function (layer) {
            return React.createElement("div", { className: "base-layer-switcher-item-container", key: "base-layer-" + layer.name },
                React.createElement("label", { className: "bp3-control bp3-radio" },
                    React.createElement("input", { className: "base-layer-switcher-option", type: "radio", value: layer.name, checked: layer.name === selected, onChange: onBaseLayerChanged }),
                    React.createElement("span", { className: "bp3-control-indicator" }),
                    layer.name));
        }));
};
exports.BaseLayerSwitcher = BaseLayerSwitcher;


/***/ }),

/***/ "./src/components/color-picker.tsx":
/*!*****************************************!*\
  !*** ./src/components/color-picker.tsx ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorPicker = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
var ol_style_contracts_1 = __webpack_require__(/*! ../api/ol-style-contracts */ "./src/api/ol-style-contracts.ts");
var react_colorful_1 = __webpack_require__(/*! react-colorful */ "./node_modules/react-colorful/dist/index.module.js");
/**
 * A basic color picker component
 *
 * @since 0.13
 */
var ColorPicker = function (props) {
    var _a, _b;
    var _c = React.useState(false), isPickerOpen = _c[0], setIsPickerOpen = _c[1];
    var onPickerToggle = function () {
        setIsPickerOpen(!isPickerOpen);
    };
    return React.createElement("div", null,
        React.createElement("button", { disabled: props.disabled, style: { width: 80, borderRadius: 3, backgroundColor: (_a = props.value) !== null && _a !== void 0 ? _a : ol_style_contracts_1.DEFAULT_COLOR }, onClick: onPickerToggle },
            constants_1.NBSP,
            constants_1.NBSP,
            constants_1.NBSP),
        React.createElement(core_1.Collapse, { isOpen: isPickerOpen },
            React.createElement(core_1.Card, null,
                React.createElement(react_colorful_1.HexColorPicker, { style: { width: "100%" }, color: (_b = props.value) !== null && _b !== void 0 ? _b : ol_style_contracts_1.DEFAULT_COLOR, onChange: function (c) { return props.onChange(c); } }),
                React.createElement(core_1.Button, { icon: "chevron-up", intent: core_1.Intent.PRIMARY, onClick: function () { return setIsPickerOpen(false); } }, (0, i18n_1.tr)("ACTION_CLOSE", props.locale)))));
};
exports.ColorPicker = ColorPicker;


/***/ }),

/***/ "./src/components/context.ts":
/*!***********************************!*\
  !*** ./src/components/context.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ToolbarContext = exports.LegendContext = exports.AppContext = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/**
 * context.ts
 *
 * This module holds various React component contexts and validation maps
 */
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var string_1 = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");
var VOID_NOOP = function () { };
exports.AppContext = React.createContext({
    allowHtmlValuesInSelection: function () { return false; },
    getHTMLCleaner: function () { return function (v) { return v; }; }
});
exports.LegendContext = React.createContext({
    stateless: false,
    getMapName: function () { return undefined; },
    isFiltering: function () { return false; },
    getFilterText: function () { return string_1.STR_EMPTY; },
    getLocale: function () { return i18n_1.DEFAULT_LOCALE; },
    getBaseIconSize: function () { return 0; },
    getIconMimeType: function () { return string_1.STR_EMPTY; },
    getChildren: function () { return []; },
    getCurrentScale: function () { return -1; },
    getTree: VOID_NOOP,
    getLayerVisibility: function () { return false; },
    getGroupVisibility: function () { return false; },
    setGroupVisibility: VOID_NOOP,
    setLayerVisibility: VOID_NOOP,
    getLayerSelectability: function () { return false; },
    setLayerSelectability: function () { return false; },
    getGroupExpanded: function () { return false; },
    setGroupExpanded: VOID_NOOP,
    getLayerExpanded: function () { return false; },
    setLayerExpanded: VOID_NOOP,
});
exports.ToolbarContext = React.createContext({
    openFlyout: VOID_NOOP,
    closeFlyout: VOID_NOOP,
    openComponent: VOID_NOOP,
    closeComponent: VOID_NOOP
});


/***/ }),

/***/ "./src/components/error.tsx":
/*!**********************************!*\
  !*** ./src/components/error.tsx ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Error = exports.normalizeStack = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var type_guards_1 = __webpack_require__(/*! ../utils/type-guards */ "./src/utils/type-guards.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
/**
 * Returns a normalized stack trace for the given error object
 *
 * @export
 * @param {(Error|InitError)} err
 * @returns {string[]}
 */
function normalizeStack(err) {
    var stack;
    if (err.stack instanceof Array) {
        stack = err.stack || [];
    }
    else if (typeof (err.stack) == 'string') {
        stack = (err.stack || "").split("\n");
    }
    else {
        stack = [];
    }
    return stack;
}
exports.normalizeStack = normalizeStack;
/**
 * The Error component displays an error object in a nicely formatted manner
 * @param props
 */
var Error = function (props) {
    var err = props.error;
    if ((0, type_guards_1.isError)(err) || (0, type_guards_1.isInitError)(err)) {
        if (props.errorRenderer) {
            return props.errorRenderer(err);
        }
        else {
            var message = err.message;
            var stack = normalizeStack(err);
            return React.createElement(core_1.Callout, { intent: core_1.Intent.DANGER, icon: "error" },
                React.createElement("h5", { className: "error-header" }, err.message),
                React.createElement("ul", { className: "error-stack" }, stack.map(function (ln, i) { return React.createElement("li", { key: "stack-line-" + i }, ln); })));
        }
    }
    else {
        return React.createElement(core_1.Callout, { intent: core_1.Intent.DANGER, icon: "error" },
            React.createElement("h5", { className: "error-header" }, err));
    }
};
exports.Error = Error;


/***/ }),

/***/ "./src/components/external-layer-factory.ts":
/*!**************************************************!*\
  !*** ./src/components/external-layer-factory.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createExternalSource = exports.createOLLayerFromSubjectDefn = exports.clusterSourceIfRequired = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var error_1 = __webpack_require__(/*! ../api/error */ "./src/api/error.ts");
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var defs_1 = __webpack_require__(/*! ../actions/defs */ "./src/actions/defs.ts");
var XYZ_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/XYZ */ "./node_modules/ol/source/XYZ.js"));
var OSM_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/OSM */ "./node_modules/ol/source/OSM.js"));
var TileDebug_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/TileDebug */ "./node_modules/ol/source/TileDebug.js"));
var Stamen_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/Stamen */ "./node_modules/ol/source/Stamen.js"));
var BingMaps_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/BingMaps */ "./node_modules/ol/source/BingMaps.js"));
var UTFGrid_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/UTFGrid */ "./node_modules/ol/source/UTFGrid.js"));
var Tile_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Tile */ "./node_modules/ol/layer/Tile.js"));
var TileWMS_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/TileWMS */ "./node_modules/ol/source/TileWMS.js"));
var Vector_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Vector */ "./node_modules/ol/layer/Vector.js"));
var Vector_2 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/Vector */ "./node_modules/ol/source/Vector.js"));
var Cluster_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/Cluster */ "./node_modules/ol/source/Cluster.js"));
var VectorTile_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/VectorTile */ "./node_modules/ol/source/VectorTile.js"));
var VectorTile_2 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/VectorTile */ "./node_modules/ol/layer/VectorTile.js"));
var csv_driver_1 = __webpack_require__(/*! ../api/layer-manager/csv-driver */ "./src/api/layer-manager/csv-driver.ts");
var KML_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/format/KML */ "./node_modules/ol/format/KML.js"));
var GeoJSON_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/format/GeoJSON */ "./node_modules/ol/format/GeoJSON.js"));
var MVT_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/format/MVT */ "./node_modules/ol/format/MVT.js"));
var external_layer_1 = __webpack_require__(/*! ../api/registry/external-layer */ "./src/api/registry/external-layer.ts");
var string_1 = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");
var GeometryType_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/GeometryType */ "./node_modules/ol/geom/GeometryType.js"));
var ol_style_helpers_1 = __webpack_require__(/*! ../api/ol-style-helpers */ "./src/api/ol-style-helpers.ts");
var ol_style_contracts_1 = __webpack_require__(/*! ../api/ol-style-contracts */ "./src/api/ol-style-contracts.ts");
var Feature_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/Feature */ "./node_modules/ol/Feature.js"));
var geojson_vt_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! geojson-vt */ "./node_modules/geojson-vt/src/index.js"));
var Projection_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/proj/Projection */ "./node_modules/ol/proj/Projection.js"));
var proj_1 = __webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js");
var lazy_1 = __webpack_require__(/*! ../api/lazy */ "./src/api/lazy.ts");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
var Image_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Image */ "./node_modules/ol/layer/Image.js"));
var ImageStatic_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/ImageStatic */ "./node_modules/ol/source/ImageStatic.js"));
function sameProjectionAs(proj1, proj2) {
    var nproj1 = (0, proj_1.get)(proj1);
    var nproj2 = (0, proj_1.get)(proj2);
    return (0, proj_1.equivalent)(nproj1, nproj2);
}
// Converts geojson-vt data to GeoJSON
var geoJsonVt2GeoJSON = function (key, value) {
    if (value.geometry) {
        var type = void 0;
        var rawType = value.type;
        var geometry = value.geometry;
        if (rawType === 1) {
            type = 'MultiPoint';
            if (geometry.length == 1) {
                type = 'Point';
                geometry = geometry[0];
            }
        }
        else if (rawType === 2) {
            type = 'MultiLineString';
            if (geometry.length == 1) {
                type = 'LineString';
                geometry = geometry[0];
            }
        }
        else if (rawType === 3) {
            type = 'Polygon';
            if (geometry.length > 1) {
                type = 'MultiPolygon';
                geometry = [geometry];
            }
        }
        return {
            'type': 'Feature',
            'geometry': {
                'type': type,
                'coordinates': geometry,
            },
            'properties': value.tags,
        };
    }
    else {
        return value;
    }
};
function applyVectorLayerProperties(defn, layer, isExternal) {
    layer.set(common_1.LayerProperty.LAYER_NAME, defn.name);
    layer.set(common_1.LayerProperty.LAYER_DESCRIPTION, defn.description);
    layer.set(common_1.LayerProperty.LAYER_DISPLAY_NAME, defn.displayName);
    layer.set(common_1.LayerProperty.LAYER_TYPE, defn.type);
    layer.set(common_1.LayerProperty.IS_SELECTABLE, defn.selectable);
    layer.set(common_1.LayerProperty.IS_EXTERNAL, isExternal);
    layer.set(common_1.LayerProperty.SELECTED_POPUP_CONFIGURATION, defn.popupTemplate);
    layer.set(common_1.LayerProperty.IS_GROUP, false);
    layer.set(common_1.LayerProperty.LAYER_METADATA, defn.meta);
    layer.set(common_1.LayerProperty.LAYER_DEFN, defn);
    layer.setVisible(defn.initiallyVisible);
}
var EMPTY_GEOJSON = { type: "FeatureCollection", features: [] };
function clusterSourceIfRequired(source, def) {
    if (def.cluster) {
        var cluster = new Cluster_1.default({
            source: source,
            distance: def.cluster.distance,
            geometryFunction: function (feature) {
                var geometry = feature.getGeometry();
                if (geometry && geometry.getType() == GeometryType_1.default.POINT) {
                    return geometry;
                }
                return undefined;
            }
        });
        return cluster;
    }
    return source;
}
exports.clusterSourceIfRequired = clusterSourceIfRequired;
function createOLLayerFromSubjectDefn(defn, mapProjection, isExternal, appSettings) {
    var _this = this;
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    switch (defn.type) {
        case defs_1.GenericSubjectLayerType.StaticImage:
            {
                var sourceArgs = (0, tslib_1.__assign)({ crossOrigin: "anonymous" }, defn.sourceParams);
                if (!sourceArgs.imageExtent)
                    sourceArgs.imageExtent = (_a = defn.meta) === null || _a === void 0 ? void 0 : _a.extents;
                var layer = new Image_1.default({
                    source: new ImageStatic_1.default(sourceArgs)
                });
                layer.set(common_1.LayerProperty.LAYER_DESCRIPTION, defn.description);
                layer.set(common_1.LayerProperty.LAYER_TYPE, "StaticImage");
                layer.set(common_1.LayerProperty.IS_SELECTABLE, false);
                layer.set(common_1.LayerProperty.IS_EXTERNAL, isExternal);
                layer.set(common_1.LayerProperty.IS_GROUP, false);
                layer.set(common_1.LayerProperty.LAYER_METADATA, defn.meta);
                layer.set(common_1.LayerProperty.LAYER_DEFN, defn);
                layer.setVisible(defn.initiallyVisible);
                return layer;
            }
        case defs_1.GenericSubjectLayerType.XYZ:
            {
                var sourceArgs = (0, tslib_1.__assign)({ crossOrigin: "anonymous" }, defn.sourceParams);
                var layer = new Tile_1.default({
                    source: new XYZ_1.default(sourceArgs)
                });
                layer.set(common_1.LayerProperty.LAYER_DESCRIPTION, defn.description);
                layer.set(common_1.LayerProperty.LAYER_TYPE, "XYZ");
                layer.set(common_1.LayerProperty.IS_SELECTABLE, false);
                layer.set(common_1.LayerProperty.IS_EXTERNAL, isExternal);
                layer.set(common_1.LayerProperty.IS_GROUP, false);
                layer.set(common_1.LayerProperty.LAYER_METADATA, defn.meta);
                layer.set(common_1.LayerProperty.LAYER_DEFN, defn);
                layer.setVisible(defn.initiallyVisible);
                return layer;
            }
        case defs_1.GenericSubjectLayerType.GeoJSON_Inline:
            {
                var features = (new GeoJSON_1.default()).readFeatures((_b = defn.sourceParams.features) !== null && _b !== void 0 ? _b : EMPTY_GEOJSON);
                var source = new Vector_2.default({
                    features: features,
                    attributions: defn.sourceParams.attributions
                });
                var layer = new Vector_1.default((0, tslib_1.__assign)((0, tslib_1.__assign)({}, defn.layerOptions), { source: clusterSourceIfRequired(source, defn) }));
                (0, ol_style_helpers_1.setOLVectorLayerStyle)(layer, (_c = defn.vectorStyle) !== null && _c !== void 0 ? _c : ol_style_contracts_1.DEFAULT_VECTOR_LAYER_STYLE, defn.cluster);
                applyVectorLayerProperties(defn, layer, isExternal);
                return layer;
            }
        case defs_1.GenericSubjectLayerType.GeoJSON:
            {
                var isWebM = sameProjectionAs(mapProjection, "EPSG:3857");
                var asVT = ((_d = defn.meta) === null || _d === void 0 ? void 0 : _d.geojson_as_vt) == true;
                if (asVT && isWebM) {
                    var lazyTileIndex_1 = new lazy_1.AsyncLazy(function () { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                        var resp, json, gj, features, tileIndex;
                        var _a, _b;
                        return (0, tslib_1.__generator)(this, function (_c) {
                            switch (_c.label) {
                                case 0:
                                    (0, logger_1.debug)("Fetching url: " + defn.sourceParams.url);
                                    return [4 /*yield*/, fetch(defn.sourceParams.url)];
                                case 1:
                                    resp = _c.sent();
                                    return [4 /*yield*/, resp.json()];
                                case 2:
                                    json = _c.sent();
                                    if (((_a = defn.meta) === null || _a === void 0 ? void 0 : _a.projection) != "EPSG:4326") {
                                        gj = new GeoJSON_1.default({
                                            dataProjection: (_b = defn.meta) === null || _b === void 0 ? void 0 : _b.projection,
                                            featureProjection: "EPSG:4326"
                                        });
                                        features = gj.readFeatures(json);
                                        json = gj.writeFeaturesObject(features, {
                                            dataProjection: "EPSG:4326"
                                        });
                                    }
                                    tileIndex = (0, geojson_vt_1.default)(json, {
                                        extent: 4096
                                    });
                                    return [2 /*return*/, tileIndex];
                            }
                        });
                    }); });
                    var format_1 = new GeoJSON_1.default({
                        // Data returned from geojson-vt is in tile pixel units
                        dataProjection: new Projection_1.default({
                            code: 'TILE_PIXELS',
                            units: 'tile-pixels',
                            extent: [0, 0, 4096, 4096],
                        }),
                    });
                    var vectorSource_1 = new VectorTile_1.default({
                        projection: mapProjection,
                        tileUrlFunction: function (tileCoord) {
                            // Use the tile coordinate as a pseudo URL for caching purposes
                            return JSON.stringify(tileCoord);
                        },
                        tileLoadFunction: function (tile, url) {
                            var tileCoord = JSON.parse(url);
                            lazyTileIndex_1.getValueAsync().then(function (tileIndex) {
                                var data = tileIndex.getTile(tileCoord[0], tileCoord[1], tileCoord[2]);
                                //console.log("Fetching tile", tileCoord, data);
                                var geojson = JSON.stringify({
                                    type: 'FeatureCollection',
                                    features: data ? data.features : [],
                                }, geoJsonVt2GeoJSON);
                                var features = format_1.readFeatures(geojson, {
                                    extent: vectorSource_1.getTileGrid().getTileCoordExtent(tileCoord),
                                    featureProjection: mapProjection,
                                });
                                tile.setFeatures(features);
                            });
                        }
                    });
                    var vectorLayer = new VectorTile_2.default({
                        source: vectorSource_1,
                    });
                    (0, ol_style_helpers_1.setOLVectorLayerStyle)(vectorLayer, (_e = defn.vectorStyle) !== null && _e !== void 0 ? _e : ol_style_contracts_1.DEFAULT_VECTOR_LAYER_STYLE, defn.cluster);
                    applyVectorLayerProperties(defn, vectorLayer, isExternal);
                    return vectorLayer;
                }
                else {
                    if (asVT) {
                        console.warn("The geojson_as_vt meta option only applies if the MapGuide map or Primary Subject Layer is in EPSG:3857. This layer will be loaded as a regular GeoJSON layer");
                    }
                    var source = new Vector_2.default({
                        url: defn.sourceParams.url,
                        format: new GeoJSON_1.default(),
                        attributions: defn.sourceParams.attributions
                    });
                    var layer = new Vector_1.default((0, tslib_1.__assign)((0, tslib_1.__assign)({}, defn.layerOptions), { source: clusterSourceIfRequired(source, defn) }));
                    (0, ol_style_helpers_1.setOLVectorLayerStyle)(layer, (_f = defn.vectorStyle) !== null && _f !== void 0 ? _f : ol_style_contracts_1.DEFAULT_VECTOR_LAYER_STYLE, defn.cluster);
                    applyVectorLayerProperties(defn, layer, isExternal);
                    return layer;
                }
            }
        case defs_1.GenericSubjectLayerType.MVT:
            {
                var mo = {
                    idProperty: defn.sourceParams.mvtIdProperty
                };
                switch (defn.sourceParams.mvtFeatureClass) {
                    case "feature":
                        mo.featureClass = Feature_1.default;
                        break;
                }
                var source = new VectorTile_1.default({
                    url: defn.sourceParams.url,
                    format: new MVT_1.default(mo),
                    attributions: defn.sourceParams.attributions,
                    tileLoadFunction: function (tile, url) {
                        tile.setLoader(function (extent, resolution, projection) {
                            fetch(url).then(function (response) {
                                if (response.status == 200) {
                                    response.arrayBuffer().then(function (data) {
                                        var format = tile.getFormat(); // ol/format/MVT configured as source format
                                        var features = format.readFeatures(data, {
                                            extent: extent,
                                            featureProjection: projection
                                        }).filter(function (f) { return f != null; });
                                        tile.setFeatures(features); //Bug: Typing for setFeatures() should be accepting FeatureLike[]
                                    });
                                }
                            });
                        });
                    }
                });
                var layer = new VectorTile_2.default((0, tslib_1.__assign)((0, tslib_1.__assign)({}, defn.layerOptions), { source: source }));
                (0, ol_style_helpers_1.setOLVectorLayerStyle)(layer, (_g = defn.vectorStyle) !== null && _g !== void 0 ? _g : ol_style_contracts_1.DEFAULT_VECTOR_LAYER_STYLE, defn.cluster);
                applyVectorLayerProperties(defn, layer, isExternal);
                return layer;
            }
        case defs_1.GenericSubjectLayerType.CSV:
            {
                var vectorSource_2 = new Vector_2.default({
                    loader: function (_extent, _resolution, projection) {
                        var xhr = new XMLHttpRequest();
                        xhr.open("GET", defn.sourceParams.url);
                        var onError = function () { return vectorSource_2.clear(); };
                        xhr.onerror = onError;
                        xhr.onload = function () {
                            if (xhr.status == 200) {
                                var driver = new csv_driver_1.CsvFormatDriver(csv_driver_1.CSV_COLUMN_ALIASES);
                                driver.tryParse(xhr.responseText.length, xhr.responseText).then(function (pf) {
                                    var _a;
                                    pf.addTo(vectorSource_2, projection, (_a = defn.meta) === null || _a === void 0 ? void 0 : _a.projection);
                                }).catch(function (e) { return onError(); });
                            }
                            else {
                                onError();
                            }
                        };
                        xhr.send();
                    },
                    attributions: defn.sourceParams.attributions
                });
                var layer = new Vector_1.default((0, tslib_1.__assign)((0, tslib_1.__assign)({}, defn.layerOptions), { source: clusterSourceIfRequired(vectorSource_2, defn) }));
                (0, ol_style_helpers_1.setOLVectorLayerStyle)(layer, (_h = defn.vectorStyle) !== null && _h !== void 0 ? _h : ol_style_contracts_1.DEFAULT_VECTOR_LAYER_STYLE, defn.cluster);
                applyVectorLayerProperties(defn, layer, isExternal);
                return layer;
            }
        case defs_1.GenericSubjectLayerType.KML:
            {
                var source = new Vector_2.default({
                    url: defn.sourceParams.url,
                    format: new KML_1.default(),
                    attributions: defn.sourceParams.attributions
                });
                var layer = new Vector_1.default((0, tslib_1.__assign)((0, tslib_1.__assign)({}, defn.layerOptions), { source: clusterSourceIfRequired(source, defn) }));
                applyVectorLayerProperties(defn, layer, isExternal);
                return layer;
            }
        case defs_1.GenericSubjectLayerType.TileWMS:
            {
                var sourceArgs = (0, tslib_1.__assign)({ crossOrigin: "anonymous" }, defn.sourceParams);
                var layer = new Tile_1.default({
                    source: new TileWMS_1.default(sourceArgs)
                });
                layer.set(common_1.LayerProperty.LAYER_DESCRIPTION, defn.description);
                layer.set(common_1.LayerProperty.LAYER_TYPE, "WMS");
                layer.set(common_1.LayerProperty.IS_SELECTABLE, true); //Let's assume this WMS service is capable of GetFeatureInfo in GeoJSON representation
                layer.set(common_1.LayerProperty.IS_EXTERNAL, isExternal);
                layer.set(common_1.LayerProperty.IS_GROUP, false);
                layer.set(common_1.LayerProperty.SELECTED_POPUP_CONFIGURATION, defn.popupTemplate);
                layer.set(common_1.LayerProperty.LAYER_METADATA, defn.meta);
                layer.set(common_1.LayerProperty.LAYER_DEFN, defn);
                layer.setVisible(defn.initiallyVisible);
                return layer;
            }
        case defs_1.GenericSubjectLayerType.CustomVector:
            {
                if ((0, string_1.strIsNullOrEmpty)(defn.driverName)) {
                    throw new Error("Missing required driverName");
                }
                var reg = external_layer_1.ExternalLayerFactoryRegistry.getInstance();
                var factory = reg.getExternalVectorLayerCreator(defn.driverName);
                if (!factory) {
                    throw new Error("Could not resolve an approriate factory for the given driver: " + defn.driverName);
                }
                var layer = factory(defn.sourceParams, defn.meta, defn.layerOptions, appSettings);
                var source = clusterSourceIfRequired(layer.getSource(), defn);
                layer.setSource(source);
                (0, ol_style_helpers_1.setOLVectorLayerStyle)(layer, (_j = defn.vectorStyle) !== null && _j !== void 0 ? _j : ol_style_contracts_1.DEFAULT_VECTOR_LAYER_STYLE, defn.cluster);
                applyVectorLayerProperties(defn, layer, isExternal);
                return layer;
            }
        default:
            throw new Error("Unknown subject layer type: " + defn.type);
    }
}
exports.createOLLayerFromSubjectDefn = createOLLayerFromSubjectDefn;
/**
 * Creates an OpenLayers source based on the given external base layer definition
 *
 * @export
 * @param {IExternalBaseLayer} layer
 * @returns
 */
function createExternalSource(layer) {
    var sourceCtor;
    switch (layer.kind) {
        case "XYZ":
            sourceCtor = XYZ_1.default;
            break;
        case "XYZDebug":
            sourceCtor = TileDebug_1.default;
            break;
        case "OSM":
            sourceCtor = OSM_1.default;
            break;
        case "Stamen":
            sourceCtor = Stamen_1.default;
            break;
        case "BingMaps":
            sourceCtor = BingMaps_1.default;
            break;
        case "UTFGrid":
            sourceCtor = UTFGrid_1.default;
            break;
        default:
            throw new error_1.MgError("Unknown external base layer provider: " + layer.kind);
    }
    if (typeof (layer.options) != 'undefined')
        return new sourceCtor((0, tslib_1.__assign)({ crossOrigin: "Anonymous" }, layer.options));
    else
        return new sourceCtor({ crossOrigin: "Anonymous" });
}
exports.createExternalSource = createExternalSource;


/***/ }),

/***/ "./src/components/flyout-region.tsx":
/*!******************************************!*\
  !*** ./src/components/flyout-region.tsx ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlyoutRegion = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var menu_1 = __webpack_require__(/*! ./menu */ "./src/components/menu.tsx");
var component_1 = __webpack_require__(/*! ../api/registry/component */ "./src/api/registry/component.tsx");
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
/**
 * A FlyoutRegion component defines a region where flyout menus can be displayed
 *
 * @export
 * @class FlyoutRegion
 * @extends {React.Component<IFlyoutRegionProps, any>}
 */
var FlyoutRegion = function (props) {
    return React.createElement("div", null, (function () {
        var children = [];
        var _loop_1 = function (flyoutId) {
            var flyout = props.flyoutConf[flyoutId];
            var open_1 = !!flyout.open;
            if (open_1) {
                var items_1 = flyout.childItems || [];
                var containerStyle = {};
                containerStyle.zIndex = 2000; //This should be big enough to be above all possible UI elements
                if (flyout.metrics) {
                    var met = flyout.metrics;
                    if (flyoutId == constants_1.WEBLAYOUT_CONTEXTMENU) {
                        // TODO: Refine the layout positioning so that it better behaves like it did
                        // previously when the blueprint context menu worked (ie. If right-clicking near
                        // the bottom, the menu should be shown "above" the cursor)
                        containerStyle.top = met.posY - 40;
                        containerStyle.left = met.posX + 20;
                    }
                    else {
                        if (flyout.metrics.vertical === true) {
                            containerStyle.top = met.posY;
                        }
                        else {
                            containerStyle.top = met.posY + met.height;
                        }
                        if (flyoutId == constants_1.WEBLAYOUT_TASKMENU) {
                            containerStyle.right = window.innerWidth - (met.posX + met.width);
                        }
                        else {
                            containerStyle.left = met.posX;
                            if (flyout.metrics.vertical === true) {
                                containerStyle.left += met.width;
                            }
                        }
                    }
                }
                var invoked_1 = function () {
                    props.onCloseFlyout(flyoutId);
                };
                var className = "mg-flyout-menu-container";
                if (flyout.componentName) {
                    className = "mg-flyout-component-container";
                }
                children.push(React.createElement("div", { key: flyoutId, className: className, style: containerStyle },
                    (function () {
                        if (flyout.componentName) {
                            return React.createElement(component_1.PlaceholderComponent, { id: flyout.componentName, componentProps: flyout.componentProps, locale: props.locale });
                        }
                        else {
                            return React.createElement(menu_1.MenuComponent, { items: items_1, onInvoked: invoked_1 });
                        }
                    })(),
                    (function () {
                        if (flyoutId === constants_1.WEBLAYOUT_TASKMENU) {
                            //HACK: In order for this flyout to show properly over the task pane iframe
                            //when it contains embedded content (eg. An ActiveX/Flash/etc control) in IE
                            //we have to stick an iframe into this flyout
                            return React.createElement("iframe", { src: "about:blank", className: "iframe-iehack-zindex" });
                        }
                    })()));
            }
        };
        for (var flyoutId in props.flyoutConf) {
            _loop_1(flyoutId);
        }
        return children;
    })());
};
exports.FlyoutRegion = FlyoutRegion;


/***/ }),

/***/ "./src/components/form-frame-shim.tsx":
/*!********************************************!*\
  !*** ./src/components/form-frame-shim.tsx ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormFrameShim = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
/**
 * The FormFrameShim component provides a compatibility shim for the AJAX viewer form frame
 *
 * @export
 * @class FormFrameShim
 * @extends {React.Component<FormFrameShimProps, any>}
 */
var FormFrameShim = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(FormFrameShim, _super);
    function FormFrameShim(props) {
        var _this = _super.call(this, props) || this;
        _this.onFormMounted = function (form) {
            _this._form = form;
        };
        _this.state = {
            target: "",
            action: "",
            params: []
        };
        return _this;
    }
    FormFrameShim.prototype.submit = function (url, params, target) {
        var _this = this;
        //TODO: Can't convert this to functional component with hooks, until this type
        //of pattern is possible
        this.setState({
            action: url,
            params: params,
            target: target
        }, function () {
            //The form will have the updated content at this point
            _this._form.submit();
        });
    };
    FormFrameShim.prototype.render = function () {
        var _a = this.state, target = _a.target, action = _a.action, params = _a.params;
        return React.createElement("form", { style: { visibility: "hidden", width: 0, height: 0 }, ref: this.onFormMounted, method: "post", id: "Frm", target: target, action: action, encType: "application/x-www-form-urlencoded" }, (function () {
            var fields = [];
            for (var i = 0; i < params.length; i += 2) {
                fields.push(React.createElement("input", { id: "f" + i, key: "f" + i, type: "hidden", name: params[i], value: params[i + 1] }));
            }
            return fields;
        })());
    };
    return FormFrameShim;
}(React.Component));
exports.FormFrameShim = FormFrameShim;


/***/ }),

/***/ "./src/components/icon.tsx":
/*!*********************************!*\
  !*** ./src/components/icon.tsx ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImageIcon = exports.Icon = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var asset_1 = __webpack_require__(/*! ../utils/asset */ "./src/utils/asset.ts");
var assets_1 = __webpack_require__(/*! ../constants/assets */ "./src/constants/assets.ts");
var Icon = function (props) {
    var spStyle = (0, tslib_1.__assign)({}, (props.style || {}));
    if (!spStyle.display) {
        spStyle.display = "inline-block";
    }
    return React.createElement("div", (0, tslib_1.__assign)({ style: spStyle, onClick: props.onClick }, props.otherProps), props.children(props.baseSize));
};
exports.Icon = Icon;
/**
 * An image icon component
 * @param props
 * @since 0.13
 */
var ImageIcon = function (props) {
    if (!props.url && !props.spriteClass) {
        return React.createElement("noscript", null);
    }
    var url;
    var spriteClass = props.spriteClass;
    if (props.url && props.url != assets_1.STD_CSS_SPRITE_RELPATH) {
        url = (0, asset_1.getAssetPath)(props.url);
        spriteClass = undefined;
    }
    if (spriteClass) {
        var spStyle = (0, tslib_1.__assign)({}, (props.style || {}));
        if (!spStyle.display) {
            spStyle.display = "inline-block";
        }
        return React.createElement("div", (0, tslib_1.__assign)({ style: spStyle, onClick: props.onClick, className: "icon " + spriteClass }, props.otherProps));
    }
    return React.createElement("img", (0, tslib_1.__assign)({ className: "icon", style: props.style, src: url, onClick: props.onClick }, props.otherProps, { onError: function (e) { return e.currentTarget.src = assets_1.ICON_ERROR; } }));
};
exports.ImageIcon = ImageIcon;


/***/ }),

/***/ "./src/components/layer-manager/add-layer.tsx":
/*!****************************************************!*\
  !*** ./src/components/layer-manager/add-layer.tsx ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddLayer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var i18n_1 = __webpack_require__(/*! ../../api/i18n */ "./src/api/i18n.ts");
var add_wms_layer_1 = __webpack_require__(/*! ./add-wms-layer */ "./src/components/layer-manager/add-wms-layer.tsx");
var add_wfs_layer_1 = __webpack_require__(/*! ./add-wfs-layer */ "./src/components/layer-manager/add-wfs-layer.tsx");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var string_1 = __webpack_require__(/*! ../../utils/string */ "./src/utils/string.ts");
var projections_1 = __webpack_require__(/*! ../../api/registry/projections */ "./src/api/registry/projections.ts");
var wfs_capabilities_panel_1 = __webpack_require__(/*! ./wfs-capabilities-panel */ "./src/components/layer-manager/wfs-capabilities-panel.tsx");
var runtime_1 = __webpack_require__(/*! ../../api/runtime */ "./src/api/runtime.ts");
var add_manage_layers_1 = __webpack_require__(/*! ../../containers/add-manage-layers */ "./src/containers/add-manage-layers.tsx");
var color_brewer_1 = __webpack_require__(/*! ./color-brewer */ "./src/components/layer-manager/color-brewer.tsx");
var ol_style_contracts_1 = __webpack_require__(/*! ../../api/ol-style-contracts */ "./src/api/ol-style-contracts.ts");
var never_1 = __webpack_require__(/*! ../../utils/never */ "./src/utils/never.ts");
var ADD_URL_LAYER_TYPES = {
    "WMS": {
        label: "WMS",
        content: function (props) { return React.createElement(add_wms_layer_1.AddWmsLayer, (0, tslib_1.__assign)({}, props)); }
    },
    "WFS": {
        label: "WFS",
        content: function (props) { return React.createElement(add_wfs_layer_1.AddWfsLayer, (0, tslib_1.__assign)({}, props)); }
    }
};
var AddLayerKind;
(function (AddLayerKind) {
    AddLayerKind[AddLayerKind["File"] = 0] = "File";
    AddLayerKind[AddLayerKind["Url"] = 1] = "Url";
})(AddLayerKind || (AddLayerKind = {}));
var CreateVectorLayerAs;
(function (CreateVectorLayerAs) {
    CreateVectorLayerAs["Vector"] = "Vector";
    CreateVectorLayerAs["Themed"] = "Themed";
    CreateVectorLayerAs["Clustered"] = "Clustered";
    CreateVectorLayerAs["Heatmap"] = "Heatmap";
})(CreateVectorLayerAs || (CreateVectorLayerAs = {}));
function getCreateVectorLayerOptions(geomTypes, locale) {
    var options = [
        { value: CreateVectorLayerAs.Vector, label: (0, i18n_1.tr)("CREATE_VECTOR_LAYER", locale), isValid: function (geomTypes) { return true; } },
        { value: CreateVectorLayerAs.Themed, label: (0, i18n_1.tr)("CREATE_VECTOR_THEMED", locale), isValid: function (geomTypes) { return true; } },
        { value: CreateVectorLayerAs.Clustered, label: (0, i18n_1.tr)("CREATE_VECTOR_CLUSTERED", locale), isValid: function (geomTypes) { return geomTypes.length == 1 && geomTypes.includes("Point"); } },
        { value: CreateVectorLayerAs.Heatmap, label: (0, i18n_1.tr)("CREATE_VECTOR_HEATMAP", locale), isValid: function (geomTypes) { return geomTypes.length == 1 && geomTypes.includes("Point"); } }
    ];
    return options.filter(function (o) { return o.isValid(geomTypes); });
}
var AddFileLayer = function (props) {
    var locale = props.locale;
    var _a = React.useState(false), isProcessingFile = _a[0], setIsProcessingFile = _a[1];
    var _b = React.useState(false), isAddingLayer = _b[0], setIsAddingLayer = _b[1];
    var _c = React.useState(undefined), addLayerError = _c[0], setAddLayerError = _c[1];
    var _d = React.useState(undefined), loadedFile = _d[0], setLoadedFile = _d[1];
    var _e = React.useState(undefined), addLayerName = _e[0], setAddLayerName = _e[1];
    var _f = React.useState(4326), addProjection = _f[0], setAddProjection = _f[1];
    var _g = React.useState(getCreateVectorLayerOptions([], locale)), createOptions = _g[0], setCreateOptions = _g[1];
    var _h = React.useState(false), enableLabels = _h[0], setEnableLabels = _h[1];
    var _j = React.useState(undefined), labelOnProperty = _j[0], setLabelOnProperty = _j[1];
    var _k = React.useState(undefined), themeOnProperty = _k[0], setThemeOnProperty = _k[1];
    var _l = React.useState([]), themableProperties = _l[0], setThemableProperties = _l[1];
    var _m = React.useState("Blues"), themeToUse = _m[0], setThemeToUse = _m[1];
    var _o = React.useState(CreateVectorLayerAs.Vector), createLayerAs = _o[0], setCreateLayerAs = _o[1];
    var _p = React.useState(10), clusterDistance = _p[0], setClusterDistance = _p[1];
    var _q = React.useState((0, color_brewer_1.getColorBrewerRamps)()), themableRamps = _q[0], _ = _q[1];
    var _r = React.useState(ol_style_contracts_1.ClusterClickAction.ShowPopup), clusterClickAction = _r[0], setClusterClickAction = _r[1];
    var parsedFeaturesRef = React.useRef(undefined);
    var setParsedFile = function (parsed) {
        setEnableLabels(false);
        setCreateOptions(getCreateVectorLayerOptions([], locale));
        parsedFeaturesRef.current = parsed;
        if (parsed) {
            setAddLayerName(parsed.name);
            setLoadedFile({
                name: parsed.name,
                size: parsed.size,
                type: parsed.type,
                defaultProjection: parsed.projection
            });
            setCreateOptions(getCreateVectorLayerOptions(parsed.geometryTypes, locale));
            setThemableProperties(parsed.propertyNames);
            if (parsed.propertyNames.length > 0) {
                setThemeOnProperty(parsed.propertyNames[0]);
                setLabelOnProperty(parsed.propertyNames[0]);
            }
            if (parsed.projection) {
                var epsg = (0, wfs_capabilities_panel_1.parseEpsgCodeFromCRS)(parsed.projection);
                if (epsg) {
                    setAddProjection(epsg);
                }
            }
        }
        else {
            setLoadedFile(undefined);
            parsedFeaturesRef.current = undefined;
        }
    };
    var onFileDropped = function (file) { return (0, tslib_1.__awaiter)(void 0, void 0, void 0, function () {
        var viewer, layerMgr, parsed, e_1;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    viewer = (0, runtime_1.getViewer)();
                    if (!viewer) return [3 /*break*/, 5];
                    setIsProcessingFile(true);
                    setAddLayerError(undefined);
                    layerMgr = viewer.getLayerManager();
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, layerMgr.parseFeaturesFromFile({
                            file: file,
                            name: file.name,
                            locale: locale
                        })];
                case 2:
                    parsed = _a.sent();
                    setParsedFile(parsed);
                    return [3 /*break*/, 4];
                case 3:
                    e_1 = _a.sent();
                    setAddLayerError(e_1);
                    return [3 /*break*/, 4];
                case 4:
                    setIsProcessingFile(false);
                    _a.label = 5;
                case 5: return [2 /*return*/];
            }
        });
    }); };
    var onCancelAddFile = function () {
        setParsedFile(undefined);
    };
    var onAddFileLayer = React.useCallback(function (layerProjection) { return (0, tslib_1.__awaiter)(void 0, void 0, void 0, function () {
        var viewer, _a, _1, layerProj, layerMgr, extraOpts, labelProp, layer, e_2;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    viewer = (0, runtime_1.getViewer)();
                    if (!(viewer && (parsedFeaturesRef === null || parsedFeaturesRef === void 0 ? void 0 : parsedFeaturesRef.current))) return [3 /*break*/, 6];
                    setIsAddingLayer(true);
                    setAddLayerError(undefined);
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 4, , 5]);
                    return [4 /*yield*/, (0, projections_1.ensureProjection)(layerProjection, locale)];
                case 2:
                    _a = _b.sent(), _1 = _a[0], layerProj = _a[1];
                    if (!(0, string_1.strIsNullOrEmpty)(addLayerName)) {
                        parsedFeaturesRef.current.name = addLayerName;
                    }
                    layerMgr = viewer.getLayerManager();
                    if (layerMgr.hasLayer(parsedFeaturesRef.current.name)) {
                        throw new Error((0, i18n_1.tr)("LAYER_NAME_EXISTS", locale, { name: parsedFeaturesRef.current.name }));
                    }
                    extraOpts = void 0;
                    switch (createLayerAs) {
                        case CreateVectorLayerAs.Clustered:
                            extraOpts = {
                                kind: "Cluster",
                                clusterDistance: clusterDistance,
                                onClusterClickAction: clusterClickAction
                            };
                            break;
                        case CreateVectorLayerAs.Themed:
                            extraOpts = {
                                kind: "Theme",
                                themeOnProperty: themeOnProperty,
                                colorBrewerTheme: themeToUse
                            };
                            break;
                        case CreateVectorLayerAs.Heatmap:
                            extraOpts = {
                                kind: "Heatmap"
                            };
                            break;
                    }
                    labelProp = void 0;
                    if (enableLabels) {
                        labelProp = labelOnProperty;
                    }
                    return [4 /*yield*/, layerMgr.addLayerFromParsedFeatures({
                            features: parsedFeaturesRef.current,
                            projection: layerProj,
                            extraOptions: extraOpts,
                            labelOnProperty: labelProp
                        })];
                case 3:
                    layer = _b.sent();
                    (0, add_manage_layers_1.zoomToLayerExtents)(layer.name, viewer);
                    setIsAddingLayer(false);
                    viewer.toastSuccess("success", (0, i18n_1.tr)("ADDED_LAYER", props.locale, { name: layer.name }));
                    setAddLayerError(undefined);
                    setLoadedFile(undefined);
                    setAddLayerName(undefined);
                    props.onLayerAdded(layer);
                    return [3 /*break*/, 5];
                case 4:
                    e_2 = _b.sent();
                    setAddLayerError(e_2);
                    if (!(0, string_1.strIsNullOrEmpty)(e_2 === null || e_2 === void 0 ? void 0 : e_2.message)) {
                        viewer.toastError("error", e_2.message);
                    }
                    return [3 /*break*/, 5];
                case 5:
                    setIsAddingLayer(false);
                    _b.label = 6;
                case 6: return [2 /*return*/];
            }
        });
    }); }, [clusterDistance, createLayerAs, themeOnProperty, themeToUse, enableLabels, labelOnProperty, clusterClickAction]);
    if (loadedFile) {
        var canAdd = true;
        if (createLayerAs == CreateVectorLayerAs.Themed) {
            if ((0, string_1.strIsNullOrEmpty)(themeOnProperty)) {
                canAdd = false;
            }
        }
        var labelEl_1 = React.createElement(React.Fragment, null,
            React.createElement(core_1.Switch, { label: (0, i18n_1.tr)("ENABLE_LABELS", locale), checked: enableLabels, onChange: function (e) { return setEnableLabels(e.target.checked); } }),
            enableLabels && React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("LABEL_USING_PROPERTY", locale) },
                React.createElement(core_1.HTMLSelect, { value: labelOnProperty, onChange: function (e) { return setLabelOnProperty(e.target.value); } }, themableProperties.map(function (th, i) { return React.createElement("option", { key: th, value: th }, th); }))));
        var colorBrewerLabel = React.createElement("div", { dangerouslySetInnerHTML: { __html: (0, i18n_1.tr)("COLORBREWER_THEME", locale) } });
        var themeEl_1 = React.createElement(React.Fragment, null,
            React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("THEME_ON_PROPERTY", locale) },
                React.createElement(core_1.HTMLSelect, { value: themeOnProperty, onChange: function (e) { return setThemeOnProperty(e.target.value); } }, themableProperties.map(function (th, i) { return React.createElement("option", { key: th, value: th }, th); }))),
            React.createElement(core_1.FormGroup, { label: colorBrewerLabel },
                React.createElement(core_1.HTMLSelect, { value: themeToUse, onChange: function (e) { return setThemeToUse(e.target.value); } }, themableRamps.map(function (th, i) { return React.createElement("option", { key: th.displayName, value: th.scheme }, th.displayName); }))),
            themeToUse && React.createElement(color_brewer_1.ColorBrewerSwatch, { theme: themeToUse }));
        var clusterEl_1 = React.createElement(React.Fragment, null,
            React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("POINT_CLUSTER_DISTANCE", locale) },
                React.createElement(core_1.NumericInput, { min: 1, value: clusterDistance, onValueChange: function (v) { return setClusterDistance(v); } })),
            React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("CLUSTER_CLICK_ACTION", locale) },
                React.createElement(core_1.HTMLSelect, { value: clusterClickAction, onChange: function (e) { return setClusterClickAction(e.target.value); } },
                    React.createElement("option", { value: ol_style_contracts_1.ClusterClickAction.ShowPopup }, (0, i18n_1.tr)("CLUSTER_CLICK_ACTION_SHOW_POPUP", locale)),
                    React.createElement("option", { value: ol_style_contracts_1.ClusterClickAction.ZoomToClusterExtents }, (0, i18n_1.tr)("CLUSTER_CLICK_ACTION_ZOOM_EXTENTS", locale)))));
        return React.createElement(core_1.NonIdealState, { title: React.createElement(core_1.EditableText, { value: addLayerName, onChange: function (v) { return setAddLayerName(v); } }), icon: "upload", description: (0, i18n_1.tr)("FMT_UPLOADED_FILE", locale, { size: loadedFile.size, type: ((0, string_1.strIsNullOrEmpty)(loadedFile.type) ? (0, i18n_1.tr)("UNKNOWN_FILE_TYPE", locale) : loadedFile.type) }), action: React.createElement(React.Fragment, null,
                addLayerError && React.createElement(core_1.Callout, { intent: core_1.Intent.DANGER, title: (0, i18n_1.tr)("ADDING_LAYER_ERROR", locale) }, addLayerError.message),
                React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("ADD_LAYER_PROJECTION", locale) }, loadedFile.defaultProjection ? React.createElement("strong", null,
                    "EPSG:",
                    addProjection) : React.createElement(core_1.FormGroup, { label: React.createElement("a", { href: "https://epsg.io", target: "_blank" }, "EPSG:"), inline: true },
                    React.createElement(core_1.NumericInput, { style: { width: 60 }, min: 0, value: addProjection, onValueChange: function (v) { return setAddProjection(v); } }))),
                React.createElement(core_1.FormGroup, { label: "Create Layer As" },
                    React.createElement(core_1.HTMLSelect, { value: createLayerAs, onChange: function (e) { return setCreateLayerAs(e.target.value); } }, createOptions.map(function (kind, i) { return React.createElement("option", { key: kind.value, value: kind.value }, kind.label); }))),
                (function () {
                    switch (createLayerAs) {
                        case CreateVectorLayerAs.Vector:
                            return React.createElement(React.Fragment, null, labelEl_1);
                        case CreateVectorLayerAs.Themed:
                            return React.createElement(React.Fragment, null,
                                labelEl_1,
                                themeEl_1);
                        case CreateVectorLayerAs.Clustered:
                            return React.createElement(React.Fragment, null,
                                labelEl_1,
                                clusterEl_1);
                        case CreateVectorLayerAs.Heatmap:
                            return React.createElement(React.Fragment, null);
                        default:
                            (0, never_1.assertNever)(createLayerAs);
                    }
                })(),
                React.createElement(core_1.ButtonGroup, null,
                    React.createElement(core_1.Button, { disabled: !canAdd, loading: isAddingLayer, onClick: function (e) { return onAddFileLayer(addProjection); }, intent: core_1.Intent.PRIMARY }, (0, i18n_1.tr)("ADD_LAYER", locale)),
                    React.createElement(core_1.Button, { loading: isAddingLayer, onClick: function (e) { return onCancelAddFile(); }, intent: core_1.Intent.DANGER }, (0, i18n_1.tr)("CANCEL", locale)))) });
    }
    else if (isProcessingFile) {
        return React.createElement(core_1.NonIdealState, { icon: React.createElement(core_1.Spinner, { intent: core_1.Intent.NONE, size: core_1.SpinnerSize.LARGE }), title: (0, i18n_1.tr)("ADD_FILE_PROCESSING", locale) });
    }
    else {
        return React.createElement(React.Fragment, null,
            addLayerError && React.createElement(core_1.Callout, { intent: core_1.Intent.DANGER, title: (0, i18n_1.tr)("ADDING_LAYER_ERROR", locale) }, addLayerError.message),
            React.createElement(core_1.NonIdealState, { title: (0, i18n_1.tr)("ADD_FILE", locale), icon: "upload", description: (0, i18n_1.tr)("ADD_FILE_INSTRUCTIONS", locale), action: React.createElement(core_1.FileInput, { fill: true, text: (0, i18n_1.tr)("CHOOSE_FILE", locale), buttonText: (0, i18n_1.tr)("BROWSE", locale), onInputChange: function (e) { return e.target.files && onFileDropped(e.target.files[0]); } }) }));
    }
};
var AddUrlLayer = function (props) {
    var locale = props.locale;
    var _a = React.useState(undefined), selectedUrlType = _a[0], setSelectedUrlType = _a[1];
    var onUrlLayerTypeChanged = function (e) {
        setSelectedUrlType(e.target.value);
    };
    var items = Object.keys(ADD_URL_LAYER_TYPES).map(function (lt) { return ({ value: lt, label: ADD_URL_LAYER_TYPES[lt].label }); });
    return React.createElement("div", null,
        React.createElement(core_1.Label, null,
            (0, i18n_1.tr)("LAYER_TYPE", locale),
            React.createElement(core_1.HTMLSelect, { value: selectedUrlType || "", onChange: onUrlLayerTypeChanged },
                React.createElement("option", null, (0, i18n_1.tr)("SELECT_LAYER_TYPE", locale)),
                items.map(function (it) { return React.createElement("option", { key: it.value, value: it.value }, it.value); }))),
        (function () {
            if (selectedUrlType && ADD_URL_LAYER_TYPES[selectedUrlType]) {
                var cprops = {
                    locale: locale,
                    onLayerAdded: props.onLayerAdded,
                    onAddLayerBusyWorker: props.onAddLayerBusyWorker,
                    onRemoveLayerBusyWorker: props.onRemoveLayerBusyWorker
                };
                return ADD_URL_LAYER_TYPES[selectedUrlType].content(cprops);
            }
        })());
};
/**
 * @hidden
 */
var AddLayer = function (props) {
    var _a = React.useState(AddLayerKind.File), addLayerKind = _a[0], setAddLayerKind = _a[1];
    var onAddLayerKindChanged = function (e) {
        setAddLayerKind(parseInt(e.target.value, 10));
    };
    return React.createElement("div", null,
        React.createElement(core_1.RadioGroup, { label: (0, i18n_1.tr)("ADD_LAYER_KIND_PROMPT", props.locale), onChange: onAddLayerKindChanged, selectedValue: addLayerKind },
            React.createElement(core_1.Radio, { label: (0, i18n_1.tr)("LAYER_KIND_FILE", props.locale), value: AddLayerKind.File }),
            React.createElement(core_1.Radio, { label: (0, i18n_1.tr)("LAYER_KIND_URL", props.locale), value: AddLayerKind.Url })),
        React.createElement("hr", null),
        (function () {
            switch (addLayerKind) {
                case AddLayerKind.File:
                    return React.createElement(AddFileLayer, (0, tslib_1.__assign)({}, props));
                case AddLayerKind.Url:
                    return React.createElement(AddUrlLayer, (0, tslib_1.__assign)({}, props));
            }
        })());
};
exports.AddLayer = AddLayer;


/***/ }),

/***/ "./src/components/layer-manager/add-wfs-layer.tsx":
/*!********************************************************!*\
  !*** ./src/components/layer-manager/add-wfs-layer.tsx ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddWfsLayer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var common_1 = __webpack_require__(/*! ../../api/common */ "./src/api/common.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var i18n_1 = __webpack_require__(/*! ../../api/i18n */ "./src/api/i18n.ts");
var error_1 = __webpack_require__(/*! ../error */ "./src/components/error.tsx");
var client_1 = __webpack_require__(/*! ../../api/client */ "./src/api/client.ts");
var wfs_capabilities_parser_1 = __webpack_require__(/*! ./wfs-capabilities-parser */ "./src/components/layer-manager/wfs-capabilities-parser.ts");
var wfs_capabilities_panel_1 = __webpack_require__(/*! ./wfs-capabilities-panel */ "./src/components/layer-manager/wfs-capabilities-panel.tsx");
var Vector_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/Vector */ "./node_modules/ol/source/Vector.js"));
var Vector_2 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Vector */ "./node_modules/ol/layer/Vector.js"));
var GeoJSON_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/format/GeoJSON */ "./node_modules/ol/format/GeoJSON.js"));
var url_1 = __webpack_require__(/*! ../../utils/url */ "./src/utils/url.ts");
var projections_1 = __webpack_require__(/*! ../../api/registry/projections */ "./src/api/registry/projections.ts");
var layer_manager_1 = __webpack_require__(/*! ../../api/layer-manager */ "./src/api/layer-manager.ts");
var runtime_1 = __webpack_require__(/*! ../../api/runtime */ "./src/api/runtime.ts");
var ol_style_helpers_1 = __webpack_require__(/*! ../../api/ol-style-helpers */ "./src/api/ol-style-helpers.ts");
var ol_style_contracts_1 = __webpack_require__(/*! ../../api/ol-style-contracts */ "./src/api/ol-style-contracts.ts");
var add_manage_layers_1 = __webpack_require__(/*! ../../containers/add-manage-layers */ "./src/containers/add-manage-layers.tsx");
/**
 * @hidden
 */
var AddWfsLayer = function (props) {
    var locale = props.locale;
    var _a = React.useState(""), wfsUrl = _a[0], setWfsUrl = _a[1];
    var _b = React.useState(false), loadingCapabilities = _b[0], setLoadingCapabilities = _b[1];
    var _c = React.useState(undefined), caps = _c[0], setCaps = _c[1];
    var _d = React.useState(undefined), error = _d[0], setError = _d[1];
    var onAddLayer = function (name, version, format, origCrs, epsgCode, wfsWgs84Bounds) {
        var viewer = (0, runtime_1.getViewer)();
        if (caps && viewer) {
            (0, projections_1.ensureProjection)(epsgCode, locale, origCrs).then(function (_a) {
                var resolvedProj = _a[1];
                var sourceProj = viewer.getProjection();
                //TODO: For correctness, we should be using the URL from the ows:Get element of the
                //GetFeature operations metadata instead of just re-computing the WFS GetFeature URL
                //relative to the capabilities URL that was entered
                var parsed = (0, url_1.parseUrl)(wfsUrl);
                var typeNameKey = "typename";
                if (version == "2.0.0") { //WFS 2.0.0 want typename(s) over typename
                    typeNameKey = "typenames";
                }
                var urlTemplate = parsed.url + "?service=WFS&version=" + version + "&request=GetFeature&" + typeNameKey + "=" + encodeURIComponent(name) + "&outputFormat=" + encodeURIComponent(format) + "&srsName=" + encodeURIComponent(origCrs);
                var sourceUrl;
                var strategy;
                var vectorFmt = new GeoJSON_1.default({
                    dataProjection: resolvedProj,
                    featureProjection: sourceProj
                });
                // FIXME: I can't seem to get bbox strategy working in general :(
                if (false) {}
                else {
                    sourceUrl = urlTemplate;
                }
                var source = new Vector_1.default({
                    format: vectorFmt,
                    url: sourceUrl,
                    strategy: strategy /*,
                    loader: innerLoader ? (function() {
                        viewer.addImageLoading();
                        props.onAddLayerBusyWorker(name);
                        innerLoader?.apply(source, arguments);
                    }) : undefined*/
                });
                var layer = new Vector_2.default({
                    source: source,
                    className: "external-vector-layer" //This is to avoid false positives for map.forEachLayerAtPixel
                });
                layer.set(common_1.LayerProperty.LAYER_TYPE, "WFS");
                layer.set(common_1.LayerProperty.IS_EXTERNAL, true);
                layer.set(common_1.LayerProperty.IS_SELECTABLE, true);
                layer.set(common_1.LayerProperty.IS_GROUP, false);
                if (wfsWgs84Bounds) {
                    layer.set(common_1.LayerProperty.WGS84_BBOX, wfsWgs84Bounds);
                }
                (0, ol_style_helpers_1.setOLVectorLayerStyle)(layer, ol_style_contracts_1.DEFAULT_VECTOR_LAYER_STYLE, undefined);
                viewer.getLayerManager().addLayer(name, layer);
                viewer.toastSuccess("success", (0, i18n_1.tr)("ADDED_LAYER", locale, { name: name }));
                var li = (0, layer_manager_1.getLayerInfo)(layer, true);
                (0, add_manage_layers_1.zoomToLayerExtents)(li.name, viewer);
                props.onLayerAdded(li);
            });
        }
    };
    var onLoadCaps = function () {
        setCaps(undefined);
        setLoadingCapabilities(true);
        var client = new client_1.Client("", "mapagent");
        client.getText(wfsUrl).then(function (s) {
            var parser = new wfs_capabilities_parser_1.WfsCapabilitiesParser();
            var caps = parser.parse(s);
            setLoadingCapabilities(false);
            setCaps(caps);
            setError(undefined);
        }).catch(function (err) {
            setLoadingCapabilities(false);
            setCaps(undefined);
            setError(err);
        });
    };
    var onWmsUrlChange = function (e) {
        setWfsUrl(e.target.value);
    };
    return React.createElement("div", null,
        React.createElement(core_1.ControlGroup, { fill: true },
            React.createElement(core_1.InputGroup, { leftIcon: "geosearch", placeholder: (0, i18n_1.tr)("ADD_WFS_LAYER_URL", locale), value: wfsUrl, onChange: onWmsUrlChange, readOnly: loadingCapabilities, rightElement: React.createElement(core_1.Button, { intent: core_1.Intent.PRIMARY, icon: "arrow-right", onClick: onLoadCaps, disabled: loadingCapabilities }) })),
        React.createElement("br", null),
        React.createElement("div", null, (function () {
            if (loadingCapabilities) {
                return React.createElement(core_1.NonIdealState, { icon: React.createElement(core_1.Spinner, { intent: core_1.Intent.NONE, size: core_1.Spinner.SIZE_LARGE }), title: (0, i18n_1.tr)("ADD_WFS_LAYER_LOADING", locale), description: (0, i18n_1.tr)("ADD_WFS_LAYER_LOADING_DESC", locale) });
            }
            else {
                if (caps) {
                    return React.createElement(wfs_capabilities_panel_1.WfsCapabilitiesPanel, { onAddLayer: onAddLayer, capabilities: caps, locale: locale });
                }
                else if (error) {
                    return React.createElement(error_1.Error, { error: error });
                }
                else {
                    return React.createElement(core_1.NonIdealState, { icon: "issue", title: (0, i18n_1.tr)("ADD_WFS_LAYER_NO_LAYERS", locale), description: (0, i18n_1.tr)("WFS_NO_LAYER_DESCRIPTION", locale) });
                }
            }
        })()));
};
exports.AddWfsLayer = AddWfsLayer;


/***/ }),

/***/ "./src/components/layer-manager/add-wms-layer.tsx":
/*!********************************************************!*\
  !*** ./src/components/layer-manager/add-wms-layer.tsx ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddWmsLayer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var common_1 = __webpack_require__(/*! ../../api/common */ "./src/api/common.ts");
var i18n_1 = __webpack_require__(/*! ../../api/i18n */ "./src/api/i18n.ts");
var error_1 = __webpack_require__(/*! ../error */ "./src/components/error.tsx");
var client_1 = __webpack_require__(/*! ../../api/client */ "./src/api/client.ts");
var wms_capabilities_panel_1 = __webpack_require__(/*! ./wms-capabilities-panel */ "./src/components/layer-manager/wms-capabilities-panel.tsx");
var WMSCapabilities_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/format/WMSCapabilities */ "./node_modules/ol/format/WMSCapabilities.js"));
var Tile_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Tile */ "./node_modules/ol/layer/Tile.js"));
var Image_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Image */ "./node_modules/ol/layer/Image.js"));
var ImageWMS_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/ImageWMS */ "./node_modules/ol/source/ImageWMS.js"));
var TileWMS_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/TileWMS */ "./node_modules/ol/source/TileWMS.js"));
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var string_1 = __webpack_require__(/*! ../../utils/string */ "./src/utils/string.ts");
var layer_manager_1 = __webpack_require__(/*! ../../api/layer-manager */ "./src/api/layer-manager.ts");
var runtime_1 = __webpack_require__(/*! ../../api/runtime */ "./src/api/runtime.ts");
/**
 * @hidden
 */
var AddWmsLayer = function (props) {
    var locale = props.locale;
    var _a = React.useState(""), wmsUrl = _a[0], setWmsUrl = _a[1];
    var _b = React.useState(false), loadingCapabilities = _b[0], setLoadingCapabilities = _b[1];
    var _c = React.useState(undefined), caps = _c[0], setCaps = _c[1];
    var _d = React.useState(undefined), error = _d[0], setError = _d[1];
    var onAddLayer = function (name, selectable, isTiled, style) {
        var _a, _b;
        var viewer = (0, runtime_1.getViewer)();
        if (caps && viewer) {
            var params = {
                LAYERS: name
            };
            if (style) {
                params.STYLE = style.Name;
            }
            if (isTiled) {
                params.TILED = true;
            }
            var layer = void 0;
            var source = void 0;
            if (isTiled) {
                source = new TileWMS_1.default({
                    url: caps.Capability.Request.GetMap.DCPType[0].HTTP.Get.OnlineResource,
                    params: params
                });
                layer = new Tile_1.default({
                    source: source
                });
            }
            else {
                source = new ImageWMS_1.default({
                    url: caps.Capability.Request.GetMap.DCPType[0].HTTP.Get.OnlineResource,
                    params: params
                });
                layer = new Image_1.default({
                    source: source
                });
            }
            layer.set(common_1.LayerProperty.LAYER_TYPE, "WMS");
            layer.set(common_1.LayerProperty.IS_SELECTABLE, selectable);
            layer.set(common_1.LayerProperty.IS_EXTERNAL, true);
            layer.set(common_1.LayerProperty.IS_GROUP, false);
            if (style) {
                var legendUrl = (_b = (_a = style.LegendURL) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.OnlineResource;
                if (!(0, string_1.strIsNullOrEmpty)(legendUrl)) {
                    layer.set(common_1.LayerProperty.HAS_WMS_LEGEND, true);
                }
            }
            // Suppress automatic load event handling for this as we need our own
            source.set(common_1.SourceProperty.SUPPRESS_LOAD_EVENTS, true);
            var started = function () {
                viewer.addImageLoading();
                props.onAddLayerBusyWorker(name);
            };
            var finished = function () {
                viewer.addImageLoaded();
                props.onRemoveLayerBusyWorker(name);
            };
            if (source instanceof TileWMS_1.default) {
                source.on("tileloadstart", started);
                source.on("tileloadend", finished);
                source.on("tileloaderror", finished);
            }
            else if (source instanceof ImageWMS_1.default) {
                source.on("imageloadstart", started);
                source.on("imageloadend", finished);
                source.on("imageloaderror", finished);
            }
            viewer.getLayerManager().addLayer(name, layer);
            viewer.toastSuccess("success", (0, i18n_1.tr)("ADDED_LAYER", locale, { name: name }));
            props.onLayerAdded((0, layer_manager_1.getLayerInfo)(layer, true));
        }
    };
    var onLoadCaps = function () {
        setCaps(undefined);
        setLoadingCapabilities(true);
        var client = new client_1.Client("", "mapagent");
        client.getText(wmsUrl).then(function (s) {
            var parser = new WMSCapabilities_1.default();
            var caps = parser.read(s);
            if (caps.version != "1.3.0") {
                setLoadingCapabilities(false);
                setCaps(undefined);
                setError((0, i18n_1.tr)("WMS_UNSUPPORTED_VERSION", locale, { version: caps.version }));
            }
            else {
                setLoadingCapabilities(false);
                setCaps(caps);
                setError(undefined);
            }
        }).catch(function (err) {
            setLoadingCapabilities(false);
            setCaps(undefined);
            setError(err);
        });
    };
    var onWmsUrlChange = function (e) {
        setWmsUrl(e.target.value);
    };
    return React.createElement("div", null,
        React.createElement(core_1.ControlGroup, { fill: true },
            React.createElement(core_1.InputGroup, { leftIcon: "geosearch", placeholder: (0, i18n_1.tr)("ADD_WMS_LAYER_URL", locale), value: wmsUrl, onChange: onWmsUrlChange, readOnly: loadingCapabilities, rightElement: React.createElement(core_1.Button, { intent: core_1.Intent.PRIMARY, icon: "arrow-right", onClick: onLoadCaps, disabled: loadingCapabilities }) })),
        React.createElement("br", null),
        React.createElement("div", null, (function () {
            if (loadingCapabilities) {
                return React.createElement(core_1.NonIdealState, { icon: React.createElement(core_1.Spinner, { intent: core_1.Intent.NONE, size: core_1.Spinner.SIZE_LARGE }), title: (0, i18n_1.tr)("ADD_WMS_LAYER_LOADING", locale), description: (0, i18n_1.tr)("ADD_WMS_LAYER_LOADING_DESC", locale) });
            }
            else {
                if (caps) {
                    return React.createElement(wms_capabilities_panel_1.WmsCapabilitiesPanel, { onAddLayer: onAddLayer, capabilities: caps, locale: locale });
                }
                else if (error) {
                    return React.createElement(error_1.Error, { error: error });
                }
                else {
                    return React.createElement(core_1.NonIdealState, { icon: "issue", title: (0, i18n_1.tr)("ADD_WMS_LAYER_NO_LAYERS", locale), description: (0, i18n_1.tr)("WMS_NO_LAYER_DESCRIPTION", locale) });
                }
            }
        })()));
};
exports.AddWmsLayer = AddWmsLayer;


/***/ }),

/***/ "./src/components/layer-manager/color-brewer.tsx":
/*!*******************************************************!*\
  !*** ./src/components/layer-manager/color-brewer.tsx ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorBrewerSwatch = exports.getMaxRamp = exports.getColorBrewerRamps = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var colorbrewer_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! colorbrewer */ "./node_modules/colorbrewer/index.es.js"));
function getColorBrewerRamps() {
    var ramps = [];
    for (var cat in colorbrewer_1.default.schemeGroups) {
        for (var _i = 0, _a = colorbrewer_1.default.schemeGroups[cat]; _i < _a.length; _i++) {
            var scheme = _a[_i];
            ramps.push({ displayName: cat + " - " + scheme, category: cat, scheme: scheme, ramp: getMaxRamp(scheme) });
        }
    }
    return ramps;
}
exports.getColorBrewerRamps = getColorBrewerRamps;
function getMaxRamp(scheme) {
    var theScheme;
    var len = 0;
    for (var s in scheme) {
        var arr = scheme[s];
        if (arr.length > len) {
            theScheme = arr;
            len = arr.length;
        }
    }
    return theScheme;
}
exports.getMaxRamp = getMaxRamp;
var ColorBrewerSwatch = function (props) {
    var ramp = getMaxRamp(colorbrewer_1.default[props.theme]);
    if (ramp) {
        return React.createElement("table", null,
            React.createElement("colgroup", null, ramp.map(function (r, i) { return React.createElement("col", { key: "ramp-col-" + i, span: 1, style: { width: 12 } }); })),
            React.createElement("tbody", null,
                React.createElement("tr", null, ramp.map(function (r, i) { return React.createElement("td", { key: "ramp-" + i, style: { border: "1px solid black", backgroundColor: r } }, "\u00A0"); }))));
    }
    ;
    return React.createElement(React.Fragment, null);
};
exports.ColorBrewerSwatch = ColorBrewerSwatch;


/***/ }),

/***/ "./src/components/layer-manager/common.tsx":
/*!*************************************************!*\
  !*** ./src/components/layer-manager/common.tsx ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorExprEditor = exports.BooleanExprEditor = exports.StringExprEditor = exports.SliderExprEditor = exports.NumberExprEditor = exports.contrast = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var i18n_1 = __webpack_require__(/*! ../../api/i18n */ "./src/api/i18n.ts");
var ol_style_contracts_1 = __webpack_require__(/*! ../../api/ol-style-contracts */ "./src/api/ol-style-contracts.ts");
var string_1 = __webpack_require__(/*! ../../utils/string */ "./src/utils/string.ts");
var color_picker_1 = __webpack_require__(/*! ../color-picker */ "./src/components/color-picker.tsx");
function rgbToYIQ(_a) {
    var r = _a.r, g = _a.g, b = _a.b;
    return ((r * 299) + (g * 587) + (b * 114)) / 1000;
}
function hexToRgb(hex) {
    if (!hex || hex === undefined || hex === '') {
        return undefined;
    }
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : undefined;
}
function contrast(colorHex, threshold) {
    if (threshold === void 0) { threshold = 128; }
    if (colorHex === undefined) {
        return '#000';
    }
    var rgb = hexToRgb(colorHex);
    if (rgb === undefined) {
        return '#000';
    }
    return rgbToYIQ(rgb) >= threshold ? '#000' : '#fff';
}
exports.contrast = contrast;
function stringifyExpr(expr, locale) {
    if (!expr) {
        return (0, i18n_1.tr)("EXPR_NOT_SET", locale);
    }
    if ((0, ol_style_contracts_1.isEvaluatable)(expr)) {
        return "Expr: " + expr.expr;
    }
    return "" + (expr !== null && expr !== void 0 ? expr : string_1.STR_EMPTY);
}
function isStrTrue(s) {
    switch (s === null || s === void 0 ? void 0 : s.toLowerCase()) {
        case "true":
        case "1":
            return true;
        case "false":
        case "0":
            return false;
    }
    return false;
}
function stringifyExprIf(expr, mode) {
    switch (mode) {
        case "edit-expr":
            return (0, ol_style_contracts_1.isEvaluatable)(expr) ? expr.expr : string_1.STR_EMPTY;
        case "edit-value":
            return (0, ol_style_contracts_1.isEvaluatable)(expr) ? string_1.STR_EMPTY : "" + (expr !== null && expr !== void 0 ? expr : string_1.STR_EMPTY);
    }
}
function useExprEditor(props) {
    var value = props.value, onChange = props.onChange;
    var _a = React.useState((0, ol_style_contracts_1.isEvaluatable)(value) ? "edit-expr" : "edit-value"), editMode = _a[0], setEditMode = _a[1];
    var _b = React.useState(value), localValue = _b[0], setLocalValue = _b[1];
    var _c = React.useState(false), isEditing = _c[0], setIsEditing = _c[1];
    var _d = React.useState(false), isEditValid = _d[0], setIsEditValid = _d[1];
    React.useEffect(function () {
        setLocalValue(value);
    }, [value]);
    var onCancelEditing = React.useCallback(function () {
        setLocalValue(value);
        setIsEditing(false);
    }, [value]);
    var onApplyValue = function () {
        onChange(localValue);
        setIsEditing(false);
    };
    var onUpdateLocalValue = function (val) {
        try {
            setLocalValue(val);
            setIsEditValid(true);
        }
        catch (e) {
            setIsEditValid(false);
        }
    };
    return {
        editMode: editMode,
        localValue: localValue,
        isEditValid: isEditValid,
        isEditing: isEditing,
        setIsEditing: setIsEditing,
        setEditMode: setEditMode,
        setLocalValue: setLocalValue,
        onApplyValue: onApplyValue,
        onCancelEditing: onCancelEditing,
        onUpdateLocalValue: onUpdateLocalValue
    };
}
function ExprEditorInner(props) {
    var renderValueEditor = props.renderValueEditor, locale = props.locale, roStyle = props.roStyle;
    var _a = useExprEditor(props), isEditValid = _a.isEditValid, isEditing = _a.isEditing, localValue = _a.localValue, setIsEditing = _a.setIsEditing, editMode = _a.editMode, setEditMode = _a.setEditMode, onApplyValue = _a.onApplyValue, onCancelEditing = _a.onCancelEditing, onUpdateLocalValue = _a.onUpdateLocalValue;
    var onEditClick = function () {
        if (isEditing) {
            onCancelEditing();
        }
        else {
            setIsEditing(true);
        }
    };
    var editButton = React.createElement(core_1.Button, { icon: "edit", minimal: true, intent: core_1.Intent.PRIMARY, style: { color: "white", backgroundColor: "#137cbd" }, onClick: function (e) { return onEditClick(); } });
    return React.createElement(React.Fragment, null,
        React.createElement(core_1.InputGroup, { style: roStyle, readOnly: true, value: stringifyExpr(props.value, locale), rightElement: editButton }),
        React.createElement(core_1.Collapse, { isOpen: isEditing, keepChildrenMounted: false },
            React.createElement(core_1.Card, null,
                React.createElement("h5", { className: "bp3-heading" }, "Edit Value"),
                React.createElement(core_1.Radio, { name: "edit-mode", label: "Value", value: "edit-value", checked: editMode == "edit-value", onChange: function (e) { return setEditMode(e.target.value); } }),
                renderValueEditor(localValue, onUpdateLocalValue, locale, editMode != "edit-value"),
                React.createElement("br", null),
                React.createElement(core_1.Radio, { name: "edit-mode", label: "Expression", value: "edit-expr", checked: editMode == "edit-expr", onChange: function (e) { return setEditMode(e.target.value); } }),
                React.createElement("input", { disabled: editMode != "edit-expr", type: "text", className: "bp3-input", value: stringifyExprIf(localValue, "edit-expr"), onChange: function (e) { return onUpdateLocalValue({ expr: e.target.value }); } }),
                React.createElement("br", null),
                React.createElement("br", null),
                React.createElement(core_1.ButtonGroup, null,
                    React.createElement(core_1.Button, { disabled: !isEditValid, intent: core_1.Intent.SUCCESS, onClick: function (e) { return onApplyValue(); } }, "Apply"),
                    React.createElement(core_1.Button, { intent: core_1.Intent.DANGER, onClick: function (e) { return onCancelEditing(); } }, "Cancel")))));
}
var NumberExprEditor = function (props) {
    var min = props.min, max = props.max;
    return React.createElement(ExprEditorInner, { locale: props.locale, value: props.value, onChange: props.onChange, renderValueEditor: function (v, oc, loc, disabled) { return React.createElement(core_1.NumericInput, { disabled: disabled, min: min, max: max, value: parseInt(stringifyExprIf(v, "edit-value"), 10), onValueChange: function (e) { return oc(e); } }); } });
};
exports.NumberExprEditor = NumberExprEditor;
var SliderExprEditor = function (props) {
    var min = props.min, max = props.max, labelStepSize = props.labelStepSize;
    return React.createElement(ExprEditorInner, { locale: props.locale, value: props.value, onChange: props.onChange, renderValueEditor: function (v, oc, loc, disabled) { return React.createElement(core_1.Slider, { disabled: disabled, min: min, max: max, labelStepSize: labelStepSize, value: parseInt(stringifyExprIf(v, "edit-value"), 10), onChange: function (e) { return oc(e); } }); } });
};
exports.SliderExprEditor = SliderExprEditor;
var StringExprEditor = function (props) {
    return React.createElement(ExprEditorInner, { locale: props.locale, value: props.value, onChange: props.onChange, renderValueEditor: function (v, oc, loc, disabled) { return React.createElement("input", { disabled: disabled, type: "text", className: "bp3-input", value: stringifyExprIf(v, "edit-value"), onChange: function (e) { return oc(e.target.value); } }); } });
};
exports.StringExprEditor = StringExprEditor;
var BooleanExprEditor = function (props) {
    return React.createElement(ExprEditorInner, { locale: props.locale, value: props.value, onChange: props.onChange, renderValueEditor: function (v, oc, loc, disabled) { return React.createElement(core_1.Switch, { disabled: disabled, checked: isStrTrue(stringifyExprIf(v, "edit-value")), onChange: function (e) { return oc(e.target.checked); } }); } });
};
exports.BooleanExprEditor = BooleanExprEditor;
var ColorExprEditor = function (props) {
    var value = props.value;
    var roStyle;
    if (!(0, ol_style_contracts_1.isEvaluatable)(value) && !(0, string_1.strIsNullOrEmpty)(value)) {
        roStyle = {
            backgroundColor: value,
            color: contrast(value)
        };
    }
    return React.createElement(ExprEditorInner, { roStyle: roStyle, locale: props.locale, value: value, onChange: props.onChange, renderValueEditor: function (v, oc, loc, disabled) { return React.createElement(color_picker_1.ColorPicker, { locale: loc, value: stringifyExprIf(v, "edit-value"), onChange: function (e) { return oc(e); } }); } });
};
exports.ColorExprEditor = ColorExprEditor;


/***/ }),

/***/ "./src/components/layer-manager/legend.ts":
/*!************************************************!*\
  !*** ./src/components/layer-manager/legend.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*

Originally copied from: https://github.com/Viglino/ol-ext/blob/master/src/legend/Legend.js

BSD 3-Clause License

Copyright (c) 2016-2021, Jean-Marc Viglino, IGN-France
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLegendImage = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var has_1 = __webpack_require__(/*! ol/has */ "./node_modules/ol/has.js");
var render_1 = __webpack_require__(/*! ol/render */ "./node_modules/ol/render.js");
var Feature_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/Feature */ "./node_modules/ol/Feature.js"));
var Point_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/Point */ "./node_modules/ol/geom/Point.js"));
var LineString_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/LineString */ "./node_modules/ol/geom/LineString.js"));
var Polygon_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/Polygon */ "./node_modules/ol/geom/Polygon.js"));
var extent_1 = __webpack_require__(/*! ol/extent */ "./node_modules/ol/extent.js");
var DEFAULT_SIZE = [16, 16];
/**
 * Get a symbol image for a given legend item
 * @param {LegendItemOptions} item
 * @param {HTMLCanvasElement|undefined} canvas a canvas to draw in, if none create one
 * @param {number|undefined} row row number to draw in canvas, default 0
 * @since 0.14
 */
function getLegendImage(item, canvas, row) {
    var _a;
    if (canvas === void 0) { canvas = undefined; }
    if (row === void 0) { row = 0; }
    item = item || {};
    if (typeof (item.margin) === 'undefined')
        item.margin = 10;
    var size = item.size || DEFAULT_SIZE;
    item.onload = item.onload || function () {
        setTimeout(function () {
            getLegendImage(item, canvas, row);
        }, 100);
    };
    var width = size[0] + 2 * item.margin;
    var height = item.lineHeight || (size[1] + 2 * item.margin);
    var ratio = has_1.DEVICE_PIXEL_RATIO;
    if (!canvas) {
        row = 0;
        canvas = document.createElement('canvas');
        canvas.width = width * ratio;
        canvas.height = height * ratio;
    }
    var ctx = canvas.getContext('2d');
    if (ctx) {
        ctx.save();
        var vectorContext = (0, render_1.toContext)(ctx, { pixelRatio: ratio });
        var typeGeom = item.typeGeom;
        var style = void 0;
        var feature = item.feature;
        if (!feature && typeGeom) {
            if (/Point/.test(typeGeom))
                feature = new Feature_1.default(new Point_1.default([0, 0]));
            else if (/LineString/.test(typeGeom))
                feature = new Feature_1.default(new LineString_1.default([0, 0]));
            else
                feature = new Feature_1.default(new Polygon_1.default([[[0, 0]]]));
            if (item.properties)
                feature.setProperties(item.properties);
        }
        if (feature) {
            style = feature.getStyle();
            if (typeof (style) === 'function')
                style = style(feature);
            if (!style) {
                style = typeof (item.style) === 'function' ? item.style(feature) : item.style || [];
            }
            typeGeom = (_a = feature.getGeometry()) === null || _a === void 0 ? void 0 : _a.getType();
        }
        else {
            style = [];
        }
        if (!(style instanceof Array))
            style = [style];
        var styles = style;
        var cx = width / 2;
        var cy = height / 2;
        var sx = size[0] / 2;
        var sy = size[1] / 2;
        var i = void 0;
        var s = void 0;
        // Get point offset
        if (typeGeom === 'Point') {
            var extent = null;
            for (var i_1 = 0; s = styles[i_1]; i_1++) {
                var img = s.getImage();
                // Refresh legend on image load
                if (img) {
                    var imgElt = img.getImage(devicePixelRatio);
                    // Check image is loaded
                    if (imgElt && imgElt.complete && !imgElt.naturalWidth) {
                        if (typeof (item.onload) === 'function') {
                            imgElt.addEventListener('load', function () {
                                setTimeout(function () {
                                    var _a;
                                    (_a = item.onload) === null || _a === void 0 ? void 0 : _a.call(item);
                                }, 100);
                            });
                        }
                        img.load();
                    }
                    // Check anchor to center the image
                    if (img.getAnchor) {
                        var anchor = img.getAnchor();
                        if (anchor) {
                            var si = img.getSize();
                            var dx = anchor[0] - si[0];
                            var dy = anchor[1] - si[1];
                            if (!extent) {
                                extent = [dx, dy, dx + si[0], dy + si[1]];
                            }
                            else {
                                (0, extent_1.extend)(extent, [dx, dy, dx + si[0], dy + si[1]]);
                            }
                        }
                    }
                }
            }
            if (extent) {
                cx = cx + (extent[2] + extent[0]) / 2;
                cy = cy + (extent[3] + extent[1]) / 2;
            }
        }
        // Draw image
        cy += (row * height) || 0;
        for (i = 0; s = style[i]; i++) {
            vectorContext.setStyle(s);
            switch (typeGeom) {
                case Point_1.default:
                case 'Point':
                case 'MultiPoint':
                    vectorContext.drawGeometry(new Point_1.default([cx, cy]));
                    break;
                case LineString_1.default:
                case 'LineString':
                case 'MultiLineString':
                    ctx.save();
                    ctx.rect(item.margin * ratio, 0, size[0] * ratio, canvas.height);
                    ctx.clip();
                    vectorContext.drawGeometry(new LineString_1.default([[cx - sx, cy], [cx + sx, cy]]));
                    ctx.restore();
                    break;
                case Polygon_1.default:
                case 'Polygon':
                case 'MultiPolygon':
                    vectorContext.drawGeometry(new Polygon_1.default([[[cx - sx, cy - sy], [cx + sx, cy - sy], [cx + sx, cy + sy], [cx - sx, cy + sy], [cx - sx, cy - sy]]]));
                    break;
            }
        }
        ctx.restore();
    }
    return canvas;
}
exports.getLegendImage = getLegendImage;
;


/***/ }),

/***/ "./src/components/layer-manager/manage-layers.tsx":
/*!********************************************************!*\
  !*** ./src/components/layer-manager/manage-layers.tsx ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ManageLayers = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var i18n_1 = __webpack_require__(/*! ../../api/i18n */ "./src/api/i18n.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var string_1 = __webpack_require__(/*! ../../utils/string */ "./src/utils/string.ts");
var ol_style_contracts_1 = __webpack_require__(/*! ../../api/ol-style-contracts */ "./src/api/ol-style-contracts.ts");
var vector_style_editor_1 = __webpack_require__(/*! ../vector-style-editor */ "./src/components/vector-style-editor.tsx");
function isBoundsZoomable(layer) {
    var _a;
    //TODO: See if WGS84_BBOX [is/can be] surfaced to ILayerInfo
    if (((_a = layer.metadata) === null || _a === void 0 ? void 0 : _a.geojson_as_vt) === true) {
        return false;
    }
    return layer.type != "WMS";
}
var OpenPanel;
(function (OpenPanel) {
    OpenPanel[OpenPanel["None"] = 0] = "None";
    OpenPanel[OpenPanel["MoreLayerOptions"] = 1] = "MoreLayerOptions";
    OpenPanel[OpenPanel["EditVectorStyle"] = 2] = "EditVectorStyle";
    OpenPanel[OpenPanel["WmsLegend"] = 3] = "WmsLegend";
})(OpenPanel || (OpenPanel = {}));
var HEATMAP_SLIDER_RAMP = [0, 10, 20, 30, 40, 50];
var LAYER_SWITCH_STYLE = { whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis" };
var ManageLayerItem = function (props) {
    var _a, _b, _c, _d;
    var layer = props.layer, locale = props.locale, canMoveUp = props.canMoveUp, canMoveDown = props.canMoveDown, currentResolution = props.currentResolution, onSetOpacity = props.onSetOpacity, onSetHeatmapBlur = props.onSetHeatmapBlur, onSetHeatmapRadius = props.onSetHeatmapRadius, onRemoveLayer = props.onRemoveLayer, onMoveLayerUp = props.onMoveLayerUp, onMoveLayerDown = props.onMoveLayerDown, onZoomToBounds = props.onZoomToBounds, onSetVisibility = props.onSetVisibility, onVectorStyleChanged = props.onVectorStyleChanged;
    var _e = React.useState(undefined), wmsLegendUrl = _e[0], setWmsLegendUrl = _e[1];
    var _f = React.useState(OpenPanel.None), openPanel = _f[0], setOpenPanel = _f[1];
    var onToggleWmsLegend = function (action) {
        if (wmsLegendUrl) {
            setWmsLegendUrl(undefined);
            setOpenPanel(OpenPanel.None);
        }
        else {
            var url = action(currentResolution);
            setWmsLegendUrl(url);
            setOpenPanel(OpenPanel.WmsLegend);
        }
    };
    var toggleOpenPanel = function (panel) {
        var p = OpenPanel.None;
        switch (panel) {
            case OpenPanel.EditVectorStyle:
            case OpenPanel.MoreLayerOptions:
            case OpenPanel.WmsLegend:
                p = (panel == openPanel) ? OpenPanel.None : panel;
                break;
        }
        setOpenPanel(p);
    };
    var isBusy = (layer.busyWorkerCount > 0);
    if (isBusy) {
        return React.createElement(core_1.Card, null,
            React.createElement(core_1.Spinner, { size: 30 }),
            React.createElement("p", { style: { textAlign: "center", marginTop: 5 } }, (0, i18n_1.tr)("LOADING_LAYER", locale, { name: layer.name })));
    }
    var canZoom = isBoundsZoomable(layer);
    var iconName = "layer";
    if (layer.type == "WMS") {
        iconName = "media";
    }
    var extraActions = [];
    var extensions = layer.extensions;
    var isWms = false;
    if (extensions) {
        switch (extensions.type) {
            case "WMS":
                {
                    isWms = true;
                    if (extensions.getLegendUrl) {
                        extraActions.push(React.createElement(core_1.Button, { key: "toggle-wms-legend", intent: core_1.Intent.SUCCESS, icon: "info-sign", onClick: function () { return onToggleWmsLegend(extensions.getLegendUrl); } }));
                    }
                }
        }
    }
    if (layer.vectorStyle) {
        if (layer.type != "KML" && layer.heatmap == null) {
            extraActions.push(React.createElement(core_1.Button, { key: "edit-vector-style", title: (0, i18n_1.tr)("LAYER_MANAGER_TT_EDIT_STYLE", locale), intent: core_1.Intent.PRIMARY, icon: "edit", onClick: function () { return toggleOpenPanel(OpenPanel.EditVectorStyle); } }));
        }
    }
    extraActions.push(React.createElement(core_1.Button, { key: "more-layer-options", title: (0, i18n_1.tr)("LAYER_MANAGER_TT_MORE_OPTIONS", locale), intent: core_1.Intent.PRIMARY, icon: "cog", onClick: function () { return toggleOpenPanel(OpenPanel.MoreLayerOptions); } }));
    var isWmsLegendOpen = !(0, string_1.strIsNullOrEmpty)(wmsLegendUrl);
    var layerLabel = (_a = layer.displayName) !== null && _a !== void 0 ? _a : layer.name;
    var theVectorStyle = (_c = (_b = layer.cluster) === null || _b === void 0 ? void 0 : _b.style) !== null && _c !== void 0 ? _c : layer.vectorStyle;
    var which;
    if (theVectorStyle == layer.vectorStyle) {
        which = ol_style_contracts_1.VectorStyleSource.Base;
    }
    else if (theVectorStyle == ((_d = layer.cluster) === null || _d === void 0 ? void 0 : _d.style)) {
        which = ol_style_contracts_1.VectorStyleSource.Cluster;
    }
    var enableLine = false;
    var enablePoint = false;
    var enablePolygon = false;
    for (var k in theVectorStyle) {
        if (theVectorStyle[k].point) {
            enablePoint = true;
        }
        if (theVectorStyle[k].line) {
            enableLine = true;
        }
        if (theVectorStyle[k].polygon) {
            enablePolygon = true;
        }
    }
    return React.createElement(core_1.Card, { key: layer.name },
        React.createElement(core_1.Switch, { style: LAYER_SWITCH_STYLE, checked: layer.visible, onChange: function () { return onSetVisibility(layer.name, !layer.visible); }, labelElement: React.createElement("span", { title: layerLabel },
                React.createElement(core_1.Icon, { icon: iconName }),
                " ",
                layerLabel) }),
        React.createElement(core_1.ButtonGroup, null,
            React.createElement(core_1.Button, { disabled: !canMoveUp, title: (0, i18n_1.tr)("LAYER_MANAGER_TT_MOVE_UP", locale), intent: core_1.Intent.PRIMARY, icon: "caret-up", onClick: function () { return onMoveLayerUp(layer.name); } }),
            React.createElement(core_1.Button, { disabled: !canMoveDown, title: (0, i18n_1.tr)("LAYER_MANAGER_TT_MOVE_DOWN", locale), intent: core_1.Intent.PRIMARY, icon: "caret-down", onClick: function () { return onMoveLayerDown(layer.name); } }),
            React.createElement(core_1.Button, { disabled: !canZoom, title: (0, i18n_1.tr)("LAYER_MANAGER_TT_ZOOM_EXTENTS", locale), intent: core_1.Intent.SUCCESS, icon: "zoom-to-fit", onClick: function () { return onZoomToBounds(layer.name); } }),
            React.createElement(core_1.Button, { title: (0, i18n_1.tr)("LAYER_MANAGER_TT_REMOVE", locale), intent: core_1.Intent.DANGER, icon: "trash", onClick: function () { return onRemoveLayer(layer.name); } }),
            extraActions),
        React.createElement(core_1.Collapse, { isOpen: openPanel == OpenPanel.MoreLayerOptions },
            React.createElement(core_1.Card, null,
                React.createElement("h5", { className: "bp3-heading" },
                    React.createElement("a", { href: "#" }, (0, i18n_1.tr)("MORE_LAYER_OPTIONS", locale))),
                React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("LAYER_OPACITY", locale) },
                    React.createElement(core_1.Slider, { min: 0, max: 1.0, stepSize: 0.01, value: layer.opacity, onChange: function (e) { return onSetOpacity(layer.name, e); } })),
                layer.heatmap && React.createElement(React.Fragment, null,
                    React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("LAYER_HEATMAP_BLUR", locale) },
                        React.createElement(core_1.Slider, { min: 1, max: 50, stepSize: 1, labelValues: HEATMAP_SLIDER_RAMP, value: layer.heatmap.blur, onChange: function (e) { return onSetHeatmapBlur(layer.name, e); } })),
                    React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("LAYER_HEATMAP_RADIUS", locale) },
                        React.createElement(core_1.Slider, { min: 1, max: 50, stepSize: 1, labelValues: HEATMAP_SLIDER_RAMP, value: layer.heatmap.radius, onChange: function (e) { return onSetHeatmapRadius(layer.name, e); } }))))),
        isWms && React.createElement(core_1.Collapse, { isOpen: isWmsLegendOpen },
            React.createElement(core_1.Card, null,
                React.createElement("h5", { className: "bp3-heading" },
                    React.createElement("a", { href: "#" }, (0, i18n_1.tr)("WMS_LEGEND", locale))),
                React.createElement("img", { src: wmsLegendUrl }))),
        theVectorStyle && React.createElement(core_1.Collapse, { isOpen: openPanel == OpenPanel.EditVectorStyle },
            React.createElement("div", { style: { padding: 5 } },
                React.createElement("h5", { className: "bp3-heading" },
                    React.createElement("a", { href: "#" }, (0, i18n_1.tr)("VECTOR_LAYER_STYLE", locale))),
                React.createElement(vector_style_editor_1.VectorLayerStyleEditor, { onChange: function (st) { return onVectorStyleChanged(layer.name, st, which); }, locale: locale, style: theVectorStyle, enablePoint: enablePoint, enableLine: enableLine, enablePolygon: enablePolygon }))));
};
/**
 * @hidden
 */
var ManageLayers = function (props) {
    var locale = props.locale, currentResolution = props.currentResolution, onSetOpacity = props.onSetOpacity, onSetHeatmapBlur = props.onSetHeatmapBlur, onSetHeatmapRadius = props.onSetHeatmapRadius, onRemoveLayer = props.onRemoveLayer, onMoveLayerUp = props.onMoveLayerUp, onMoveLayerDown = props.onMoveLayerDown, onZoomToBounds = props.onZoomToBounds, onSetVisibility = props.onSetVisibility, onVectorStyleChanged = props.onVectorStyleChanged;
    var _a = React.useState(props.layers), layers = _a[0], setLayers = _a[1];
    React.useEffect(function () {
        setLayers(props.layers);
    }, [props.layers]);
    if (layers.length) {
        return React.createElement("div", null, layers.map(function (lyr, i) {
            var cannotMoveUp = (i == 0 || layers.length <= 1);
            var cannotMoveDown = (i >= layers.length - 1 || layers.length <= 1);
            return React.createElement(ManageLayerItem, { key: "manage-layer-" + i, layer: lyr, locale: locale, canMoveUp: !cannotMoveUp, canMoveDown: !cannotMoveDown, currentResolution: currentResolution, onSetOpacity: onSetOpacity, onSetHeatmapBlur: onSetHeatmapBlur, onSetHeatmapRadius: onSetHeatmapRadius, onRemoveLayer: onRemoveLayer, onMoveLayerUp: onMoveLayerUp, onMoveLayerDown: onMoveLayerDown, onZoomToBounds: onZoomToBounds, onSetVisibility: onSetVisibility, onVectorStyleChanged: onVectorStyleChanged });
        }));
    }
    else {
        return React.createElement(core_1.NonIdealState, { icon: "layers", title: (0, i18n_1.tr)("NO_EXTERNAL_LAYERS", locale), description: (0, i18n_1.tr)("NO_EXTERNAL_LAYERS_DESC", locale, { tabName: (0, i18n_1.tr)("ADD_LAYER", locale) }) });
    }
};
exports.ManageLayers = ManageLayers;


/***/ }),

/***/ "./src/components/layer-manager/wfs-capabilities-panel.tsx":
/*!*****************************************************************!*\
  !*** ./src/components/layer-manager/wfs-capabilities-panel.tsx ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WfsCapabilitiesPanel = exports.parseEpsgCodeFromCRS = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var i18n_1 = __webpack_require__(/*! ../../api/i18n */ "./src/api/i18n.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
/**
 * Attempts to extract an EPSG code from the given CRS identifier
 *
 * @export
 * @param {string | undefined} crs
 * @returns {(number | undefined)}
 * @since 0.13
 */
function parseEpsgCodeFromCRS(crs) {
    if (crs == "urn:ogc:def:crs:OGC:1.3:CRS84") {
        return 4326;
    }
    var res = crs === null || crs === void 0 ? void 0 : crs.match(/urn:ogc:def:crs:EPSG::(\d+)/);
    if ((res === null || res === void 0 ? void 0 : res.length) == 2) {
        return parseInt(res[1], 10);
    }
    res = crs === null || crs === void 0 ? void 0 : crs.match(/EPSG:(\d+)/);
    if ((res === null || res === void 0 ? void 0 : res.length) == 2) {
        return parseInt(res[1], 10);
    }
    return undefined;
}
exports.parseEpsgCodeFromCRS = parseEpsgCodeFromCRS;
function isGeoJsonMimeType(mimeType) {
    var _a;
    var lmt = (_a = mimeType === null || mimeType === void 0 ? void 0 : mimeType.toLowerCase()) !== null && _a !== void 0 ? _a : "";
    if (lmt.indexOf("application/vnd.geo+json") >= 0 ||
        lmt.indexOf("application/json") >= 0) {
        return true;
    }
    return false;
}
function getGeoJsonFormat(serviceInfo, layer) {
    var _a, _b, _c, _d;
    var lformats = (_b = ((_a = layer.formats) !== null && _a !== void 0 ? _a : []).filter(function (f) { return isGeoJsonMimeType(f); })) === null || _b === void 0 ? void 0 : _b[0];
    // NOTE: Some WFS services advertise GeoJSON support as an allowed outputFormat parameter at the service-level, 
    // but not as an advertised outputFormat for the layer in question. Without fully reading the spec, I don't know
    // if using GetFeature for a layer with a service-level outputFormat for such layers is formally allowed. Based
    // on my sample WFS services, this appears to be allowed, so if geojson is supported at the service-level, but
    // not at the layer level, we'll still consider geojson as being "supported"
    var sformats = (_d = ((_c = serviceInfo.allowedOutputFormats) !== null && _c !== void 0 ? _c : []).filter(function (f) { return isGeoJsonMimeType(f); })) === null || _d === void 0 ? void 0 : _d[0];
    return lformats !== null && lformats !== void 0 ? lformats : sformats;
}
function getLayerCrs(layer) {
    var pdc = [parseEpsgCodeFromCRS(layer.defaultCrs), layer.defaultCrs];
    // We strongly prefer 4326/3857 projections over others
    if (!(pdc[0] == 4326 || pdc[0] == 3857)) {
        if (layer.otherCrs) {
            var matches = layer.otherCrs.filter(function (c) {
                var poc = parseEpsgCodeFromCRS(c);
                return (poc == 4326 || poc == 3857);
            });
            if (matches.length > 0) {
                pdc = [parseEpsgCodeFromCRS(matches[0]), matches[0]];
            }
        }
    }
    return pdc;
}
/**
 * @hidden
 */
var WfsCapabilitiesPanel = function (props) {
    var locale = props.locale, capabilities = props.capabilities, onAddLayer = props.onAddLayer;
    var layers = capabilities.layers, info = capabilities.info;
    return React.createElement(React.Fragment, null,
        React.createElement(core_1.Card, null,
            React.createElement("h5", { className: "bp3-heading" },
                React.createElement("a", { href: "#" }, (0, i18n_1.tr)("WFS_SERVICE_INFO", locale))),
            React.createElement("p", null, (0, i18n_1.tr)("WFS_VERSION", locale, { version: info.version })),
            React.createElement("p", null, (0, i18n_1.tr)("OWS_SERVICE_TITLE", locale, { title: info.title })),
            React.createElement("p", null, (0, i18n_1.tr)("OWS_SERVICE_ABSTRACT", locale, { abstract: info.abstract }))),
        React.createElement(core_1.Card, { style: { marginBottom: 10 } },
            React.createElement("h5", { className: "bp3-heading" },
                React.createElement("a", { href: "#" }, (0, i18n_1.tr)("WFS_AVAILABLE_LAYERS", locale))),
            layers.map(function (layer) {
                var geoJsonFmt = getGeoJsonFormat(info, layer);
                var _a = getLayerCrs(layer), epsgCode = _a[0], origCrs = _a[1];
                //Only include layers whose CRS was able to be parsed into an epsg code
                if (epsgCode && geoJsonFmt) {
                    var otherActions = React.createElement(React.Fragment, null);
                    return React.createElement(core_1.Card, { key: layer.name, style: { padding: 15, paddingTop: 5 } },
                        React.createElement("h4", null,
                            React.createElement(core_1.Icon, { icon: "layer" }),
                            " ",
                            layer.name),
                        React.createElement("p", null, (0, i18n_1.tr)("OWS_LAYER_TITLE", locale, { title: layer.title })),
                        React.createElement("p", null, (0, i18n_1.tr)("OWS_LAYER_CRS", locale, { crs: "EPSG:" + epsgCode })),
                        React.createElement(core_1.ButtonGroup, { fill: true },
                            React.createElement(core_1.Button, { onClick: function () { return onAddLayer(layer.name, info.version, geoJsonFmt, origCrs, epsgCode, layer.wgs84Bounds); }, intent: core_1.Intent.PRIMARY, icon: "new-layer" }, (0, i18n_1.tr)("ADD_LAYER", locale)),
                            otherActions));
                }
            }).filter(function (c) { return c; })));
};
exports.WfsCapabilitiesPanel = WfsCapabilitiesPanel;


/***/ }),

/***/ "./src/components/layer-manager/wfs-capabilities-parser.ts":
/*!*****************************************************************!*\
  !*** ./src/components/layer-manager/wfs-capabilities-parser.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WfsCapabilitiesParser = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var string_1 = __webpack_require__(/*! ../../utils/string */ "./src/utils/string.ts");
function tryGetElementContent(el) {
    var _a;
    if (el) {
        return (_a = el.textContent) !== null && _a !== void 0 ? _a : el.text;
    }
}
function getElements(root, tagName, ns) {
    var els;
    if (ns) {
        els = root.getElementsByTagName(ns + ":" + tagName);
        if (els.length == 0) {
            //Try un-qualified
            els = root.getElementsByTagName(tagName);
        }
    }
    else {
        els = root.getElementsByTagName(tagName);
    }
    var elements = [];
    if (els) {
        for (var i = 0; i < els.length; i++) {
            var el = els.item(i);
            if (el) {
                elements.push(el);
            }
        }
    }
    return elements;
}
function trySetProperty(obj, setter, value) {
    if (value) {
        setter(obj, value);
    }
}
/**
 * A basic parser for WFS capabilities XML
 *
 * @export
 * @class WfsCapabilitiesParser
 * @since 0.13
 */
var WfsCapabilitiesParser = /** @class */ (function () {
    function WfsCapabilitiesParser() {
    }
    WfsCapabilitiesParser.prototype.parse = function (xml) {
        var parser = new DOMParser();
        this.xmlDoc = parser.parseFromString(xml, "text/xml");
        var info = this.getServiceInfo();
        var layers = this.getLayers();
        return {
            info: info,
            layers: layers
        };
    };
    WfsCapabilitiesParser.prototype.getServiceInfo = function () {
        var _a, _b;
        var els = getElements(this.xmlDoc, "ServiceIdentification", "ows");
        var info = {
            title: "",
            abstract: "",
            version: ""
        };
        if (els.length == 1) {
            var t = tryGetElementContent((_a = getElements(els[0], "Title", "ows")) === null || _a === void 0 ? void 0 : _a[0]);
            var a = tryGetElementContent((_b = getElements(els[0], "Abstract", "ows")) === null || _b === void 0 ? void 0 : _b[0]);
            var ops = getElements(this.xmlDoc, "Operation", "ows");
            for (var _i = 0, ops_1 = ops; _i < ops_1.length; _i++) {
                var op = ops_1[_i];
                if (op.getAttribute("name") == "GetFeature") {
                    var parms = getElements(op, "Parameter", "ows");
                    for (var _c = 0, parms_1 = parms; _c < parms_1.length; _c++) {
                        var parm = parms_1[_c];
                        if (parm.getAttribute("name") == "outputFormat") {
                            var allowedValues = getElements(parm, "Value", "ows")
                                .map(function (av) { return tryGetElementContent(av); })
                                .filter(function (s) { return !(0, string_1.strIsNullOrEmpty)(s); });
                            if (allowedValues.length > 0) {
                                info.allowedOutputFormats = allowedValues;
                            }
                        }
                    }
                }
            }
            var v = getElements(els[0], "ServiceTypeVersion", "ows")
                .map(function (el) { return tryGetElementContent(el); })
                .filter(function (s) { return !(0, string_1.strIsNullOrEmpty)(s); });
            v.sort();
            trySetProperty(info, function (i, v) { return i.title = v; }, t);
            trySetProperty(info, function (i, v) { return i.abstract = v; }, a);
            //Pick the last (highest) version
            if (v.length > 0) {
                info.version = v[v.length - 1];
            }
        }
        return info;
    };
    WfsCapabilitiesParser.prototype.getLayers = function () {
        var els = getElements(this.xmlDoc, "FeatureType", "wfs");
        var layers = els.map(function (el) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            var info = {
                name: "",
                title: "",
                abstract: "",
                defaultCrs: ""
            };
            var n = tryGetElementContent((_a = getElements(el, "Name", "wfs")) === null || _a === void 0 ? void 0 : _a[0]);
            var t = tryGetElementContent((_b = getElements(el, "Title", "wfs")) === null || _b === void 0 ? void 0 : _b[0]);
            var a = tryGetElementContent((_c = getElements(el, "Abstract", "wfs")) === null || _c === void 0 ? void 0 : _c[0]);
            var c = tryGetElementContent((_e = (_d = getElements(el, "DefaultCRS", "wfs")) === null || _d === void 0 ? void 0 : _d[0]) !== null && _e !== void 0 ? _e : (_f = getElements(el, "DefaultSRS", "wfs")) === null || _f === void 0 ? void 0 : _f[0] // WFS older versions
            );
            var oc = getElements(el, "OtherCRS", "wfs")
                .map(function (fel) { return tryGetElementContent(fel); })
                .filter(function (s) { return !(0, string_1.strIsNullOrEmpty)(s); });
            var os = getElements(el, "OtherSRS", "wfs")
                .map(function (fel) { return tryGetElementContent(fel); })
                .filter(function (s) { return !(0, string_1.strIsNullOrEmpty)(s); });
            info.otherCrs = (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], oc, true), os, true);
            var fmts = getElements(el, "Format", "wfs")
                .map(function (fel) { return tryGetElementContent(fel); })
                .filter(function (s) { return !(0, string_1.strIsNullOrEmpty)(s); });
            var ll = tryGetElementContent((_g = getElements(el, "LowerCorner", "ows")) === null || _g === void 0 ? void 0 : _g[0]);
            var ur = tryGetElementContent((_h = getElements(el, "UpperCorner", "ows")) === null || _h === void 0 ? void 0 : _h[0]);
            trySetProperty(info, function (i, v) { return i.name = v; }, n);
            trySetProperty(info, function (i, v) { return i.title = v; }, t);
            trySetProperty(info, function (i, v) { return i.abstract = v; }, a);
            trySetProperty(info, function (i, v) { return i.defaultCrs = v; }, c);
            if (fmts.length > 0) {
                info.formats = fmts;
            }
            var llParts = ll === null || ll === void 0 ? void 0 : ll.split(' ').map(function (s) { return parseFloat(s); });
            var urParts = ur === null || ur === void 0 ? void 0 : ur.split(' ').map(function (s) { return parseFloat(s); });
            if ((llParts === null || llParts === void 0 ? void 0 : llParts.length) == 2 && (urParts === null || urParts === void 0 ? void 0 : urParts.length) == 2) {
                info.wgs84Bounds = [
                    llParts[0],
                    llParts[1],
                    urParts[0],
                    urParts[1]
                ];
            }
            return info;
        });
        return layers;
    };
    return WfsCapabilitiesParser;
}());
exports.WfsCapabilitiesParser = WfsCapabilitiesParser;


/***/ }),

/***/ "./src/components/layer-manager/wms-capabilities-panel.tsx":
/*!*****************************************************************!*\
  !*** ./src/components/layer-manager/wms-capabilities-panel.tsx ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WmsCapabilitiesPanel = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var i18n_1 = __webpack_require__(/*! ../../api/i18n */ "./src/api/i18n.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
function extractWmsLayers(caps) {
    var _a, _b;
    var layers = [];
    var _c = caps.Capability.Layer, Layer = _c.Layer, rootLayer = (0, tslib_1.__rest)(_c, ["Layer"]);
    if (rootLayer.Name) { //Must have name to be considered
        layers.push([rootLayer, (_a = rootLayer.Style) !== null && _a !== void 0 ? _a : []]);
    }
    if (caps.Capability.Layer.Layer) {
        for (var _i = 0, _d = caps.Capability.Layer.Layer; _i < _d.length; _i++) {
            var layer = _d[_i];
            layers.push([layer, (_b = layer.Style) !== null && _b !== void 0 ? _b : []]);
        }
    }
    return layers;
}
var WmsCapabilitiesPanel = function (props) {
    var locale = props.locale, onAddLayer = props.onAddLayer;
    var caps = props.capabilities;
    var layers = extractWmsLayers(caps);
    return React.createElement(React.Fragment, null,
        React.createElement(core_1.Card, null,
            React.createElement("h5", { className: "bp3-heading" },
                React.createElement("a", { href: "#" }, (0, i18n_1.tr)("WMS_SERVICE_INFO", locale))),
            React.createElement("p", null, (0, i18n_1.tr)("WMS_VERSION", locale, { version: caps.version })),
            React.createElement("p", null, (0, i18n_1.tr)("OWS_SERVICE_NAME", locale, { name: caps.Service.Name })),
            React.createElement("p", null, (0, i18n_1.tr)("OWS_SERVICE_TITLE", locale, { title: caps.Service.Title })),
            React.createElement("p", null, (0, i18n_1.tr)("OWS_SERVICE_ABSTRACT", locale, { abstract: caps.Service.Abstract }))),
        React.createElement(core_1.Card, { style: { marginBottom: 10 } },
            React.createElement("h5", { className: "bp3-heading" },
                React.createElement("a", { href: "#" }, (0, i18n_1.tr)("WMS_AVAILABLE_LAYERS", locale))),
            layers.map(function (_a) {
                var layer = _a[0], styles = _a[1];
                var otherActions = React.createElement(React.Fragment, null);
                return React.createElement(core_1.Card, { key: layer.Name, style: { padding: 15, paddingTop: 5 } },
                    React.createElement("h4", null,
                        React.createElement(core_1.Icon, { icon: "layer" }),
                        " ",
                        layer.Name),
                    React.createElement("p", null, (0, i18n_1.tr)("OWS_LAYER_TITLE", locale, { title: layer.Title })),
                    (function () {
                        if (styles.length) {
                            return styles.map(function (st) { return React.createElement(core_1.ButtonGroup, { key: st.Name, vertical: true, fill: true, alignText: "left" },
                                React.createElement(core_1.Button, { onClick: function () { var _a, _b; return onAddLayer(layer.Name, layer.queryable, false, st, (_b = (_a = st.LegendURL) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.OnlineResource); }, intent: core_1.Intent.PRIMARY, icon: "new-layer" }, (0, i18n_1.tr)("ADD_LAYER_WITH_WMS_STYLE", locale, { style: st.Name })),
                                React.createElement(core_1.Button, { onClick: function () { var _a, _b; return onAddLayer(layer.Name, layer.queryable, true, st, (_b = (_a = st.LegendURL) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.OnlineResource); }, intent: core_1.Intent.PRIMARY, icon: "new-layer" }, (0, i18n_1.tr)("ADD_LAYER_WITH_WMS_STYLE_TILED", locale, { style: st.Name })),
                                otherActions); });
                        }
                        else {
                            return React.createElement(core_1.ButtonGroup, { vertical: true, fill: true, alignText: "left" },
                                React.createElement(core_1.Button, { onClick: function () { return onAddLayer(layer.Name, layer.queryable, false, undefined); }, intent: core_1.Intent.PRIMARY, icon: "new-layer" }, (0, i18n_1.tr)("ADD_LAYER", locale)),
                                React.createElement(core_1.Button, { onClick: function () { return onAddLayer(layer.Name, layer.queryable, true, undefined); }, intent: core_1.Intent.PRIMARY, icon: "new-layer" }, (0, i18n_1.tr)("ADD_LAYER_TILED", locale)),
                                otherActions);
                        }
                    })());
            })));
};
exports.WmsCapabilitiesPanel = WmsCapabilitiesPanel;


/***/ }),

/***/ "./src/components/legend.tsx":
/*!***********************************!*\
  !*** ./src/components/legend.tsx ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Legend = exports.GroupNode = exports.LayerNode = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var context_1 = __webpack_require__(/*! ./context */ "./src/components/context.ts");
var base_layer_switcher_1 = __webpack_require__(/*! ./base-layer-switcher */ "./src/components/base-layer-switcher.tsx");
var type_guards_1 = __webpack_require__(/*! ../utils/type-guards */ "./src/utils/type-guards.ts");
var icon_1 = __webpack_require__(/*! ./icon */ "./src/components/icon.tsx");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var number_1 = __webpack_require__(/*! ../utils/number */ "./src/utils/number.ts");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
var string_1 = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");
var context_2 = __webpack_require__(/*! ./map-providers/context */ "./src/components/map-providers/context.tsx");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var ICON_LEGEND_LAYER = "layer";
var ICON_SELECT = "select";
var ICON_LC_UNSELECT = "disable";
var ICON_LEGEND_THEME = "multi-select";
var ICON_LEGEND_TOGGLE = "chevron-down";
var ICON_LEGEND_TOGGLE_EXPAND = "chevron-right";
var ICON_LEGEND_RASTER = "media";
var ICON_FOLDER_HORIZONTAL = "folder-close";
var ICON_CLEAR = "cross";
var ICON_SEARCH = "search";
var UL_LIST_STYLE = function (baseSize) { return ({ listStyle: "none", paddingLeft: baseSize + 4, marginTop: 2, marginBottom: 2 }); };
var LI_LIST_STYLE = { listStyle: "none", marginTop: 2, marginBottom: 2 };
var ROW_ITEM_ELEMENT_STYLE = { verticalAlign: "middle" };
var CHK_STYLE = function (baseSize) { return ({ margin: 0, width: baseSize - 2 + "px", height: baseSize - 2 + "px", padding: 1, verticalAlign: "middle" }); };
var EMPTY_STYLE = function (baseSize) { return ({ display: "inline-block", margin: 0, width: baseSize + "px", height: baseSize + "px", verticalAlign: "middle" }); };
var LegendLabel = function (props) {
    var _a;
    var legendCtx = React.useContext(context_1.LegendContext);
    var inner;
    var ft = (_a = legendCtx.getFilterText()) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase();
    if (legendCtx.isFiltering() && !(0, string_1.strIsNullOrEmpty)(ft)) {
        var idx = props.text.toLocaleLowerCase().indexOf(ft);
        if (idx >= 0) {
            inner = props.text.substring(0, idx);
            inner += "<span class='legend-label-highlight-text'>" + props.text.substring(idx, idx + ft.length) + "</span>";
            inner += props.text.substring(idx + ft.length, props.text.length);
        }
        else {
            inner = props.text;
        }
    }
    else {
        inner = props.text;
    }
    return React.createElement("span", { className: "legend-label", style: { lineHeight: props.baseSize + "px", verticalAlign: "middle" }, dangerouslySetInnerHTML: { __html: inner } });
};
function getIconUri(iconMimeType, iconBase64) {
    if (iconMimeType && iconBase64) {
        return "data:" + iconMimeType + ";base64," + iconBase64;
    }
    else {
        return undefined;
    }
}
var EmptyNode = function (props) {
    return React.createElement("div", { style: EMPTY_STYLE(props.baseSize) }, constants_1.NBSP);
};
var RuleNode = function (props) {
    var icon = getIconUri(props.iconMimeType, props.rule.Icon);
    var label = (props.rule.LegendLabel ? props.rule.LegendLabel : "");
    return React.createElement("li", { className: "layer-rule-node", style: LI_LIST_STYLE },
        React.createElement(EmptyNode, { baseSize: props.baseSize }),
        " ",
        React.createElement("img", { style: ROW_ITEM_ELEMENT_STYLE, src: icon }),
        " ",
        React.createElement(LegendLabel, { baseSize: props.baseSize, text: label }));
};
var LayerNode = function (props) {
    var layer = props.layer;
    var legendCtx = React.useContext(context_1.LegendContext);
    var _a = React.useState(legendCtx.getLayerVisibility(props.layer)), layerVisible = _a[0], setLayerVisible = _a[1];
    var label = layer.LegendLabel ? layer.LegendLabel : "";
    var iconMimeType = legendCtx.getIconMimeType();
    var onVisibilityChanged = function (e) {
        setLayerVisible(e.target.checked);
        legendCtx.setLayerVisibility(layer.ObjectId, e.target.checked);
    };
    var onToggleSelectability = function (e) {
        var selectable = getLayerSelectability(layer.ObjectId);
        legendCtx.setLayerSelectability(layer.ObjectId, !selectable);
    };
    var getExpanded = function () {
        var expanded = legendCtx.getLayerExpanded(layer.ObjectId);
        if (expanded == null)
            expanded = layer.ExpandInLegend;
        return expanded;
    };
    var onToggleExpansion = function (e) {
        var expanded = getExpanded();
        legendCtx.setLayerExpanded(layer.ObjectId, !expanded);
    };
    var getLayerSelectability = function (layerId) {
        var selectable = legendCtx.getLayerSelectability(layerId);
        if (selectable == null) {
            selectable = layer.Selectable;
        }
        return selectable;
    };
    var text = label;
    var icon = React.createElement(icon_1.Icon, { baseSize: legendCtx.getBaseIconSize(), style: ROW_ITEM_ELEMENT_STYLE }, function (bs) { return React.createElement(core_1.Icon, { icon: ICON_LEGEND_LAYER, iconSize: bs }); });
    var selectable;
    if (layer.Selectable === true) {
        //NOTE: As we've intercepted the BP icons package, we've re-appropriated the "disable" icon for
        //disabling selection
        selectable = React.createElement(icon_1.Icon, { baseSize: legendCtx.getBaseIconSize(), style: ROW_ITEM_ELEMENT_STYLE, onClick: onToggleSelectability }, function (bs) { return React.createElement(core_1.Icon, { icon: getLayerSelectability(layer.ObjectId) ? ICON_SELECT : ICON_LC_UNSELECT, iconSize: bs }); });
    }
    var chkbox;
    if (layer.Type == 1) { //Dynamic
        chkbox = React.createElement("input", { type: 'checkbox', className: 'layer-checkbox', style: CHK_STYLE(legendCtx.getBaseIconSize()), value: layer.ObjectId, onChange: onVisibilityChanged, checked: (layerVisible) });
    }
    var tooltip = label;
    var nodeClassName = "layer-node";
    var nodeStyle = (0, tslib_1.__assign)({ whiteSpace: "nowrap", overflow: "hidden" }, LI_LIST_STYLE);
    if (layer.ScaleRange) {
        var _loop_1 = function (scaleRange) {
            if (scaleRange.FeatureStyle && scaleRange.FeatureStyle.length > 0) {
                var ruleElements = [];
                //if (debug)
                //    text = label + " (" + scaleRange.MinScale + " - " + scaleRange.MaxScale + ")";
                var body = void 0;
                var isExpanded_1 = getExpanded();
                var totalRuleCount = 0;
                for (var _c = 0, _d = scaleRange.FeatureStyle; _c < _d.length; _c++) {
                    var fts = _d[_c];
                    totalRuleCount += fts.Rule.length;
                }
                if (isExpanded_1 && totalRuleCount > 1) {
                    icon = React.createElement(icon_1.Icon, { baseSize: legendCtx.getBaseIconSize(), style: ROW_ITEM_ELEMENT_STYLE }, function (bs) { return React.createElement(core_1.Icon, { icon: ICON_LEGEND_THEME, iconSize: bs }); });
                    for (var fi = 0; fi < scaleRange.FeatureStyle.length; fi++) {
                        var fts = scaleRange.FeatureStyle[fi];
                        var ftsRuleCount = fts.Rule.length;
                        //Test compression
                        var bCompressed = false;
                        if (ftsRuleCount > 3) {
                            bCompressed = !(fts.Rule[1].Icon);
                        }
                        if (bCompressed) {
                            ruleElements.push(React.createElement(RuleNode, { baseSize: legendCtx.getBaseIconSize(), key: "layer-" + layer.ObjectId + "-style-" + fi + "-rule-first", iconMimeType: iconMimeType, rule: fts.Rule[0] }));
                            ruleElements.push(React.createElement("li", { style: LI_LIST_STYLE, key: "layer-" + layer.ObjectId + "-style-" + fi + "-rule-compressed" },
                                React.createElement(LegendLabel, { baseSize: legendCtx.getBaseIconSize(), text: (0, i18n_1.tr)("OTHER_THEME_RULE_COUNT", legendCtx.getLocale(), { count: ftsRuleCount - 2 }) })));
                            ruleElements.push(React.createElement(RuleNode, { baseSize: legendCtx.getBaseIconSize(), key: "layer-" + layer.ObjectId + "-style-" + fi + "-rule-last", iconMimeType: iconMimeType, rule: fts.Rule[ftsRuleCount - 1] }));
                        }
                        else {
                            for (var i = 0; i < ftsRuleCount; i++) {
                                var rule = fts.Rule[i];
                                ruleElements.push(React.createElement(RuleNode, { baseSize: legendCtx.getBaseIconSize(), key: "layer-" + layer.ObjectId + "-style-" + fi + "-rule-" + i, iconMimeType: iconMimeType, rule: rule }));
                            }
                        }
                    }
                }
                else { //Collapsed
                    if (totalRuleCount > 1) {
                        icon = React.createElement(icon_1.Icon, { style: ROW_ITEM_ELEMENT_STYLE, baseSize: legendCtx.getBaseIconSize() }, function (bs) { return React.createElement(core_1.Icon, { icon: ICON_LEGEND_THEME, iconSize: bs }); });
                    }
                    else {
                        var uri = getIconUri(iconMimeType, scaleRange.FeatureStyle[0].Rule[0].Icon);
                        if (uri) {
                            icon = React.createElement(icon_1.ImageIcon, { style: ROW_ITEM_ELEMENT_STYLE, url: uri });
                        }
                    }
                }
                if (ruleElements.length > 0) {
                    body = React.createElement("ul", { style: UL_LIST_STYLE(legendCtx.getBaseIconSize()) }, ruleElements);
                }
                var expanded = void 0;
                if (totalRuleCount > 1) {
                    expanded = React.createElement(icon_1.Icon, { baseSize: legendCtx.getBaseIconSize(), style: ROW_ITEM_ELEMENT_STYLE, onClick: onToggleExpansion }, function (bs) { return React.createElement(core_1.Icon, { icon: isExpanded_1 ? ICON_LEGEND_TOGGLE : ICON_LEGEND_TOGGLE_EXPAND, iconSize: bs }); });
                }
                else {
                    expanded = React.createElement(EmptyNode, { baseSize: legendCtx.getBaseIconSize() });
                }
                return { value: React.createElement("li", { title: tooltip, style: nodeStyle, className: nodeClassName },
                        expanded,
                        " ",
                        chkbox,
                        " ",
                        selectable,
                        " ",
                        icon,
                        " ",
                        React.createElement(LegendLabel, { baseSize: legendCtx.getBaseIconSize(), text: text }),
                        " ",
                        body) };
            }
            else { //This is generally a raster
                icon = React.createElement(icon_1.Icon, { baseSize: legendCtx.getBaseIconSize(), style: ROW_ITEM_ELEMENT_STYLE }, function (bs) { return React.createElement(core_1.Icon, { icon: ICON_LEGEND_RASTER, iconSize: bs }); });
            }
        };
        for (var _i = 0, _b = layer.ScaleRange; _i < _b.length; _i++) {
            var scaleRange = _b[_i];
            var state_1 = _loop_1(scaleRange);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    return React.createElement("li", { title: tooltip, style: nodeStyle, className: nodeClassName },
        React.createElement(EmptyNode, { baseSize: legendCtx.getBaseIconSize() }),
        " ",
        chkbox,
        " ",
        selectable,
        " ",
        icon,
        " ",
        label);
};
exports.LayerNode = LayerNode;
var ExternalLayerNode = function (_a) {
    var layer = _a.layer;
    var legendCtx = React.useContext(context_1.LegendContext);
    var nodeClassName = "layer-node";
    var nodeStyle = (0, tslib_1.__assign)({ whiteSpace: "nowrap", overflow: "hidden" }, LI_LIST_STYLE);
    var dispatch = (0, context_2.useReduxDispatch)();
    var onVisibilityChanged = function (visible) {
        var activeMapName = legendCtx.getMapName();
        if (activeMapName) {
            dispatch((0, map_1.setMapLayerVisibility)(activeMapName, layer.name, visible));
        }
    };
    var chkbox = React.createElement("input", { type: 'checkbox', className: 'layer-checkbox', style: CHK_STYLE(legendCtx.getBaseIconSize()), onChange: function (e) { return onVisibilityChanged(e.target.checked); }, checked: layer.visible });
    var iconToUse = ICON_LEGEND_LAYER;
    if (layer.type == "WMS") {
        iconToUse = ICON_LEGEND_RASTER;
    }
    var icon = React.createElement(icon_1.Icon, { baseSize: legendCtx.getBaseIconSize(), style: ROW_ITEM_ELEMENT_STYLE }, function (bs) { return React.createElement(core_1.Icon, { icon: iconToUse, iconSize: bs }); });
    return React.createElement("li", { style: nodeStyle, className: nodeClassName },
        chkbox,
        " ",
        icon,
        " ",
        layer.displayName);
};
var ExternalLayersGroupNode = function (_a) {
    var layers = _a.layers;
    var legendCtx = React.useContext(context_1.LegendContext);
    if (layers.length == 0) {
        return React.createElement(React.Fragment, null);
    }
    else {
        var nodeClassName = "group-node";
        var icon = React.createElement(icon_1.Icon, { baseSize: legendCtx.getBaseIconSize(), style: ROW_ITEM_ELEMENT_STYLE }, function (bs) { return React.createElement(core_1.Icon, { icon: ICON_FOLDER_HORIZONTAL, iconSize: bs }); });
        var nodeStyle = (0, tslib_1.__assign)({ whiteSpace: "nowrap", overflow: "hidden" }, LI_LIST_STYLE);
        return React.createElement("li", { style: nodeStyle, className: nodeClassName },
            React.createElement("span", null,
                icon,
                " ",
                React.createElement(LegendLabel, { baseSize: legendCtx.getBaseIconSize(), text: (0, i18n_1.tr)("EXTERNAL_LAYERS", legendCtx.getLocale()) })),
            React.createElement("ul", { style: UL_LIST_STYLE(legendCtx.getBaseIconSize()) }, layers.map(function (layer, i) { return React.createElement(ExternalLayerNode, { key: "external-layer=" + layer.name, layer: layer }); })));
    }
};
var GroupNode = function (props) {
    var group = props.group;
    var legendCtx = React.useContext(context_1.LegendContext);
    var _a = React.useState(legendCtx.getGroupVisibility(group)), groupVisible = _a[0], setGroupVisible = _a[1];
    var getExpanded = function () {
        var expanded = legendCtx.getGroupExpanded(group.ObjectId);
        if (expanded == null)
            expanded = group.ExpandInLegend;
        return expanded;
    };
    var onToggleExpansion = function (e) {
        var expanded = getExpanded();
        legendCtx.setGroupExpanded(group.ObjectId, !expanded);
    };
    var onVisibilityChanged = function (e) {
        setGroupVisible(e.target.checked);
        legendCtx.setGroupVisibility(group.ObjectId, e.target.checked);
    };
    var currentScale = legendCtx.getCurrentScale();
    var tree = legendCtx.getTree();
    var icon = React.createElement(icon_1.Icon, { baseSize: legendCtx.getBaseIconSize(), style: ROW_ITEM_ELEMENT_STYLE }, function (bs) { return React.createElement(core_1.Icon, { icon: ICON_FOLDER_HORIZONTAL, iconSize: bs }); });
    var isExpanded = getExpanded();
    var expanded = React.createElement(icon_1.Icon, { baseSize: legendCtx.getBaseIconSize(), style: ROW_ITEM_ELEMENT_STYLE, onClick: onToggleExpansion }, function (bs) { return React.createElement(core_1.Icon, { icon: isExpanded ? ICON_LEGEND_TOGGLE : ICON_LEGEND_TOGGLE_EXPAND, iconSize: bs }); });
    var chkbox = React.createElement("input", { type: 'checkbox', className: 'group-checkbox', style: CHK_STYLE(legendCtx.getBaseIconSize()), value: group.ObjectId, onChange: onVisibilityChanged, checked: (groupVisible) });
    var tooltip = group.LegendLabel;
    var nodeClassName = "group-node";
    var nodeStyle = (0, tslib_1.__assign)({ whiteSpace: "nowrap", overflow: "hidden" }, LI_LIST_STYLE);
    return React.createElement("li", { title: tooltip, style: nodeStyle, className: nodeClassName },
        React.createElement("span", null,
            expanded,
            " ",
            chkbox,
            " ",
            icon,
            " ",
            React.createElement(LegendLabel, { baseSize: legendCtx.getBaseIconSize(), text: group.LegendLabel })),
        (function () {
            if (isExpanded && props.childItems.length > 0) {
                return React.createElement("ul", { style: UL_LIST_STYLE(legendCtx.getBaseIconSize()) }, props.childItems.map(function (item) {
                    if (item.DisplayInLegend === true) {
                        if ((0, type_guards_1.isLayer)(item)) {
                            if (isLayerVisibleAtScale(item, currentScale, legendCtx.stateless)) {
                                //console.debug(`isLayerVisibleAtScale(${item.Name}, ${currentScale}) = true`);
                                return React.createElement(exports.LayerNode, { key: item.ObjectId, layer: item });
                            }
                        }
                        else {
                            if (isGroupVisibleAtScale(item, tree, currentScale, legendCtx.stateless)) {
                                //console.debug(`isGroupVisibleAtScale(${item.Name}, ${currentScale}) = true`);
                                var children = tree.groupChildren[item.ObjectId] || [];
                                return React.createElement(exports.GroupNode, { key: item.ObjectId, group: item, childItems: children });
                            }
                        }
                    }
                }));
            }
        })());
};
exports.GroupNode = GroupNode;
function isLayerVisibleAtScale(layer, scale, stateless) {
    if (layer.ScaleRange) {
        for (var _i = 0, _a = layer.ScaleRange; _i < _a.length; _i++) {
            var sr = _a[_i];
            if ((0, number_1.scaleRangeBetween)(scale, sr.MinScale, sr.MaxScale)) {
                return true;
            }
        }
    }
    else {
        // In stateless mode, it is potentially expensive to fetch all the required layer defs to get the scale range information,
        // so we must operate under the assumption that such information just doesn't exist, so in such cases assume the layer is
        // visible (in the legend), even if it is not visible (in the map)
        if (stateless) {
            return true;
        }
    }
    return false;
}
function isGroupVisibleAtScale(group, tree, scale, stateless) {
    var children = tree.groupChildren[group.ObjectId] || [];
    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
        var child = children_1[_i];
        if ((0, type_guards_1.isLayer)(child)) {
            if (isLayerVisibleAtScale(child, scale, stateless)) {
                return true;
            }
        }
        else {
            if (isGroupVisibleAtScale(child, tree, scale, stateless)) {
                return true;
            }
        }
    }
    if (stateless) {
        return true;
    }
    return false;
}
function itemTextFilter(items, text) {
    var filtered = items.map(function (i) {
        if ((0, type_guards_1.isLayer)(i)) {
            if (i.LegendLabel.toLocaleLowerCase().indexOf(text) < 0) {
                return null;
            }
            return i;
        }
        else {
            return i;
        }
    }).filter(function (i) { return i != null; });
    return filtered;
}
function buildFilteredTree(tree, text) {
    var filtered = {
        root: itemTextFilter(tree.root, text),
        groupChildren: {}
    };
    var keys = Object.keys(tree.groupChildren);
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var oid = keys_1[_i];
        filtered.groupChildren[oid] = itemTextFilter(tree.groupChildren[oid], text);
    }
    return filtered;
}
function setupTree(map) {
    var _a, _b;
    var state = {
        Layers: (_a = map === null || map === void 0 ? void 0 : map.Layer) !== null && _a !== void 0 ? _a : [],
        Groups: (_b = map === null || map === void 0 ? void 0 : map.Group) !== null && _b !== void 0 ? _b : [],
        LayerMap: {},
        GroupMap: {},
        tree: {
            root: [],
            groupChildren: {}
        }
    };
    if (map === null || map === void 0 ? void 0 : map.Layer) {
        for (var _i = 0, _c = map.Layer; _i < _c.length; _i++) {
            var layer = _c[_i];
            state.LayerMap[layer.ObjectId] = layer;
        }
    }
    if (map === null || map === void 0 ? void 0 : map.Group) {
        for (var _d = 0, _e = map.Group; _d < _e.length; _d++) {
            var group_1 = _e[_d];
            state.GroupMap[group_1.ObjectId] = group_1;
        }
    }
    var Layers = state.Layers, Groups = state.Groups, LayerMap = state.LayerMap, GroupMap = state.GroupMap;
    var _f = state.tree, root = _f.root, groupChildren = _f.groupChildren;
    if (Groups) {
        var remainingGroups = {};
        //1st pass, un-parented groups
        for (var _g = 0, Groups_1 = Groups; _g < Groups_1.length; _g++) {
            var group_2 = Groups_1[_g];
            groupChildren[group_2.ObjectId] = [];
            if (group_2.ParentId) {
                remainingGroups[group_2.ObjectId] = group_2;
                continue;
            }
            root.push(group_2);
        }
        //2nd pass, parented groups
        var itemCount = 0;
        for (var objId in remainingGroups) {
            itemCount++;
        }
        //Whittle down
        while (itemCount > 0) {
            var removeIds = [];
            for (var objId in remainingGroups) {
                var group = remainingGroups[objId];
                //Do we have a parent?
                if (typeof (groupChildren[group.ParentId]) != 'undefined') {
                    if (typeof (groupChildren[group.ObjectId]) != 'undefined') {
                        groupChildren[group.ObjectId] = [];
                    }
                    groupChildren[group.ParentId].push(group);
                    removeIds.push(group.ObjectId);
                }
            }
            for (var _h = 0, removeIds_1 = removeIds; _h < removeIds_1.length; _h++) {
                var id = removeIds_1[_h];
                delete remainingGroups[id];
            }
            itemCount = 0;
            for (var objId in remainingGroups) {
                itemCount++;
            }
        }
    }
    if (Layers) {
        for (var _j = 0, Layers_1 = Layers; _j < Layers_1.length; _j++) {
            var layer = Layers_1[_j];
            if (layer.ParentId) {
                //Do we have a parent?
                if (typeof (groupChildren[layer.ParentId]) === 'undefined') {
                    groupChildren[layer.ParentId] = [];
                }
                groupChildren[layer.ParentId].push(layer);
            }
            else {
                root.push(layer);
            }
        }
    }
    return state;
}
var DEFAULT_ICON_SIZE = 16;
/**
 * The Legend component provides a component to view the layer structure, its styles and thematics and
 * the ability to toggle the group/layer visibility of the current map
 * @param props
 */
var Legend = function (props) {
    var _a;
    var _b = React.useState(setupTree(props.map)), state = _b[0], setState = _b[1];
    var _tree = state.tree;
    var currentScale = props.currentScale, externalBaseLayers = props.externalBaseLayers, onBaseLayerChanged = props.onBaseLayerChanged, maxHeight = props.maxHeight;
    var _c = React.useState(false), isFiltering = _c[0], setIsFiltering = _c[1];
    var _d = React.useState(""), filterText = _d[0], setFilterText = _d[1];
    var _e = React.useState(undefined), filteredTree = _e[0], setFilteredTree = _e[1];
    React.useEffect(function () {
        onExitFilterMode();
        var tree = setupTree(props.map);
        setState(tree);
    }, [props.map]);
    var onEnterFilterMode = function () {
        setIsFiltering(true);
        setFilterText("");
        setFilteredTree(_tree);
    };
    var onExitFilterMode = function () {
        setIsFiltering(false);
        setFilterText("");
        setFilteredTree(undefined);
    };
    var onFilterUpdate = function (text) {
        setFilterText(text);
        if ((0, string_1.strIsNullOrEmpty)(text)) {
            setFilteredTree(_tree);
        }
        else {
            setFilteredTree(buildFilteredTree(_tree, text.toLocaleLowerCase()));
        }
    };
    var getLayerSelectability = function (layerId) {
        var items = props.overrideSelectableLayers || {};
        return items[layerId];
    };
    var setLayerSelectability = function (layerId, selectable) {
        var _a;
        (_a = props.onLayerSelectabilityChanged) === null || _a === void 0 ? void 0 : _a.call(props, layerId, selectable);
    };
    var getGroupExpanded = function (groupId) {
        var items = props.overrideExpandedItems || {};
        return items[groupId];
    };
    var setGroupExpanded = function (groupId, expanded) {
        var _a;
        (_a = props.onGroupExpansionChanged) === null || _a === void 0 ? void 0 : _a.call(props, groupId, expanded);
    };
    var getLayerExpanded = function (layerId) {
        var items = props.overrideExpandedItems || {};
        return items[layerId];
    };
    var setLayerExpanded = function (layerId, expanded) {
        var _a;
        (_a = props.onGroupExpansionChanged) === null || _a === void 0 ? void 0 : _a.call(props, layerId, expanded);
    };
    var getGroupVisibility = function (group) {
        var showGroups = props.showGroups, hideGroups = props.hideGroups;
        var visible = group.Visible;
        if (showGroups && showGroups.indexOf(group.ObjectId) >= 0) {
            visible = true;
        }
        else if (hideGroups && hideGroups.indexOf(group.ObjectId) >= 0) {
            visible = false;
        }
        return visible;
    };
    var getLayerVisibility = function (layer) {
        var showLayers = props.showLayers, hideLayers = props.hideLayers;
        var visible = layer.Visible;
        if (showLayers && showLayers.indexOf(layer.ObjectId) >= 0) {
            visible = true;
        }
        else if (hideLayers && hideLayers.indexOf(layer.ObjectId) >= 0) {
            visible = false;
        }
        return visible;
    };
    var setGroupVisibility = function (groupId, visible) {
        var _a;
        (_a = props.onGroupVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(props, groupId, visible);
    };
    var setLayerVisibility = function (layerId, visible) {
        var _a;
        (_a = props.onLayerVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(props, layerId, visible);
    };
    var getIconMimeType = function () {
        var _a;
        return ((_a = props.map) === null || _a === void 0 ? void 0 : _a.IconMimeType)
            ? "" + props.map.IconMimeType
            : undefined;
    };
    var getChildren = function (objectId) {
        return state.tree.groupChildren[objectId] || [];
    };
    var rootStyle = {
        position: "relative"
    };
    if (maxHeight) {
        rootStyle.maxHeight = maxHeight;
    }
    var providerImpl = {
        stateless: props.stateless,
        isFiltering: function () { return isFiltering; },
        getFilterText: function () { return filterText; },
        getLocale: function () { return props.locale; },
        getMapName: function () { return props.activeMapName; },
        getBaseIconSize: function () { var _a; return (_a = props.baseIconSize) !== null && _a !== void 0 ? _a : DEFAULT_ICON_SIZE; },
        getIconMimeType: getIconMimeType,
        getChildren: getChildren,
        getCurrentScale: function () { return props.currentScale; },
        getTree: function () { return isFiltering && filteredTree ? filteredTree : state.tree; },
        getGroupVisibility: getGroupVisibility,
        getLayerVisibility: getLayerVisibility,
        setGroupVisibility: setGroupVisibility,
        setLayerVisibility: setLayerVisibility,
        getLayerSelectability: getLayerSelectability,
        setLayerSelectability: setLayerSelectability,
        getGroupExpanded: getGroupExpanded,
        setGroupExpanded: setGroupExpanded,
        getLayerExpanded: getLayerExpanded,
        setLayerExpanded: setLayerExpanded
    };
    var daTree = providerImpl.getTree();
    var rootItems = daTree.root;
    return React.createElement(context_1.LegendContext.Provider, { value: providerImpl },
        React.createElement("div", { style: rootStyle },
            (function () {
                if (externalBaseLayers != null &&
                    externalBaseLayers.length > 0 &&
                    props.inlineBaseLayerSwitcher) {
                    return React.createElement(core_1.Card, { style: { marginBottom: 10 } },
                        React.createElement("h5", { className: "bp3-heading" },
                            React.createElement("a", { href: "#" }, (0, i18n_1.tr)("EXTERNAL_BASE_LAYERS", props.locale))),
                        React.createElement(base_layer_switcher_1.BaseLayerSwitcher, { locale: props.locale, externalBaseLayers: externalBaseLayers, onBaseLayerChanged: onBaseLayerChanged }));
                }
            })(),
            (function () {
                if (isFiltering) {
                    return React.createElement(core_1.InputGroup, { round: true, autoFocus: true, leftIcon: ICON_SEARCH, placeholder: (0, i18n_1.tr)("LEGEND_FILTER_LAYERS", props.locale), onChange: function (e) { return onFilterUpdate(e.target.value); }, rightElement: React.createElement(core_1.Button, { minimal: true, icon: ICON_CLEAR, onClick: function () { return onExitFilterMode(); } }) });
                }
                else {
                    return React.createElement(core_1.Button, { onClick: function () { return onEnterFilterMode(); }, title: (0, i18n_1.tr)("LEGEND_FILTER_LAYERS", props.locale), icon: ICON_SEARCH, style: { position: "absolute", right: 0, top: 0 } });
                }
            })(),
            React.createElement("ul", { style: UL_LIST_STYLE((_a = props.baseIconSize) !== null && _a !== void 0 ? _a : DEFAULT_ICON_SIZE) },
                rootItems.map(function (item) {
                    if (item.DisplayInLegend === true) {
                        if ((0, type_guards_1.isLayer)(item)) {
                            if (isLayerVisibleAtScale(item, currentScale, props.stateless)) {
                                //console.debug(`isLayerVisibleAtScale(${item.Name}, ${currentScale}) = true`);
                                return React.createElement(exports.LayerNode, { key: item.ObjectId, layer: item });
                            }
                        }
                        else {
                            var bGroupVisAtScale = isGroupVisibleAtScale(item, daTree, currentScale, props.stateless);
                            var bGroupVisFilter = false;
                            if (providerImpl.isFiltering()) {
                                var bInFilter = item.LegendLabel.toLocaleLowerCase().indexOf(providerImpl.getFilterText().toLocaleLowerCase()) >= 0;
                                //console.log(`'${item.LegendLabel}' - '${providerImpl.getFilterText()}': ${bInFilter ? "true" : "false"}`);
                                if (bInFilter) {
                                    bGroupVisFilter = true;
                                }
                            }
                            if (bGroupVisAtScale || bGroupVisFilter) {
                                //console.debug(`isGroupVisibleAtScale(${item.Name}, ${currentScale}) = true`);
                                var children = daTree.groupChildren[item.ObjectId] || [];
                                return React.createElement(exports.GroupNode, { key: item.ObjectId, group: item, childItems: children });
                            }
                        }
                    }
                }),
                props.externalLayers && React.createElement(ExternalLayersGroupNode, { layers: props.externalLayers }))));
};
exports.Legend = Legend;


/***/ }),

/***/ "./src/components/map-load-indicator.tsx":
/*!***********************************************!*\
  !*** ./src/components/map-load-indicator.tsx ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapLoadIndicator = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var MapLoadIndicator = function (props) {
    var loaded = props.loaded, loading = props.loading, color = props.color, position = props.position;
    var visibility = "visible";
    var pc = Math.min(100, (loaded / loading * 100));
    var width = pc.toFixed(1) + "%";
    if (loaded === loading || pc >= 100) {
        visibility = "hidden";
        width = "0";
    }
    var style = {
        position: "absolute",
        zIndex: 10,
        visibility: visibility,
        left: 0,
        height: 5,
        width: width,
        background: color,
        transition: "width 250ms"
    };
    if (position == "top") {
        style.top = 0;
    }
    else {
        style.bottom = 0;
    }
    return React.createElement("div", { style: style });
};
exports.MapLoadIndicator = MapLoadIndicator;


/***/ }),

/***/ "./src/components/map-menu.tsx":
/*!*************************************!*\
  !*** ./src/components/map-menu.tsx ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapMenu = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
/**
 * The MapMenu component provides the ability to switch between active maps
 * @param props
 */
var MapMenu = function (props) {
    var _a = React.useState(undefined), selected = _a[0], setSelected = _a[1];
    var onActiveMapChanged = function (e) {
        var _a;
        var value = e.currentTarget.value;
        setSelected(value);
        (_a = props.onActiveMapChanged) === null || _a === void 0 ? void 0 : _a.call(props, value);
    };
    return React.createElement("div", null, props.maps.map(function (layer) {
        return React.createElement("div", { className: "map-menu-item-container", key: "base-layer-" + layer.mapName },
            React.createElement("label", { className: "bp3-control bp3-radio" },
                React.createElement("input", { className: "map-menu-option", type: "radio", value: layer.mapName, checked: layer.mapName === props.selectedMap, onChange: onActiveMapChanged }),
                React.createElement("span", { className: "bp3-control-indicator" }),
                layer.label));
    }));
};
exports.MapMenu = MapMenu;


/***/ }),

/***/ "./src/components/map-providers/base.ts":
/*!**********************************************!*\
  !*** ./src/components/map-providers/base.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseMapProviderContext = exports.useViewerSideEffects = exports.isMiddleMouseDownEvent = exports.recursiveFindLayer = exports.inflateBoundsByMeters = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var ReactDOM = (0, tslib_1.__importStar)(__webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"));
var common_1 = __webpack_require__(/*! ../../api/common */ "./src/api/common.ts");
var mouse_1 = __webpack_require__(/*! ../tooltips/mouse */ "./src/components/tooltips/mouse.ts");
var Map_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/Map */ "./node_modules/ol/Map.js"));
var OverviewMap_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/control/OverviewMap */ "./node_modules/ol/control/OverviewMap.js"));
var DragBox_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/DragBox */ "./node_modules/ol/interaction/DragBox.js"));
var Select_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/Select */ "./node_modules/ol/interaction/Select.js"));
var Draw_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/Draw */ "./node_modules/ol/interaction/Draw.js"));
var selected_features_1 = __webpack_require__(/*! ../tooltips/selected-features */ "./src/components/tooltips/selected-features.ts");
var Feature_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/Feature */ "./node_modules/ol/Feature.js"));
var Polygon_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/Polygon */ "./node_modules/ol/geom/Polygon.js"));
var Attribution_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/control/Attribution */ "./node_modules/ol/control/Attribution.js"));
var Rotate_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/control/Rotate */ "./node_modules/ol/control/Rotate.js"));
var DragRotate_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/DragRotate */ "./node_modules/ol/interaction/DragRotate.js"));
var DragPan_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/DragPan */ "./node_modules/ol/interaction/DragPan.js"));
var PinchRotate_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/PinchRotate */ "./node_modules/ol/interaction/PinchRotate.js"));
var PinchZoom_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/PinchZoom */ "./node_modules/ol/interaction/PinchZoom.js"));
var KeyboardPan_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/KeyboardPan */ "./node_modules/ol/interaction/KeyboardPan.js"));
var KeyboardZoom_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/KeyboardZoom */ "./node_modules/ol/interaction/KeyboardZoom.js"));
var MouseWheelZoom_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/MouseWheelZoom */ "./node_modules/ol/interaction/MouseWheelZoom.js"));
var View_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/View */ "./node_modules/ol/View.js"));
var GeometryType_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/GeometryType */ "./node_modules/ol/geom/GeometryType.js"));
var proj_1 = __webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js");
var layer_manager_1 = __webpack_require__(/*! ../../api/layer-manager */ "./src/api/layer-manager.ts");
var olExtent = (0, tslib_1.__importStar)(__webpack_require__(/*! ol/extent */ "./node_modules/ol/extent.js"));
var olEasing = (0, tslib_1.__importStar)(__webpack_require__(/*! ol/easing */ "./node_modules/ol/easing.js"));
var i18n_1 = __webpack_require__(/*! ../../api/i18n */ "./src/api/i18n.ts");
var assert_1 = __webpack_require__(/*! ../../utils/assert */ "./src/utils/assert.ts");
var logger_1 = __webpack_require__(/*! ../../utils/logger */ "./src/utils/logger.ts");
var map_1 = __webpack_require__(/*! ../../actions/map */ "./src/actions/map.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var ol_factory_1 = __webpack_require__(/*! ../../api/ol-factory */ "./src/api/ol-factory.ts");
var ismobilejs_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ismobilejs */ "./node_modules/ismobilejs/esm/index.js"));
var Group_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Group */ "./node_modules/ol/layer/Group.js"));
var ol_style_contracts_1 = __webpack_require__(/*! ../../api/ol-style-contracts */ "./src/api/ol-style-contracts.ts");
var ol_style_helpers_1 = __webpack_require__(/*! ../../api/ol-style-helpers */ "./src/api/ol-style-helpers.ts");
var runtime_1 = __webpack_require__(/*! ../../api/runtime */ "./src/api/runtime.ts");
var client_1 = __webpack_require__(/*! ../../api/client */ "./src/api/client.ts");
var context_1 = __webpack_require__(/*! ./context */ "./src/components/map-providers/context.tsx");
function isValidView(view) {
    if (view.resolution) {
        return !isNaN(view.x)
            && !isNaN(view.y)
            && !isNaN(view.scale)
            && !isNaN(view.resolution);
    }
    else {
        return !isNaN(view.x)
            && !isNaN(view.y)
            && !isNaN(view.scale);
    }
}
function inflateBoundsByMeters(thisProj, extent, meters) {
    // We need to inflate this bbox by a known unit of measure (meters), so re-project this extent to a meter's based coordinate system (EPSG:3857)
    var webmBounds = (0, proj_1.transformExtent)(extent, thisProj, "EPSG:3857");
    // Inflate the box by specified amount
    var webmBounds2 = olExtent.buffer(webmBounds, meters);
    // Re-project this extent back to the original projection
    var inflatedBounds = (0, proj_1.transformExtent)(webmBounds2, "EPSG:3857", thisProj);
    return inflatedBounds;
}
exports.inflateBoundsByMeters = inflateBoundsByMeters;
function recursiveFindLayer(layers, predicate) {
    for (var i = 0; i < layers.getLength(); i++) {
        var layer = layers.item(i);
        if (layer instanceof Group_1.default) {
            var match = recursiveFindLayer(layer.getLayers(), predicate);
            if (match) {
                return match;
            }
        }
        else {
            if (predicate(layer)) {
                return layer;
            }
        }
    }
    return undefined;
}
exports.recursiveFindLayer = recursiveFindLayer;
function isMiddleMouseDownEvent(e) {
    return (e && (e.which == 2 || e.button == 4));
}
exports.isMiddleMouseDownEvent = isMiddleMouseDownEvent;
function useViewerSideEffects(context, appSettings, isReady, mapName, layers, initialExternalLayers, agentUri, agentKind, selection) {
    if (agentUri === void 0) { agentUri = undefined; }
    if (agentKind === void 0) { agentKind = undefined; }
    if (selection === void 0) { selection = null; }
    var dispatch = (0, context_1.useReduxDispatch)();
    // Side-effect to pre-load external layers. Should only happen once per map name
    React.useEffect(function () {
        if (isReady) {
            if (mapName && !layers) {
                (0, logger_1.debug)("React.useEffect - Change of initial external layers for [" + mapName + "] (change should only happen once per mapName!)");
                if (initialExternalLayers && initialExternalLayers.length > 0) {
                    (0, logger_1.debug)("React.useEffect - First-time loading of external layers for [" + mapName + "]");
                    var layerManager = context.getLayerManager(mapName);
                    for (var _i = 0, initialExternalLayers_1 = initialExternalLayers; _i < initialExternalLayers_1.length; _i++) {
                        var extLayer = initialExternalLayers_1[_i];
                        var added = layerManager.addExternalLayer(extLayer, true, appSettings);
                        if (added) {
                            dispatch((0, map_1.mapLayerAdded)(mapName, added));
                        }
                    }
                }
                else {
                    //Even if no initial external layers were loaded, the layers state still needs to be set
                    //otherwise components that depend on this state (eg. External Layer Manager) will assume
                    //this is still not ready yet
                    (0, logger_1.debug)("React.useEffect - Signal that external layers are ready for [" + mapName + "]");
                    dispatch((0, map_1.externalLayersReady)(mapName));
                }
            }
        }
    }, [context, mapName, initialExternalLayers, layers, isReady]);
    // Side-effect to apply the current external layer list
    React.useEffect(function () {
        (0, logger_1.debug)("React.useEffect - Change of external layers");
        if (context.isReady() && layers) {
            var layerManager = context.getLayerManager(mapName);
            layerManager.apply(layers);
        }
    }, [context, mapName, layers]);
    // Side-effect to set the viewer "instance" once the MapViewerBase component has been mounted.
    // Should only happen once.
    React.useEffect(function () {
        (0, logger_1.debug)("React.useEffect - Change of context and/or agent URI/kind");
        (0, runtime_1.setViewer)(context);
        var browserWindow = window;
        browserWindow.getViewer = browserWindow.getViewer || runtime_1.getViewer;
        if (agentUri && agentKind) {
            browserWindow.getClient = browserWindow.getClient || (function () { return new client_1.Client(agentUri, agentKind); });
        }
        (0, logger_1.debug)("React.useEffect - Attached runtime viewer instance and installed browser global APIs");
    }, [context, agentUri, agentKind]);
    // Side-effect to imperatively refresh the map upon selection change
    React.useEffect(function () {
        (0, logger_1.debug)("React.useEffect - Change of selection");
        context.refreshMap(common_1.RefreshMode.SelectionOnly);
    }, [context, selection]);
}
exports.useViewerSideEffects = useViewerSideEffects;
var BaseMapProviderContext = /** @class */ (function () {
    function BaseMapProviderContext(olFactory) {
        var _this = this;
        if (olFactory === void 0) { olFactory = new ol_factory_1.OLFactory(); }
        this.olFactory = olFactory;
        this.onBeginDigitization = function (callback) {
            var _a;
            (_a = _this._comp) === null || _a === void 0 ? void 0 : _a.onDispatch((0, map_1.setActiveTool)(common_1.ActiveMapTool.None));
            //Could be a small timing issue here, but the active tool should generally
            //be "None" before the user clicks their first digitizing vertex/point
            callback(false);
        };
        this.onResize = function (e) {
            var _a;
            if (_this._map) {
                var size = _this._map.getSize();
                if (size) {
                    var w = size[0], h = size[1];
                    (_a = _this._comp) === null || _a === void 0 ? void 0 : _a.onDispatch((0, map_1.mapResized)(w, h));
                }
            }
        };
        this._busyWorkers = 0;
        this._layerSetGroups = {};
        this._tileSourceLoaders = {};
        this._imageSourceLoaders = {};
        this._wmsQueryAugmentations = {};
        this._triggerZoomRequestOnMoveEnd = true;
        var ism = (0, ismobilejs_1.default)(navigator.userAgent);
        this._supportsTouch = ism.phone || ism.tablet;
        var baseInitialState = {
            activeTool: common_1.ActiveMapTool.None,
            view: undefined,
            viewRotation: 0,
            viewRotationEnabled: true,
            locale: i18n_1.DEFAULT_LOCALE,
            cancelDigitizationKey: common_1.KC_ESCAPE,
            undoLastPointKey: common_1.KC_U,
            mapName: undefined,
            externalBaseLayers: undefined,
            initialExternalLayers: []
        };
        this._state = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, baseInitialState), this.getInitialProviderState());
    }
    /**
     * Exports an image of the current map view
     *
     * @param {IMapImageExportOptions} options
     * @memberof IMapViewer
     * @since 0.14
     */
    BaseMapProviderContext.prototype.exportImage = function (options) {
        if (this._map) {
            var map_2 = this._map;
            map_2.once('rendercomplete', function () {
                var mapCanvas = document.createElement('canvas');
                if (options.size) {
                    var _a = options.size, w = _a[0], h = _a[1];
                    mapCanvas.width = w;
                    mapCanvas.height = h;
                }
                else {
                    var size = map_2.getSize();
                    if (size) {
                        mapCanvas.width = size[0];
                        mapCanvas.height = size[1];
                    }
                }
                var mapContext = mapCanvas.getContext('2d');
                if (mapContext) {
                    var canvasSelector = '.ol-layer canvas, .external-vector-layer canvas';
                    Array.prototype.forEach.call(document.querySelectorAll(canvasSelector), function (canvas) {
                        var _a, _b, _c, _d, _e, _f;
                        if (canvas.width > 0) {
                            var parentNode = canvas.parentNode;
                            var opacity = (_c = (_b = (_a = parentNode) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.opacity) !== null && _c !== void 0 ? _c : "";
                            mapContext.globalAlpha = opacity === '' ? 1 : Number(opacity);
                            var transform = canvas.style.transform;
                            // Get the transform parameters from the style's transform matrix
                            var matrix = (_f = (_e = (_d = transform.match(/^matrix\(([^\(]*)\)$/)) === null || _d === void 0 ? void 0 : _d[1]) === null || _e === void 0 ? void 0 : _e.split(',')) === null || _f === void 0 ? void 0 : _f.map(Number);
                            if (matrix) {
                                // Apply the transform to the export map context
                                CanvasRenderingContext2D.prototype.setTransform.apply(mapContext, matrix);
                                mapContext.drawImage(canvas, 0, 0);
                            }
                        }
                    });
                    options.callback(mapCanvas.toDataURL(options.exportMimeType));
                }
            });
            map_2.renderSync();
        }
    };
    /**
     * Adds a custom tile load function for a given base image tile layer.
     *
     * NOTE: Unlike other load function registrations this must be done before the viewer is mounted. New load functions added at runtime will not be recognized
     * @param mapName
     * @param layerName The base layer this function should apply for
     * @param func The custom tile load function
     * @since 0.14
     */
    BaseMapProviderContext.prototype.addBaseTileLoadFunction = function (mapName, layerName, func) {
        if (!this._baseTileSourceLoaders) {
            this._baseTileSourceLoaders = {};
        }
        if (!this._baseTileSourceLoaders[mapName]) {
            this._baseTileSourceLoaders[mapName] = {};
        }
        this._baseTileSourceLoaders[mapName][layerName] = func;
    };
    /**
     * Adds a custom tile load function for a given overlay image tile layer
     * @param mapName
     * @param layerName The layer this function should apply for
     * @param func The custom tile load function
     * @since 0.14
     */
    BaseMapProviderContext.prototype.addTileLoadFunction = function (mapName, layerName, func) {
        if (!this._tileSourceLoaders) {
            this._tileSourceLoaders = {};
        }
        if (!this._tileSourceLoaders[mapName]) {
            this._tileSourceLoaders[mapName] = {};
        }
        this._tileSourceLoaders[mapName][layerName] = func;
    };
    /**
     * Adds a custom image load function for a given overlay image layer
     * @param mapName
     * @param layerName The layer this function should apply for
     * @param func The custom tile load function
     * @since 0.14
     */
    BaseMapProviderContext.prototype.addImageLoadFunction = function (mapName, layerName, func) {
        if (!this._imageSourceLoaders) {
            this._imageSourceLoaders = {};
        }
        if (!this._imageSourceLoaders[mapName]) {
            this._imageSourceLoaders[mapName] = {};
        }
        this._imageSourceLoaders[mapName][layerName] = func;
    };
    /**
     * Adds a WMS query augmentation for the given WMS overlay layer
     * @param mapName
     * @param layerName The layer this function should apply for
     * @param func The WMS query augmentation
     * @since 0.14
     */
    BaseMapProviderContext.prototype.addWmsQueryAugmentation = function (mapName, layerName, func) {
        if (!this._wmsQueryAugmentations) {
            this._wmsQueryAugmentations = {};
        }
        if (!this._wmsQueryAugmentations[mapName]) {
            this._wmsQueryAugmentations[mapName] = {};
        }
        this._wmsQueryAugmentations[mapName][layerName] = func;
    };
    BaseMapProviderContext.prototype.addCustomSelectionPopupRenderer = function (mapName, layerName, renderer) {
        if (mapName && layerName) {
            if (!this._customSelectionPopupRenderers) {
                this._customSelectionPopupRenderers = {};
            }
            if (!this._customSelectionPopupRenderers[mapName]) {
                this._customSelectionPopupRenderers[mapName] = {};
            }
            this._customSelectionPopupRenderers[mapName][layerName] = renderer;
        }
        else {
            this._globalCustomSelectionPopupRenderer = renderer;
        }
    };
    BaseMapProviderContext.prototype.getSelectionPopupRenderer = function (layerName) {
        if (!this._customSelectionPopupRenderers) {
            this._customSelectionPopupRenderers = {};
        }
        var mapName = this._state.mapName;
        if (mapName) {
            if (!this._customSelectionPopupRenderers[mapName]) {
                this._customSelectionPopupRenderers[mapName] = {};
            }
            var r = this._customSelectionPopupRenderers[mapName][layerName];
            if (r) {
                return r;
            }
        }
        if (this._globalCustomSelectionPopupRenderer) {
            return this._globalCustomSelectionPopupRenderer;
        }
        return undefined;
    };
    /**
     * @virtual
     */
    BaseMapProviderContext.prototype.hideAllPopups = function () {
        var _a, _b;
        (_a = this._mouseTooltip) === null || _a === void 0 ? void 0 : _a.clear();
        (_b = this._selectTooltip) === null || _b === void 0 ? void 0 : _b.hide();
    };
    BaseMapProviderContext.prototype.isReady = function () { return !!(this._map && this._comp); };
    //#region IMapViewer
    /**
     * @virtual
     * @returns {(IMapGuideViewerSupport | undefined)}
     * @memberof BaseMapProviderContext
     */
    BaseMapProviderContext.prototype.mapguideSupport = function () {
        return undefined;
    };
    BaseMapProviderContext.prototype.setActiveTool = function (tool) {
        var _a;
        (_a = this._comp) === null || _a === void 0 ? void 0 : _a.onDispatch((0, map_1.setActiveTool)(tool));
    };
    BaseMapProviderContext.prototype.getOLFactory = function () {
        return this.olFactory;
    };
    BaseMapProviderContext.prototype.getMapName = function () {
        return this._state.mapName;
    };
    BaseMapProviderContext.prototype.setViewRotation = function (rotation) {
        var _a;
        (_a = this._comp) === null || _a === void 0 ? void 0 : _a.onDispatch((0, map_1.setViewRotation)(rotation));
    };
    BaseMapProviderContext.prototype.getViewRotation = function () {
        return this._state.viewRotation;
    };
    BaseMapProviderContext.prototype.isViewRotationEnabled = function () {
        return this._state.viewRotationEnabled;
    };
    BaseMapProviderContext.prototype.setViewRotationEnabled = function (enabled) {
        var _a;
        (_a = this._comp) === null || _a === void 0 ? void 0 : _a.onDispatch((0, map_1.setViewRotationEnabled)(enabled));
    };
    BaseMapProviderContext.prototype.toastSuccess = function (iconName, message) {
        var _a, _b;
        return (_b = (_a = this._toasterRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.show({ icon: iconName, message: message, intent: core_1.Intent.SUCCESS });
    };
    BaseMapProviderContext.prototype.toastWarning = function (iconName, message) {
        var _a, _b;
        return (_b = (_a = this._toasterRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.show({ icon: iconName, message: message, intent: core_1.Intent.WARNING });
    };
    BaseMapProviderContext.prototype.toastError = function (iconName, message) {
        var _a, _b;
        return (_b = (_a = this._toasterRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.show({ icon: iconName, message: message, intent: core_1.Intent.DANGER });
    };
    BaseMapProviderContext.prototype.toastPrimary = function (iconName, message) {
        var _a, _b;
        return (_b = (_a = this._toasterRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.show({ icon: iconName, message: message, intent: core_1.Intent.PRIMARY });
    };
    BaseMapProviderContext.prototype.dismissToast = function (key) {
        var _a, _b;
        (_b = (_a = this._toasterRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.dismiss(key);
    };
    BaseMapProviderContext.prototype.addImageLoading = function () {
        var _a;
        (_a = this._comp) === null || _a === void 0 ? void 0 : _a.addImageLoading();
    };
    BaseMapProviderContext.prototype.addImageLoaded = function () {
        var _a;
        (_a = this._comp) === null || _a === void 0 ? void 0 : _a.addImageLoaded();
    };
    BaseMapProviderContext.prototype.addSubscribers = function (props) {
        var _a, _b;
        return (_b = (_a = this._comp) === null || _a === void 0 ? void 0 : _a.addSubscribers(props)) !== null && _b !== void 0 ? _b : [];
    };
    BaseMapProviderContext.prototype.removeSubscribers = function (names) {
        var _a, _b;
        return (_b = (_a = this._comp) === null || _a === void 0 ? void 0 : _a.removeSubscribers(names)) !== null && _b !== void 0 ? _b : false;
    };
    BaseMapProviderContext.prototype.getSubscribers = function () {
        var _a, _b;
        return (_b = (_a = this._comp) === null || _a === void 0 ? void 0 : _a.getSubscribers()) !== null && _b !== void 0 ? _b : [];
    };
    BaseMapProviderContext.prototype.dispatch = function (action) {
        var _a;
        (_a = this._comp) === null || _a === void 0 ? void 0 : _a.onDispatch(action);
    };
    BaseMapProviderContext.prototype.getDefaultPointCircleStyle = function () {
        return (0, tslib_1.__assign)({}, ol_style_contracts_1.DEFAULT_POINT_CIRCLE_STYLE);
    };
    BaseMapProviderContext.prototype.getDefaultPointIconStyle = function () {
        return (0, tslib_1.__assign)({}, ol_style_contracts_1.DEFAULT_POINT_ICON_STYLE);
    };
    BaseMapProviderContext.prototype.getDefaultLineStyle = function () {
        return (0, tslib_1.__assign)({}, ol_style_contracts_1.DEFAULT_LINE_STYLE);
    };
    BaseMapProviderContext.prototype.getDefaultPolygonStyle = function () {
        return (0, tslib_1.__assign)({}, ol_style_contracts_1.DEFAULT_POLY_STYLE);
    };
    BaseMapProviderContext.prototype.getBaseTileSourceLoaders = function (mapName) {
        var _a, _b;
        return (_b = (_a = this._baseTileSourceLoaders) === null || _a === void 0 ? void 0 : _a[mapName]) !== null && _b !== void 0 ? _b : {};
    };
    BaseMapProviderContext.prototype.getTileSourceLoaders = function (mapName) {
        var _a, _b;
        return (_b = (_a = this._tileSourceLoaders) === null || _a === void 0 ? void 0 : _a[mapName]) !== null && _b !== void 0 ? _b : {};
    };
    BaseMapProviderContext.prototype.getImageSourceLoaders = function (mapName) {
        var _a, _b;
        return (_b = (_a = this._imageSourceLoaders) === null || _a === void 0 ? void 0 : _a[mapName]) !== null && _b !== void 0 ? _b : {};
    };
    //#region IMapViewerContextCallback
    BaseMapProviderContext.prototype.getMockMode = function () { return undefined; };
    BaseMapProviderContext.prototype.addFeatureToHighlight = function (feat, bAppend) {
        var _a;
        if (this._state.mapName) {
            // Features have to belong to layer in order to be visible and have the highlight style, 
            // so in addition to adding this new feature to the OL select observable collection, we 
            // need to also add the feature to a scratch vector layer dedicated for this purpose
            var layerSet = this.getLayerSetGroup(this._state.mapName);
            if (layerSet) {
                var sf = (_a = this._select) === null || _a === void 0 ? void 0 : _a.getFeatures();
                if (sf) {
                    if (!bAppend) {
                        sf.clear();
                    }
                    if (feat) {
                        sf.push(feat);
                    }
                }
            }
        }
    };
    //#endregion
    //#region Map Context
    BaseMapProviderContext.prototype.getScaleForExtent = function (bounds) {
        (0, assert_1.assertIsDefined)(this._map);
        (0, assert_1.assertIsDefined)(this._state.mapName);
        var activeLayerSet = this.getLayerSetGroup(this._state.mapName);
        (0, assert_1.assertIsDefined)(activeLayerSet);
        var size = this._map.getSize();
        (0, assert_1.assertIsDefined)(size);
        var mcsW = olExtent.getWidth(bounds);
        var mcsH = olExtent.getHeight(bounds);
        var devW = size[0];
        var devH = size[1];
        var metersPerPixel = 0.0254 / activeLayerSet.getDpi();
        var metersPerUnit = activeLayerSet.getMetersPerUnit();
        //Scale calculation code from AJAX viewer
        var mapScale;
        if (devH * mcsW > devW * mcsH)
            mapScale = mcsW * metersPerUnit / (devW * metersPerPixel); // width-limited
        else
            mapScale = mcsH * metersPerUnit / (devH * metersPerPixel); // height-limited
        return mapScale;
    };
    BaseMapProviderContext.prototype.getViewForExtent = function (extent) {
        (0, assert_1.assertIsDefined)(this._map);
        var scale, center;
        // If this is a zero-width/height extent, we need to "inflate" it to something small
        // so that we do not enter an infinite loop due to attempting to get a x/y/scale from
        // a zero-width/height extent.
        //
        // This generally happens if we want to zoom to the bounds of a selected point
        if (olExtent.getWidth(extent) == 0 || olExtent.getHeight(extent) == 0) {
            var thisProj = this.getProjection();
            // Inflate the box by 20 meters
            var inflatedBounds = inflateBoundsByMeters(thisProj, extent, 20);
            // Now we can safely extract the scale/center
            scale = this.getScaleForExtent(inflatedBounds);
            center = olExtent.getCenter(inflatedBounds);
        }
        else {
            scale = this.getScaleForExtent(extent);
            center = olExtent.getCenter(extent);
        }
        return {
            x: center[0],
            y: center[1],
            scale: scale,
            resolution: this._map.getView().getResolution()
        };
    };
    BaseMapProviderContext.prototype.onZoomSelectBox = function (e) {
        var _a;
        if (this._comp) {
            var extent = (_a = this._zoomSelectBox) === null || _a === void 0 ? void 0 : _a.getGeometry();
            if (!extent) {
                return;
            }
            switch (this._state.activeTool) {
                case common_1.ActiveMapTool.Zoom:
                    {
                        var ext = extent.getExtent();
                        this._comp.onDispatch((0, map_1.setCurrentView)(this.getViewForExtent(ext)));
                    }
                    break;
                case common_1.ActiveMapTool.Select:
                    {
                        this.selectFeaturesByExtent(extent);
                    }
                    break;
            }
        }
    };
    /**
     * @virtual
     * @protected
     * @param {GenericEvent} e
     * @returns
     * @memberof BaseMapProviderContext
     */
    BaseMapProviderContext.prototype.onMouseMove = function (e) {
        if (this._comp) {
            this.handleMouseTooltipMouseMove(e);
            this.handleHighlightHover(e);
            if (this._comp.isContextMenuOpen()) {
                return;
            }
            if (this._state.mapName) {
                this._comp.onDispatch((0, map_1.setMouseCoordinates)(this._state.mapName, e.coord));
            }
        }
    };
    BaseMapProviderContext.prototype.incrementBusyWorker = function () {
        var _a;
        this._busyWorkers++;
        (_a = this._comp) === null || _a === void 0 ? void 0 : _a.onDispatch((0, map_1.setBusyCount)(this._busyWorkers));
    };
    BaseMapProviderContext.prototype.decrementBusyWorker = function () {
        var _a;
        this._busyWorkers--;
        (_a = this._comp) === null || _a === void 0 ? void 0 : _a.onDispatch((0, map_1.setBusyCount)(this._busyWorkers));
    };
    BaseMapProviderContext.prototype.applyView = function (layerSet, vw) {
        this._triggerZoomRequestOnMoveEnd = false;
        layerSet.getView().setCenter([vw.x, vw.y]);
        //Don't use this.scaleToResolution() as that uses this.props to determine
        //applicable layer set, but we already have that here
        var res = layerSet.scaleToResolution(vw.scale);
        layerSet.getView().setResolution(res);
        this._triggerZoomRequestOnMoveEnd = true;
    };
    BaseMapProviderContext.prototype.removeActiveDrawInteraction = function () {
        if (this._activeDrawInteraction && this._map && this._comp) {
            this._map.removeInteraction(this._activeDrawInteraction);
            this._activeDrawInteraction = null;
            this._comp.setDigitizingType(undefined);
        }
    };
    BaseMapProviderContext.prototype.getActiveTool = function () { return this._state.activeTool; };
    BaseMapProviderContext.prototype.cancelDigitization = function () {
        if (this.isDigitizing()) {
            this.removeActiveDrawInteraction();
            this.clearMouseTooltip();
            //this._mouseTooltip.clear();
        }
    };
    BaseMapProviderContext.prototype.pushDrawInteraction = function (digitizingType, draw, handler, prompt) {
        var _this = this;
        (0, assert_1.assertIsDefined)(this._comp);
        this.onBeginDigitization(function (cancel) {
            if (!cancel) {
                (0, assert_1.assertIsDefined)(_this._map);
                (0, assert_1.assertIsDefined)(_this._comp);
                _this.removeActiveDrawInteraction();
                //this._mouseTooltip.clear();
                _this.clearMouseTooltip();
                if (prompt) {
                    //this._mouseTooltip.setText(prompt);
                    _this.setMouseTooltip(prompt);
                }
                _this._activeDrawInteraction = draw;
                _this._activeDrawInteraction.once("drawend", function (e) {
                    var drawnFeature = e.feature;
                    var geom = drawnFeature.getGeometry();
                    _this.cancelDigitization();
                    handler(geom);
                });
                _this._map.addInteraction(_this._activeDrawInteraction);
                _this._comp.setDigitizingType(digitizingType);
            }
        });
    };
    /**
     * @virtual
     * @protected
     * @param {Polygon} geom
     * @memberof BaseMapProviderContext
     */
    BaseMapProviderContext.prototype.selectFeaturesByExtent = function (geom) { };
    BaseMapProviderContext.prototype.zoomByDelta = function (delta) {
        (0, assert_1.assertIsDefined)(this._map);
        var view = this._map.getView();
        if (!view) {
            return;
        }
        var currentZoom = view.getZoom();
        if (currentZoom !== undefined) {
            var newZoom = view.getConstrainedZoom(currentZoom + delta);
            if (view.getAnimating()) {
                view.cancelAnimations();
            }
            view.animate({
                zoom: newZoom,
                duration: 250,
                easing: olEasing.easeOut
            });
        }
    };
    BaseMapProviderContext.prototype.ensureAndGetLayerSetGroup = function (nextState) {
        (0, assert_1.assertIsDefined)(nextState.mapName);
        var layerSet = this._layerSetGroups[nextState.mapName];
        if (!layerSet) {
            layerSet = this.initLayerSet(nextState);
            this._layerSetGroups[nextState.mapName] = layerSet;
        }
        return layerSet;
    };
    //public getLayerSet(name: string, bCreate: boolean = false, props?: IMapViewerContextProps): MgLayerSet {
    BaseMapProviderContext.prototype.getLayerSetGroup = function (name) {
        var layerSet;
        if (name) {
            layerSet = this._layerSetGroups[name];
            /*
            if (!layerSet && props && bCreate) {
                layerSet = this.initLayerSet(props);
                this._layerSets[props.map.Name] = layerSet;
                this._activeMapName = props.map.Name;
            }
            */
        }
        return layerSet;
    };
    /**
     * @virtual
     * @readonly
     * @memberof BaseMapProviderContext
     */
    BaseMapProviderContext.prototype.isMouseOverTooltip = function () { var _a, _b; return (_b = (_a = this._selectTooltip) === null || _a === void 0 ? void 0 : _a.isMouseOver) !== null && _b !== void 0 ? _b : false; };
    BaseMapProviderContext.prototype.clearMouseTooltip = function () {
        var _a;
        (_a = this._mouseTooltip) === null || _a === void 0 ? void 0 : _a.clear();
    };
    BaseMapProviderContext.prototype.setMouseTooltip = function (text) {
        var _a;
        (_a = this._mouseTooltip) === null || _a === void 0 ? void 0 : _a.setText(text);
    };
    BaseMapProviderContext.prototype.handleMouseTooltipMouseMove = function (e) {
        var _a, _b;
        (_b = (_a = this._mouseTooltip) === null || _a === void 0 ? void 0 : _a.onMouseMove) === null || _b === void 0 ? void 0 : _b.call(_a, e);
    };
    BaseMapProviderContext.prototype.isLayerHoverable = function (layer) {
        return !((layer === null || layer === void 0 ? void 0 : layer.get(common_1.LayerProperty.IS_HOVER_HIGHLIGHT)) == true)
            && !((layer === null || layer === void 0 ? void 0 : layer.get(common_1.LayerProperty.IS_WMS_SELECTION_OVERLAY)) == true)
            && !((layer === null || layer === void 0 ? void 0 : layer.get(common_1.LayerProperty.IS_HEATMAP)) == true)
            && !((layer === null || layer === void 0 ? void 0 : layer.get(common_1.LayerProperty.IS_MEASURE)) == true);
    };
    BaseMapProviderContext.prototype.handleHighlightHover = function (e) {
        var _this = this;
        if (e.dragging) {
            return;
        }
        if (this._state.mapName && this._map) {
            var activeLayerSet = this.getLayerSetGroup(this._state.mapName);
            if (activeLayerSet) {
                var pixel = this._map.getEventPixel(e.originalEvent);
                if (pixel) {
                    var featureToLayerMap_1 = [];
                    this._map.forEachFeatureAtPixel(pixel, function (feature, layer) {
                        if (_this.isLayerHoverable(layer) && feature instanceof Feature_1.default) {
                            featureToLayerMap_1.push([feature, layer]);
                        }
                    });
                    var feature = featureToLayerMap_1.length ? featureToLayerMap_1[0][0] : undefined;
                    //const featuresAtPixel = this._map?.getFeaturesAtPixel(pixel);
                    //const feature = featuresAtPixel?.length ? featuresAtPixel[0] : undefined;
                    if (feature != this._highlightedFeature && feature instanceof Feature_1.default) {
                        if (this._highlightedFeature) {
                            activeLayerSet.removeHighlightedFeature(this._highlightedFeature);
                        }
                        if (feature) {
                            activeLayerSet.addHighlightedFeature(feature);
                        }
                        this._highlightedFeature = feature;
                    }
                }
            }
        }
    };
    BaseMapProviderContext.prototype.hideSelectedVectorFeaturesTooltip = function () {
        var _a;
        (_a = this._selectTooltip) === null || _a === void 0 ? void 0 : _a.hide();
    };
    BaseMapProviderContext.prototype.showSelectedVectorFeatures = function (features, pixel, featureToLayerMap, locale) {
        var _a;
        (_a = this._selectTooltip) === null || _a === void 0 ? void 0 : _a.showSelectedVectorFeatures(features, pixel, featureToLayerMap, locale);
    };
    BaseMapProviderContext.prototype.queryWmsFeatures = function (mapName, coord, bAppendMode) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var activeLayerSet, layerMgr, res;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(mapName && this._map)) return [3 /*break*/, 2];
                        activeLayerSet = this.getLayerSetGroup(mapName);
                        layerMgr = this.getLayerManager(mapName);
                        res = this._map.getView().getResolution();
                        if (!(res && this._selectTooltip)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._selectTooltip.queryWmsFeatures(activeLayerSet, layerMgr, coord, res, bAppendMode, {
                                getLocale: function () { return _this._state.locale; },
                                addClientSelectedFeature: function (feat, layer) { return _this.addClientSelectedFeature(feat, layer); },
                                addFeatureToHighlight: function (feat, bAppend) { return _this.addFeatureToHighlight(feat, bAppend); },
                                getWmsRequestAugmentations: function () { var _a; return (_a = _this._wmsQueryAugmentations[mapName]) !== null && _a !== void 0 ? _a : {}; }
                            })];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [2 /*return*/, false];
                }
            });
        });
    };
    /**
     * @virtual
     * @protected
     * @param {GenericEvent} e
     * @memberof BaseMapProviderContext
     */
    BaseMapProviderContext.prototype.onImageError = function (e) { };
    BaseMapProviderContext.prototype.addClientSelectedFeature = function (f, l) {
        var _a;
        if (this._select)
            this._select.getFeatures().push(f);
        if (this._state.mapName) {
            var features = f.get("features");
            var theFeature = void 0;
            //Are we clustered?
            if (Array.isArray(features)) {
                // Only proceeed with dispatch if single item array
                if (features.length == 1) {
                    theFeature = features[0];
                }
                else {
                    return;
                }
            }
            else {
                theFeature = f;
            }
            var p = (0, tslib_1.__assign)({}, theFeature.getProperties());
            delete p[theFeature.getGeometryName()];
            var feat = {
                bounds: (_a = theFeature.getGeometry()) === null || _a === void 0 ? void 0 : _a.getExtent(),
                properties: p
            };
            this.dispatch((0, map_1.addClientSelectedFeature)(this._state.mapName, l.get(common_1.LayerProperty.LAYER_NAME), feat));
        }
    };
    BaseMapProviderContext.prototype.clearClientSelectedFeatures = function () {
        if (this._select)
            this._select.getFeatures().clear();
        if (this._state.mapName) {
            this.dispatch((0, map_1.clearClientSelection)(this._state.mapName));
        }
    };
    BaseMapProviderContext.prototype.onMapClick = function (e) {
        var _this = this;
        var _a, _b, _c;
        if (!this._comp || !this._map) {
            return;
        }
        if (this._comp.isContextMenuOpen()) {
            // We're going on the assumption that due to element placement
            // if this event is fired, it meant that the user clicked outside
            // the context menu, otherwise the context menu itself would've handled
            // the event
            (_b = (_a = this._comp).onHideContextMenu) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
        if (this.isDigitizing()) {
            return;
        }
        //TODO: Our selected feature tooltip only shows properties of a single feature
        //and displays upon said feature being selected. As a result, although we can
        //(and should) allow for multiple features to be selected, we need to figure
        //out the proper UI for such a case before we enable multiple selection.
        var bAppendMode = false;
        var featureToLayerMap = [];
        if ((this._state.activeTool == common_1.ActiveMapTool.Select) && this._select) {
            if (!bAppendMode) {
                this.clearClientSelectedFeatures();
            }
            this._map.forEachFeatureAtPixel(e.pixel, function (feature, layer) {
                if (featureToLayerMap.length == 0) { //See TODO above
                    if (layer.get(common_1.LayerProperty.IS_SELECTABLE) == true && feature instanceof Feature_1.default) {
                        featureToLayerMap.push([feature, layer]);
                    }
                }
            });
            if (this._select && featureToLayerMap.length == 1) {
                var _d = featureToLayerMap[0], f = _d[0], l = _d[1];
                if ((0, ol_style_helpers_1.isClusteredFeature)(f) && (0, ol_style_helpers_1.getClusterSubFeatures)(f).length > 1 && ((_c = l.get(common_1.LayerProperty.VECTOR_STYLE)) === null || _c === void 0 ? void 0 : _c.getClusterClickAction()) == ol_style_contracts_1.ClusterClickAction.ZoomToClusterExtents) {
                    var zoomBounds = (0, ol_style_helpers_1.getClusterSubFeatures)(f).reduce(function (bounds, currentFeatures) {
                        var g = currentFeatures.getGeometry();
                        if (g) {
                            return olExtent.extend(bounds, g.getExtent());
                        }
                        else {
                            return bounds;
                        }
                    }, olExtent.createEmpty());
                    // Inflate the bounds by 20 meters so that the new view has some "breathing space" and you don't see points
                    // of the cluster on the edge of the view
                    var inflatedBounds = inflateBoundsByMeters(this.getProjection(), zoomBounds, 20);
                    this.zoomToExtent(inflatedBounds);
                }
                else {
                    this.addClientSelectedFeature(f, l);
                }
            }
        }
        // We'll only fall through the normal map selection query route if no 
        // vector features were selected as part of this click
        var px = e.pixel;
        if (featureToLayerMap.length == 0) {
            this.hideSelectedVectorFeaturesTooltip();
            if (this._state.activeTool == common_1.ActiveMapTool.Select) {
                this.queryWmsFeatures(this._state.mapName, e.coordinate, bAppendMode).then(function (madeSelection) {
                    if (!madeSelection) {
                        _this.onProviderMapClick(px);
                    }
                    else {
                        console.log("Made WMS selection. Skipping provider click event");
                    }
                });
            }
            else {
                this.onProviderMapClick(px);
            }
        }
        else {
            if (this._select) {
                if (!bAppendMode) {
                    if (this._state.mapName) {
                        var activeLayerSet = this.getLayerSetGroup(this._state.mapName);
                        activeLayerSet === null || activeLayerSet === void 0 ? void 0 : activeLayerSet.clearWmsSelectionOverlay();
                    }
                }
                this.showSelectedVectorFeatures(this._select.getFeatures(), px, featureToLayerMap, this._state.locale);
            }
        }
    };
    BaseMapProviderContext.prototype.initContext = function (layerSet, locale, overviewMapElementSelector) {
        if (this._map) {
            // HACK: className property not documented. This needs to be fixed in OL api doc.
            var overviewMapOpts = {
                className: 'ol-overviewmap ol-custom-overviewmap',
                layers: layerSet.getLayersForOverviewMap(),
                view: new View_1.default({
                    projection: layerSet.getProjection()
                }),
                tipLabel: (0, i18n_1.tr)("OL_OVERVIEWMAP_TIP", locale),
                collapseLabel: String.fromCharCode(187),
                label: String.fromCharCode(171) //'\u00AB'
            };
            if (overviewMapElementSelector) {
                var el = overviewMapElementSelector();
                if (el) {
                    overviewMapOpts.target = ReactDOM.findDOMNode(el);
                    overviewMapOpts.collapsed = false;
                    overviewMapOpts.collapsible = false;
                }
            }
            this._ovMap = new OverviewMap_1.default(overviewMapOpts);
            this._map.addControl(this._ovMap);
            this.onBeforeAttachingLayerSetGroup(layerSet);
            layerSet.attach(this._map, this._ovMap, false);
        }
    };
    //#endregion
    /**
     * @virtual
     * @protected
     * @param {TLayerSetGroup} layerSetGroup
     * @memberof BaseMapProviderContext
     */
    BaseMapProviderContext.prototype.onBeforeAttachingLayerSetGroup = function (layerSetGroup) { };
    BaseMapProviderContext.prototype.setToasterRef = function (ref) {
        this._toasterRef = ref;
    };
    BaseMapProviderContext.prototype.onKeyDown = function (e) {
        var _a, _b;
        var cancelKey = (_a = this._state.cancelDigitizationKey) !== null && _a !== void 0 ? _a : common_1.KC_ESCAPE;
        var undoKey = (_b = this._state.undoLastPointKey) !== null && _b !== void 0 ? _b : common_1.KC_U;
        if (e.keyCode == cancelKey) {
            this.cancelDigitization();
        }
        else if (e.keyCode == undoKey && this._activeDrawInteraction) {
            this._activeDrawInteraction.removeLastPoint();
        }
    };
    BaseMapProviderContext.prototype.isDigitizing = function () {
        if (!this._map)
            return false;
        var activeDraw = this._map.getInteractions().getArray().filter(function (inter) { return inter instanceof Draw_1.default; })[0];
        return activeDraw != null;
    };
    BaseMapProviderContext.prototype.detachFromComponent = function () {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        this._comp = undefined;
        (_a = this._select) === null || _a === void 0 ? void 0 : _a.dispose();
        this._select = undefined;
        if (this._boundZoomSelectBox) {
            (_b = this._zoomSelectBox) === null || _b === void 0 ? void 0 : _b.un("boxend", this._boundZoomSelectBox);
            this._boundZoomSelectBox = undefined;
        }
        if (this._boundClick) {
            (_c = this._map) === null || _c === void 0 ? void 0 : _c.un("click", this._boundClick);
            this._boundClick = undefined;
        }
        if (this._boundMouseMove) {
            (_d = this._map) === null || _d === void 0 ? void 0 : _d.un("pointermove", this._boundMouseMove);
            this._boundMouseMove = undefined;
        }
        if (this._boundResize) {
            (_e = this._map) === null || _e === void 0 ? void 0 : _e.un("change:size", this._boundResize);
            this._boundResize = undefined;
        }
        if (this._boundMoveEnd) {
            (_f = this._map) === null || _f === void 0 ? void 0 : _f.un("moveend", this._boundMoveEnd);
            this._boundMoveEnd = undefined;
        }
        (_g = this._zoomSelectBox) === null || _g === void 0 ? void 0 : _g.dispose();
        this._zoomSelectBox = undefined;
        (_h = this._activeDrawInteraction) === null || _h === void 0 ? void 0 : _h.dispose();
        this._activeDrawInteraction = null;
        (_j = this._selectTooltip) === null || _j === void 0 ? void 0 : _j.dispose();
        this._selectTooltip = undefined;
        (_k = this._mouseTooltip) === null || _k === void 0 ? void 0 : _k.dispose();
        this._mouseTooltip = undefined;
        (_l = this._map) === null || _l === void 0 ? void 0 : _l.setTarget(undefined);
        (_m = this._ovMap) === null || _m === void 0 ? void 0 : _m.setMap(undefined); //HACK: Typings workaround
        this._map = undefined;
        this._ovMap = undefined;
        (0, logger_1.debug)("Map provider context detached from component and reset to initial state");
    };
    BaseMapProviderContext.prototype.onMoveEnd = function (e) {
        var _a, _b;
        //HACK:
        //
        //What we're hoping here is that when the view has been broadcasted back up
        //and flowed back in through new view props, that the resulting zoom/pan
        //operation in componentDidUpdate() is effectively a no-op as the intended
        //zoom/pan location has already been reached by this event right here
        //
        //If we look at this through Redux DevTools, we see 2 entries for Map/SET_VIEW
        //for the initial view (un-desirable), but we still only get one map image request
        //for the initial view (good!). Everything is fine after that.
        if (this._triggerZoomRequestOnMoveEnd) {
            var cv = this.getCurrentView();
            if (isValidView(cv)) {
                (_a = this._comp) === null || _a === void 0 ? void 0 : _a.onDispatch((0, map_1.setCurrentView)(cv));
            }
            else {
                console.warn("Attempt to set invalid view", cv);
            }
        }
        else {
            (0, logger_1.info)("Triggering zoom request on moveend suppresseed");
        }
        if (e.frameState.viewState.rotation != this._state.viewRotation) {
            (_b = this._comp) === null || _b === void 0 ? void 0 : _b.onDispatch((0, map_1.setViewRotation)(e.frameState.viewState.rotation));
        }
    };
    /**
     * @virtual
     * @param {HTMLElement} el
     * @param {IViewerComponent} comp
     * @memberof BaseMapProviderContext
     */
    BaseMapProviderContext.prototype.attachToComponent = function (el, comp) {
        var _this = this;
        this._comp = comp;
        this._select = new Select_1.default({
            condition: function (e) { return false; },
            layers: function (layer) { return layer.get(common_1.LayerProperty.IS_SELECTABLE) == true || layer.get(common_1.LayerProperty.IS_SCRATCH) == true; }
        });
        this._zoomSelectBox = new DragBox_1.default({
            condition: function (e) {
                var _a;
                // DragBox needs to be suppressed if the select tool can drag pan
                if (_this._state.activeTool == common_1.ActiveMapTool.Select && ((_a = _this._comp) === null || _a === void 0 ? void 0 : _a.selectCanDragPan()) === true) {
                    return false;
                }
                var startingMiddleMouseDrag = e.type == "pointerdown" && isMiddleMouseDownEvent(e.originalEvent);
                return !_this.isDigitizing() && !startingMiddleMouseDrag && (_this._state.activeTool === common_1.ActiveMapTool.Select || _this._state.activeTool === common_1.ActiveMapTool.Zoom);
            }
        });
        this._boundZoomSelectBox = this.onZoomSelectBox.bind(this);
        this._boundMouseMove = this.onMouseMove.bind(this);
        this._boundResize = this.onResize.bind(this);
        this._boundClick = this.onMapClick.bind(this);
        this._boundMoveEnd = this.onMoveEnd.bind(this);
        this._zoomSelectBox.on("boxend", this._boundZoomSelectBox);
        var mapOptions = {
            target: el,
            //layers: layers,
            //view: view,
            controls: [
                new Attribution_1.default({
                    tipLabel: (0, i18n_1.tr)("OL_ATTRIBUTION_TIP", this._state.locale)
                }),
                new Rotate_1.default({
                    tipLabel: (0, i18n_1.tr)("OL_RESET_ROTATION_TIP", this._state.locale)
                })
            ],
            interactions: [
                this._select,
                new DragRotate_1.default(),
                new DragPan_1.default({
                    condition: function (e) {
                        var _a;
                        // We'll allow for select tool to pan if instructed from above
                        if (_this._state.activeTool == common_1.ActiveMapTool.Select && ((_a = _this._comp) === null || _a === void 0 ? void 0 : _a.selectCanDragPan()) === true) {
                            return true;
                        }
                        var startingMiddleMouseDrag = e.type == "pointerdown" && isMiddleMouseDownEvent(e.originalEvent);
                        var enabled = (startingMiddleMouseDrag || _this._supportsTouch || _this._state.activeTool === common_1.ActiveMapTool.Pan);
                        //console.log(e);
                        //console.log(`Allow Pan - ${enabled} (middle mouse: ${startingMiddleMouseDrag})`);
                        return enabled;
                    }
                }),
                new PinchRotate_1.default(),
                new PinchZoom_1.default(),
                new KeyboardPan_1.default(),
                new KeyboardZoom_1.default(),
                new MouseWheelZoom_1.default(),
                this._zoomSelectBox
            ]
        };
        this._map = new Map_1.default(mapOptions);
        var activeLayerSet = this.ensureAndGetLayerSetGroup(this._state);
        this.initContext(activeLayerSet, this._state.locale, this._state.overviewMapElementSelector);
        this._mouseTooltip = new mouse_1.MouseTrackingTooltip(this._map, this._comp.isContextMenuOpen);
        this._selectTooltip = new selected_features_1.SelectedFeaturesTooltip(this._map, this);
        this._map.on("pointermove", this._boundMouseMove);
        this._map.on("change:size", this._boundResize);
        this._map.on("click", this._boundClick);
        this._map.on("moveend", this._boundMoveEnd);
        if (this._state.view) {
            var _a = this._state.view, x = _a.x, y = _a.y, scale = _a.scale;
            this.zoomToView(x, y, scale);
        }
        else {
            var extents = activeLayerSet.getExtent();
            this._map.getView().fit(extents);
        }
        this.onResize(this._map.getSize());
    };
    BaseMapProviderContext.prototype.scaleToResolution = function (scale) {
        (0, assert_1.assertIsDefined)(this._state.mapName);
        var activeLayerSet = this.getLayerSetGroup(this._state.mapName);
        (0, assert_1.assertIsDefined)(activeLayerSet);
        return activeLayerSet.scaleToResolution(scale);
    };
    BaseMapProviderContext.prototype.resolutionToScale = function (resolution) {
        (0, assert_1.assertIsDefined)(this._state.mapName);
        var activeLayerSet = this.getLayerSetGroup(this._state.mapName);
        (0, assert_1.assertIsDefined)(activeLayerSet);
        return activeLayerSet.resolutionToScale(resolution);
    };
    BaseMapProviderContext.prototype.getCurrentView = function () {
        var ov = this.getOLView();
        var center = ov.getCenter();
        var resolution = ov.getResolution();
        var scale = this.resolutionToScale(resolution);
        return {
            x: center[0],
            y: center[1],
            scale: scale,
            resolution: resolution
        };
    };
    BaseMapProviderContext.prototype.getCurrentExtent = function () {
        (0, assert_1.assertIsDefined)(this._map);
        return this._map.getView().calculateExtent(this._map.getSize());
    };
    BaseMapProviderContext.prototype.getSize = function () {
        (0, assert_1.assertIsDefined)(this._map);
        return this._map.getSize();
    };
    BaseMapProviderContext.prototype.getOLView = function () {
        (0, assert_1.assertIsDefined)(this._map);
        return this._map.getView();
    };
    BaseMapProviderContext.prototype.zoomToView = function (x, y, scale) {
        if (this._map) {
            var view = this._map.getView();
            view.setCenter([x, y]);
            view.setResolution(this.scaleToResolution(scale));
        }
    };
    /**
     * @virtual
     * @param {RefreshMode} [mode=RefreshMode.LayersOnly | RefreshMode.SelectionOnly]
     * @memberof BaseMapProviderContext
     */
    BaseMapProviderContext.prototype.refreshMap = function (mode) {
        if (mode === void 0) { mode = common_1.RefreshMode.LayersOnly | common_1.RefreshMode.SelectionOnly; }
    };
    BaseMapProviderContext.prototype.getMetersPerUnit = function () {
        (0, assert_1.assertIsDefined)(this._state.mapName);
        var activeLayerSet = this.getLayerSetGroup(this._state.mapName);
        (0, assert_1.assertIsDefined)(activeLayerSet);
        return activeLayerSet.getMetersPerUnit();
    };
    BaseMapProviderContext.prototype.initialView = function () {
        (0, assert_1.assertIsDefined)(this._comp);
        (0, assert_1.assertIsDefined)(this._state.mapName);
        var activeLayerSet = this.getLayerSetGroup(this._state.mapName);
        (0, assert_1.assertIsDefined)(activeLayerSet);
        this._comp.onDispatch((0, map_1.setCurrentView)(this.getViewForExtent(activeLayerSet.getExtent())));
    };
    BaseMapProviderContext.prototype.zoomDelta = function (delta) {
        //TODO: To conform to redux uni-directional data flow, this should
        //broadcast the new desired view back up and flow it back through to this
        //component as new props
        this.zoomByDelta(delta);
    };
    BaseMapProviderContext.prototype.zoomToExtent = function (extent) {
        var _a;
        (_a = this._comp) === null || _a === void 0 ? void 0 : _a.onDispatch((0, map_1.setCurrentView)(this.getViewForExtent(extent)));
    };
    BaseMapProviderContext.prototype.digitizePoint = function (handler, prompt) {
        (0, assert_1.assertIsDefined)(this._comp);
        var draw = new Draw_1.default({
            type: GeometryType_1.default.POINT
        });
        this.pushDrawInteraction("Point", draw, handler, prompt || (0, i18n_1.tr)("DIGITIZE_POINT_PROMPT", this._state.locale));
    };
    BaseMapProviderContext.prototype.digitizeLine = function (handler, prompt) {
        (0, assert_1.assertIsDefined)(this._comp);
        var draw = new Draw_1.default({
            type: GeometryType_1.default.LINE_STRING,
            minPoints: 2,
            maxPoints: 2
        });
        this.pushDrawInteraction("Line", draw, handler, prompt || (0, i18n_1.tr)("DIGITIZE_LINE_PROMPT", this._state.locale));
    };
    BaseMapProviderContext.prototype.digitizeLineString = function (handler, prompt) {
        var _a;
        (0, assert_1.assertIsDefined)(this._comp);
        var draw = new Draw_1.default({
            type: GeometryType_1.default.LINE_STRING,
            minPoints: 2
        });
        this.pushDrawInteraction("LineString", draw, handler, prompt || (0, i18n_1.tr)("DIGITIZE_LINESTRING_PROMPT", this._state.locale, {
            key: String.fromCharCode((_a = this._state.undoLastPointKey) !== null && _a !== void 0 ? _a : common_1.KC_U) //Pray that a sane (printable) key was bound
        }));
    };
    BaseMapProviderContext.prototype.digitizeCircle = function (handler, prompt) {
        (0, assert_1.assertIsDefined)(this._comp);
        var draw = new Draw_1.default({
            type: GeometryType_1.default.CIRCLE
        });
        this.pushDrawInteraction("Circle", draw, handler, prompt || (0, i18n_1.tr)("DIGITIZE_CIRCLE_PROMPT", this._state.locale));
    };
    BaseMapProviderContext.prototype.digitizeRectangle = function (handler, prompt) {
        (0, assert_1.assertIsDefined)(this._comp);
        var geomFunc = function (coordinates, geometry) {
            if (!geometry) {
                geometry = new Polygon_1.default([]);
            }
            var start = coordinates[0];
            var end = coordinates[1];
            geometry.setCoordinates([
                [start, [start[0], end[1]], end, [end[0], start[1]], start]
            ]);
            return geometry;
        };
        var draw = new Draw_1.default({
            type: GeometryType_1.default.LINE_STRING,
            maxPoints: 2,
            geometryFunction: geomFunc
        });
        this.pushDrawInteraction("Rectangle", draw, handler, prompt || (0, i18n_1.tr)("DIGITIZE_RECT_PROMPT", this._state.locale));
    };
    BaseMapProviderContext.prototype.digitizePolygon = function (handler, prompt) {
        var _a;
        (0, assert_1.assertIsDefined)(this._comp);
        var draw = new Draw_1.default({
            type: GeometryType_1.default.POLYGON
        });
        this.pushDrawInteraction("Polygon", draw, handler, prompt || (0, i18n_1.tr)("DIGITIZE_POLYGON_PROMPT", this._state.locale, {
            key: String.fromCharCode((_a = this._state.undoLastPointKey) !== null && _a !== void 0 ? _a : common_1.KC_U) //Pray that a sane (printable) key was bound
        }));
    };
    BaseMapProviderContext.prototype.addInteraction = function (interaction) {
        (0, assert_1.assertIsDefined)(this._map);
        this._map.addInteraction(interaction);
        return interaction;
    };
    BaseMapProviderContext.prototype.removeInteraction = function (interaction) {
        var _a;
        (_a = this._map) === null || _a === void 0 ? void 0 : _a.removeInteraction(interaction);
    };
    BaseMapProviderContext.prototype.addOverlay = function (overlay) {
        var _a;
        (_a = this._map) === null || _a === void 0 ? void 0 : _a.addOverlay(overlay);
    };
    BaseMapProviderContext.prototype.removeOverlay = function (overlay) {
        var _a;
        (_a = this._map) === null || _a === void 0 ? void 0 : _a.removeOverlay(overlay);
    };
    BaseMapProviderContext.prototype.getProjection = function () {
        (0, assert_1.assertIsDefined)(this._map);
        return this._map.getView().getProjection();
    };
    BaseMapProviderContext.prototype.addHandler = function (eventName, handler) {
        var _a;
        (_a = this._map) === null || _a === void 0 ? void 0 : _a.on(eventName, handler);
    };
    BaseMapProviderContext.prototype.removeHandler = function (eventName, handler) {
        var _a;
        (_a = this._map) === null || _a === void 0 ? void 0 : _a.un(eventName, handler);
    };
    BaseMapProviderContext.prototype.updateSize = function () {
        var _a;
        (_a = this._map) === null || _a === void 0 ? void 0 : _a.updateSize();
    };
    BaseMapProviderContext.prototype.getLayerManagerForLayerSet = function (layerSet) {
        (0, assert_1.assertIsDefined)(this._map);
        return new layer_manager_1.LayerManager(this._map, layerSet);
    };
    BaseMapProviderContext.prototype.getLayerManager = function (mapName) {
        (0, assert_1.assertIsDefined)(this._map);
        (0, assert_1.assertIsDefined)(this._state.mapName);
        var layerSet = this.ensureAndGetLayerSetGroup(this._state); // this.getLayerSet(mapName ?? this._state.mapName, true, this._comp as any);
        return this.getLayerManagerForLayerSet(layerSet);
    };
    BaseMapProviderContext.prototype.screenToMapUnits = function (x, y) {
        var bAllowOutsideWindow = false;
        var _a = this.getSize(), mapDevW = _a[0], mapDevH = _a[1];
        var _b = this.getCurrentExtent(), extX1 = _b[0], extY1 = _b[1], extX2 = _b[2], extY2 = _b[3];
        if (!bAllowOutsideWindow) {
            if (x > mapDevW - 1)
                x = mapDevW - 1;
            else if (x < 0)
                x = 0;
            if (y > mapDevH - 1)
                y = mapDevH - 1;
            else if (y < 0)
                y = 0;
        }
        x = extX1 + (extX2 - extX1) * (x / mapDevW);
        y = extY1 - (extY1 - extY2) * (y / mapDevH);
        return [x, y];
    };
    BaseMapProviderContext.prototype.getSelectedFeatures = function () {
        var _a;
        return (_a = this._select) === null || _a === void 0 ? void 0 : _a.getFeatures();
    };
    BaseMapProviderContext.prototype.getPointSelectionBox = function (point, ptBuffer) {
        (0, assert_1.assertIsDefined)(this._map);
        var ll = this._map.getCoordinateFromPixel([point[0] - ptBuffer, point[1] - ptBuffer]);
        var ur = this._map.getCoordinateFromPixel([point[0] + ptBuffer, point[1] + ptBuffer]);
        return [ll[0], ll[1], ur[0], ur[1]];
    };
    BaseMapProviderContext.prototype.getResolution = function () {
        (0, assert_1.assertIsDefined)(this._map);
        return this._map.getView().getResolution();
    };
    BaseMapProviderContext.prototype.updateOverviewMapElement = function (overviewMapElementSelector) {
        if (this._ovMap) {
            var el = overviewMapElementSelector();
            if (el) {
                this._ovMap.setCollapsed(false);
                this._ovMap.setCollapsible(false);
                this._ovMap.setTarget(ReactDOM.findDOMNode(el));
            }
            else {
                this._ovMap.setCollapsed(true);
                this._ovMap.setCollapsible(true);
                this._ovMap.setTarget(null);
            }
        }
    };
    return BaseMapProviderContext;
}());
exports.BaseMapProviderContext = BaseMapProviderContext;


/***/ }),

/***/ "./src/components/map-providers/context.tsx":
/*!**************************************************!*\
  !*** ./src/components/map-providers/context.tsx ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapContextProvider = exports.useMapProviderContext = exports.MapProviderContextProvider = exports.useAppState = exports.useReduxDispatch = exports.ReduxProvider = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var react_redux_1 = __webpack_require__(/*! react-redux */ "./node_modules/react-redux/es/index.js");
var MapProviderContext = React.createContext({});
/**
 * Wraps the provider component of react-redux
 *
 * @since 0.14
 */
var ReduxProvider = function (_a) {
    var store = _a.store, children = _a.children;
    return React.createElement(react_redux_1.Provider, { store: store }, children);
};
exports.ReduxProvider = ReduxProvider;
/**
 * Wraps useDispatch from react-redux
 *
 * @since 0.14
 */
function useReduxDispatch() {
    return (0, react_redux_1.useDispatch)();
}
exports.useReduxDispatch = useReduxDispatch;
/**
 * Fetches the requested sub-section of the application state
 *
 * @since 0.14
 */
function useAppState(selector, equalityFn) {
    return (0, react_redux_1.useSelector)(selector, equalityFn);
}
exports.useAppState = useAppState;
/**
 * @since 0.14
 */
var MapProviderContextProvider = function (_a) {
    var value = _a.value, children = _a.children;
    return React.createElement(MapProviderContext.Provider, { value: value }, children);
};
exports.MapProviderContextProvider = MapProviderContextProvider;
/**
 * Obtains the current map provider context, which provides imperative access to the current map
 *
 * @since 0.14
 */
function useMapProviderContext() {
    return React.useContext(MapProviderContext);
}
exports.useMapProviderContext = useMapProviderContext;
/**
 * @since 0.14
 */
var MapContextProvider = function (_a) {
    var value = _a.value, store = _a.store, children = _a.children;
    var inner = children;
    if (store) {
        inner = React.createElement(exports.ReduxProvider, { store: store }, children);
    }
    return React.createElement(exports.MapProviderContextProvider, { value: value }, inner);
};
exports.MapContextProvider = MapContextProvider;


/***/ }),

/***/ "./src/components/map-providers/mapguide.ts":
/*!**************************************************!*\
  !*** ./src/components/map-providers/mapguide.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapGuideMapProviderContext = exports.isMapGuideProviderState = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var client_1 = __webpack_require__(/*! ../../api/client */ "./src/api/client.ts");
var session_keep_alive_1 = __webpack_require__(/*! ../session-keep-alive */ "./src/components/session-keep-alive.tsx");
var common_1 = __webpack_require__(/*! ../../api/common */ "./src/api/common.ts");
var WKT_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/format/WKT */ "./node_modules/ol/format/WKT.js"));
var Polygon_1 = __webpack_require__(/*! ol/geom/Polygon */ "./node_modules/ol/geom/Polygon.js");
var map_1 = __webpack_require__(/*! ../../actions/map */ "./src/actions/map.ts");
var View_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/View */ "./node_modules/ol/View.js"));
var lodash_debounce_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! lodash.debounce */ "./node_modules/lodash.debounce/index.js"));
var viewer_state_1 = __webpack_require__(/*! ../../utils/viewer-state */ "./src/utils/viewer-state.ts");
var array_1 = __webpack_require__(/*! ../../utils/array */ "./src/utils/array.ts");
var mg_layer_set_group_1 = __webpack_require__(/*! ../../api/mg-layer-set-group */ "./src/api/mg-layer-set-group.ts");
var feature_1 = __webpack_require__(/*! ../tooltips/feature */ "./src/components/tooltips/feature.ts");
var logger_1 = __webpack_require__(/*! ../../utils/logger */ "./src/utils/logger.ts");
var site_version_1 = __webpack_require__(/*! ../../utils/site-version */ "./src/utils/site-version.ts");
var constants_1 = __webpack_require__(/*! ../../constants */ "./src/constants.ts");
var error_1 = __webpack_require__(/*! ../../api/error */ "./src/api/error.ts");
var base_1 = __webpack_require__(/*! ./base */ "./src/components/map-providers/base.ts");
var assert_1 = __webpack_require__(/*! ../../utils/assert */ "./src/utils/assert.ts");
var string_1 = __webpack_require__(/*! ../../utils/string */ "./src/utils/string.ts");
var url_1 = __webpack_require__(/*! ../../utils/url */ "./src/utils/url.ts");
var actions_1 = __webpack_require__(/*! ../../constants/actions */ "./src/constants/actions.ts");
var deArrayify_1 = __webpack_require__(/*! ../../api/builders/deArrayify */ "./src/api/builders/deArrayify.ts");
var hooks_1 = __webpack_require__(/*! ../../containers/hooks */ "./src/containers/hooks.ts");
var hooks_mapguide_1 = __webpack_require__(/*! ../../containers/hooks-mapguide */ "./src/containers/hooks-mapguide.ts");
var context_1 = __webpack_require__(/*! ./context */ "./src/components/map-providers/context.tsx");
var utfgrid_1 = __webpack_require__(/*! ../tooltips/utfgrid */ "./src/components/tooltips/utfgrid.ts");
var Tile_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Tile */ "./node_modules/ol/layer/Tile.js"));
var UTFGrid_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/UTFGrid */ "./node_modules/ol/source/UTFGrid.js"));
var hooks_generic_1 = __webpack_require__(/*! ../../containers/hooks-generic */ "./src/containers/hooks-generic.ts");
var type_guards_1 = __webpack_require__(/*! ../../utils/type-guards */ "./src/utils/type-guards.ts");
function isMapGuideProviderState(arg) {
    return typeof (arg.agentUri) == 'string'
        && typeof (arg.agentKind) == 'string';
}
exports.isMapGuideProviderState = isMapGuideProviderState;
function useMapGuideViewerState() {
    var activeTool = (0, hooks_1.useViewerActiveTool)();
    var view = (0, hooks_1.useActiveMapView)();
    var viewRotation = (0, hooks_1.useViewerViewRotation)();
    var viewRotationEnabled = (0, hooks_1.useViewerViewRotationEnabled)();
    var mapName = (0, hooks_1.useActiveMapName)();
    var locale = (0, hooks_1.useViewerLocale)();
    var externalBaseLayers = (0, hooks_1.useActiveMapExternalBaseLayers)(true);
    var cancelDigitizationKey = (0, hooks_1.useConfiguredCancelDigitizationKey)();
    var undoLastPointKey = (0, hooks_1.useConfiguredUndoLastPointKey)();
    var layers = (0, hooks_1.useActiveMapLayers)();
    var initialExternalLayers = (0, hooks_1.useActiveMapInitialExternalLayers)();
    var dispatch = (0, context_1.useReduxDispatch)();
    var appSettings = (0, hooks_1.useCustomAppSettings)();
    // ============== Generic ============== //
    var subject = (0, hooks_generic_1.useActiveMapSubjectLayer)();
    // ============== MapGuide-specific ================== //
    var stateless = (0, hooks_1.useViewerIsStateless)();
    var imageFormat = (0, hooks_1.useViewerImageFormat)();
    var agentUri = (0, hooks_1.useConfiguredAgentUri)();
    var agentKind = (0, hooks_1.useConfiguredAgentKind)();
    var map = (0, hooks_mapguide_1.useActiveMapState)();
    var pointSelectionBuffer = (0, hooks_1.useViewerPointSelectionBuffer)();
    var featureTooltipsEnabled = (0, hooks_1.useViewerFeatureTooltipsEnabled)();
    var manualFeatureTooltips = (0, hooks_1.useConfiguredManualFeatureTooltips)();
    var sessionId = (0, hooks_mapguide_1.useActiveMapSessionId)();
    var selectionColor = (0, hooks_1.useViewerSelectionColor)();
    var selectionImageFormat = (0, hooks_1.useViewerSelectionImageFormat)();
    var selectableLayerNames = (0, hooks_mapguide_1.useActiveMapSelectableLayerNames)();
    var layerTransparency = (0, hooks_mapguide_1.useActiveMapLayerTransparency)();
    var showGroups = (0, hooks_mapguide_1.useActiveMapShowGroups)();
    var hideGroups = (0, hooks_mapguide_1.useActiveMapHideGroups)();
    var showLayers = (0, hooks_mapguide_1.useActiveMapShowLayers)();
    var hideLayers = (0, hooks_mapguide_1.useActiveMapHideLayers)();
    var activeSelectedFeature = (0, hooks_mapguide_1.useActiveMapActiveSelectedFeature)();
    var activeSelectedFeatureColor = (0, hooks_1.useViewerActiveFeatureSelectionColor)();
    var selection = (0, hooks_1.useActiveMapSelectionSet)();
    var bgColor;
    if (map) {
        bgColor = "#" + map.BackgroundColor.substring(2);
    }
    var activeSelectedFeatureXml;
    if (activeSelectedFeature && selection && selection.FeatureSet) {
        activeSelectedFeatureXml = (0, deArrayify_1.getActiveSelectedFeatureXml)(selection.FeatureSet, activeSelectedFeature);
    }
    var theMap = map !== null && map !== void 0 ? map : subject;
    var isReady = false;
    // Regardless of inferred readiness, the map/subject must be set
    if (!theMap) {
        isReady = false;
        theMap = {};
    }
    else {
        if (subject && layerTransparency) {
            isReady = true;
        }
        else if (agentUri && theMap && layerTransparency) {
            if (!stateless) {
                if ((0, type_guards_1.isRuntimeMap)(theMap) && sessionId) {
                    isReady = true;
                }
            }
            else {
                isReady = true;
            }
        }
    }
    var nextState = {
        stateless: stateless,
        activeTool: activeTool,
        view: view,
        viewRotation: viewRotation,
        viewRotationEnabled: viewRotationEnabled,
        mapName: mapName,
        locale: locale,
        externalBaseLayers: externalBaseLayers,
        cancelDigitizationKey: cancelDigitizationKey,
        undoLastPointKey: undoLastPointKey,
        initialExternalLayers: initialExternalLayers,
        appSettings: appSettings !== null && appSettings !== void 0 ? appSettings : {},
        // ========== IMapProviderStateExtras ========== //
        isReady: isReady,
        bgColor: bgColor,
        layers: layers,
        // =========== MapGuide-specific ============== //
        imageFormat: imageFormat,
        agentUri: agentUri,
        agentKind: agentKind,
        map: theMap,
        pointSelectionBuffer: pointSelectionBuffer,
        featureTooltipsEnabled: featureTooltipsEnabled,
        manualFeatureTooltips: manualFeatureTooltips,
        sessionId: sessionId,
        selectionColor: selectionColor,
        selectionImageFormat: selectionImageFormat,
        selectableLayerNames: selectableLayerNames,
        layerTransparency: layerTransparency,
        showGroups: showGroups !== null && showGroups !== void 0 ? showGroups : [],
        hideGroups: hideGroups !== null && hideGroups !== void 0 ? hideGroups : [],
        showLayers: showLayers !== null && showLayers !== void 0 ? showLayers : [],
        hideLayers: hideLayers !== null && hideLayers !== void 0 ? hideLayers : [],
        activeSelectedFeatureXml: activeSelectedFeatureXml !== null && activeSelectedFeatureXml !== void 0 ? activeSelectedFeatureXml : string_1.STR_EMPTY,
        activeSelectedFeatureColor: activeSelectedFeatureColor,
        selection: selection
    };
    return nextState;
}
var MapGuideMapProviderContext = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(MapGuideMapProviderContext, _super);
    // ============================================================= //
    function MapGuideMapProviderContext(mockMode) {
        if (mockMode === void 0) { mockMode = undefined; }
        var _this = _super.call(this) || this;
        _this.mockMode = mockMode;
        _this.onOpenTooltipLink = function (url) {
            var _a;
            var fixedUrl = url;
            if (_this._state.mapName && _this._state.sessionId) {
                fixedUrl = (0, url_1.ensureParameters)(url, _this._state.mapName, _this._state.sessionId, _this._state.locale);
            }
            (_a = _this._comp) === null || _a === void 0 ? void 0 : _a.onDispatch({
                type: actions_1.ActionType.TASK_INVOKE_URL,
                payload: {
                    url: fixedUrl
                }
            });
        };
        _this._wktFormat = new WKT_1.default();
        _this.refreshOnStateChange = (0, lodash_debounce_1.default)(_this._refreshOnStateChange.bind(_this), 500);
        return _this;
    }
    /**
     * @override
     */
    MapGuideMapProviderContext.prototype.getHookFunction = function () {
        return useMapGuideViewerState;
    };
    MapGuideMapProviderContext.prototype.setMockMode = function (mode) {
        this.mockMode = mode;
    };
    /**
     * @override
     */
    MapGuideMapProviderContext.prototype.hideAllPopups = function () {
        var _a;
        _super.prototype.hideAllPopups.call(this);
        (_a = this._featureTooltip) === null || _a === void 0 ? void 0 : _a.setEnabled(false);
    };
    /**
     *
     * @override
     * @protected
     * @returns {(MapGuideMockMode | undefined)}
     * @memberof MapGuideMapProviderContext
     */
    MapGuideMapProviderContext.prototype.getMockMode = function () { return this.mockMode; };
    MapGuideMapProviderContext.prototype.getInitialProviderState = function () {
        return {
            stateless: false,
            imageFormat: "PNG8",
            agentUri: undefined,
            agentKind: "mapagent",
            map: {},
            pointSelectionBuffer: 2,
            featureTooltipsEnabled: true,
            manualFeatureTooltips: false,
            sessionId: undefined,
            selectionColor: "0000FF",
            selectionImageFormat: "PNG8",
            selectableLayerNames: [],
            layerTransparency: {},
            appSettings: {},
            showGroups: [],
            hideGroups: [],
            showLayers: [],
            hideLayers: [],
            activeSelectedFeatureXml: string_1.STR_EMPTY,
            activeSelectedFeatureColor: "FF0000",
            selection: null
        };
    };
    MapGuideMapProviderContext.prototype.getProviderName = function () { return "MapGuide"; };
    /**
     * @override
     * @returns {(IMapGuideViewerSupport | undefined)}
     * @memberof MapGuideMapProviderContext
     */
    MapGuideMapProviderContext.prototype.mapguideSupport = function () {
        return this;
    };
    //#region IMapGuideViewerSupport
    MapGuideMapProviderContext.prototype.getSelection = function () {
        return this._state.selection;
    };
    MapGuideMapProviderContext.prototype.getSelectionXml = function (selection, layerIds) {
        return (0, deArrayify_1.buildSelectionXml)(selection, layerIds);
    };
    MapGuideMapProviderContext.prototype.getSessionId = function () {
        return this._state.sessionId;
    };
    MapGuideMapProviderContext.prototype.setFeatureTooltipEnabled = function (enabled) {
        var _a;
        (_a = this._comp) === null || _a === void 0 ? void 0 : _a.onDispatch((0, map_1.setFeatureTooltipsEnabled)(enabled));
    };
    //#endregion
    //#region IMapViewerContextCallback
    MapGuideMapProviderContext.prototype.onSessionExpired = function () {
    };
    MapGuideMapProviderContext.prototype.onProviderMapClick = function (px) {
        var _a;
        if (this._state.mapName && this._state.sessionId) {
            if (this._state.manualFeatureTooltips && this._state.featureTooltipsEnabled) {
                this.queryFeatureTooltip(px);
            }
            else if (this._state.activeTool === common_1.ActiveMapTool.Select) {
                var ptBuffer = (_a = this._state.pointSelectionBuffer) !== null && _a !== void 0 ? _a : 2;
                var box = this.getPointSelectionBox(px, ptBuffer);
                var geom = (0, Polygon_1.fromExtent)(box);
                var options = this.buildDefaultQueryOptions(geom);
                options.maxfeatures = 1;
                this.sendSelectionQuery(options);
            }
        }
    };
    //#endregion
    //#region Map Context
    /**
     * @override
     * @protected
     * @param {GenericEvent} e
     * @returns
     * @memberof BaseMapProviderContext
     */
    MapGuideMapProviderContext.prototype.onMouseMove = function (e) {
        var _a, _b;
        if (this._comp) {
            this.handleMouseTooltipMouseMove(e);
            this.handleHighlightHover(e);
            if (this._comp.isContextMenuOpen()) {
                return;
            }
            if (!this._state.manualFeatureTooltips) {
                this.handleFeatureTooltipMouseMove(e);
            }
            if (this._utfGridTooltip) {
                this._utfGridTooltip.onMouseMove(e);
            }
            if (this._state.mapName) {
                (_b = (_a = this._comp).onDispatch) === null || _b === void 0 ? void 0 : _b.call(_a, (0, map_1.setMouseCoordinates)(this._state.mapName, e.coordinate));
            }
        }
    };
    MapGuideMapProviderContext.prototype.queryFeatureTooltip = function (pixel) {
        if (!this._state.stateless && this._featureTooltip && this._featureTooltip.isEnabled()) {
            this._featureTooltip.raiseQueryFromPoint(pixel);
        }
    };
    MapGuideMapProviderContext.prototype.handleFeatureTooltipMouseMove = function (e) {
        if (!this._state.stateless && this._featureTooltip && this._featureTooltip.isEnabled()) {
            this._featureTooltip.onMouseMove(e);
        }
    };
    MapGuideMapProviderContext.prototype.enableFeatureTooltips = function (enabled) {
        var _a;
        (_a = this._featureTooltip) === null || _a === void 0 ? void 0 : _a.setEnabled(enabled);
    };
    MapGuideMapProviderContext.prototype.refreshMapInternal = function (name, mode) {
        if (mode === void 0) { mode = common_1.RefreshMode.LayersOnly | common_1.RefreshMode.SelectionOnly; }
        var layerSet = this.getLayerSetGroup(name);
        layerSet === null || layerSet === void 0 ? void 0 : layerSet.refreshMap(mode);
    };
    MapGuideMapProviderContext.prototype.showSelectedFeature = function (mapExtent, size, map, selectionColor, featureXml) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var sv, layerSet, r, dataUri, e_1;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sv = (0, site_version_1.getSiteVersion)(map);
                        // This operation requires v4.0.0 QUERYMAPFEATURES, so bail if this ain't the right version
                        if (!(0, site_version_1.canUseQueryMapFeaturesV4)(sv)) {
                            return [2 /*return*/];
                        }
                        layerSet = this.getLayerSetGroup(map.Name);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 5, , 6]);
                        if (!featureXml) return [3 /*break*/, 3];
                        return [4 /*yield*/, this._client.queryMapFeatures_v4({
                                mapname: map.Name,
                                session: map.SessionId,
                                selectionformat: "PNG",
                                featurefilter: featureXml,
                                selectioncolor: selectionColor,
                                requestdata: 2,
                                layerattributefilter: 0,
                                persist: 0 //IMPORTANT: This is a transient selection
                            })];
                    case 2:
                        r = _a.sent();
                        if (r.InlineSelectionImage) {
                            dataUri = "data:" + r.InlineSelectionImage.MimeType + ";base64," + r.InlineSelectionImage.Content;
                            layerSet === null || layerSet === void 0 ? void 0 : layerSet.showActiveSelectedFeature(mapExtent, size, dataUri);
                        }
                        else {
                            layerSet === null || layerSet === void 0 ? void 0 : layerSet.showActiveSelectedFeature(mapExtent, common_1.BLANK_SIZE, constants_1.BLANK_GIF_DATA_URI);
                        }
                        return [3 /*break*/, 4];
                    case 3:
                        layerSet === null || layerSet === void 0 ? void 0 : layerSet.showActiveSelectedFeature(mapExtent, common_1.BLANK_SIZE, constants_1.BLANK_GIF_DATA_URI);
                        _a.label = 4;
                    case 4: return [3 /*break*/, 6];
                    case 5:
                        e_1 = _a.sent();
                        layerSet === null || layerSet === void 0 ? void 0 : layerSet.showActiveSelectedFeature(mapExtent, common_1.BLANK_SIZE, constants_1.BLANK_GIF_DATA_URI);
                        return [3 /*break*/, 6];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    //#endregion
    /**
     * DO NOT CALL DIRECTLY, call this.refreshOnStateChange() instead, which is a throttled version
     * of this method
     * @private
     */
    MapGuideMapProviderContext.prototype._refreshOnStateChange = function (mapName, showGroups, showLayers, hideGroups, hideLayers) {
        if (showGroups || showLayers || hideGroups || hideLayers) {
            //this.refreshOnStateChange(map, showGroups, showLayers, hideGroups, hideLayers);
            var layerSet = this.getLayerSetGroup(mapName);
            if (layerSet instanceof mg_layer_set_group_1.MgLayerSetGroup) {
                layerSet.setMapGuideMocking(this.getMockMode());
                layerSet.update(showGroups, showLayers, hideGroups, hideLayers);
            }
        }
    };
    /**
     * @override
     * @protected
     * @param {GenericEvent} e
     * @memberof MapGuideMapProviderContext
     */
    MapGuideMapProviderContext.prototype.onImageError = function (e) {
        var _this = this;
        var _a;
        (_a = this._keepAlive) === null || _a === void 0 ? void 0 : _a.lastTry().catch(function (err) {
            if ((0, error_1.isSessionExpiredError)(err)) {
                _this.onSessionExpired();
            }
        });
    };
    MapGuideMapProviderContext.prototype.getSelectableLayers = function () {
        var _a;
        return (_a = this._state.selectableLayerNames) !== null && _a !== void 0 ? _a : [];
    };
    MapGuideMapProviderContext.prototype.buildDefaultQueryOptions = function (geom, reqQueryFeatures /* Attributes */) {
        if (reqQueryFeatures === void 0) { reqQueryFeatures = 1; }
        (0, assert_1.assertIsDefined)(this._state.sessionId);
        (0, assert_1.assertIsDefined)(this._state.mapName);
        var names = this.getSelectableLayers();
        var wkt;
        if (typeof geom === 'string') {
            wkt = geom;
        }
        else {
            wkt = this._wktFormat.writeGeometry(geom);
        }
        return {
            mapname: this._state.mapName,
            session: this._state.sessionId,
            geometry: wkt,
            requestdata: reqQueryFeatures,
            layernames: names.length > 0 ? names.join(",") : undefined,
            persist: 1
        };
    };
    /**
     * @virtual
     * @protected
     * @param {Polygon} geom
     * @memberof MapGuideMapProviderContext
     */
    MapGuideMapProviderContext.prototype.selectFeaturesByExtent = function (geom) {
        if (!this._state.mapName || !this._comp || !this._state.sessionId || !this._state.selectionColor) {
            return;
        }
        this.sendSelectionQuery(this.buildDefaultQueryOptions(geom));
    };
    /**
     * @override
     * @protected
     */
    MapGuideMapProviderContext.prototype.initLayerSet = function (nextState) {
        var _this = this;
        var mapName = nextState.mapName;
        (0, assert_1.assertIsDefined)(mapName);
        (0, assert_1.assertIsDefined)(this._state.map);
        var layerSet = new mg_layer_set_group_1.MgLayerSetGroup(nextState, {
            getImageLoaders: function () { return _super.prototype.getImageSourceLoaders.call(_this, mapName); },
            getTileLoaders: function () { return _super.prototype.getTileSourceLoaders.call(_this, mapName); },
            getBaseTileLoaders: function () { return _super.prototype.getBaseTileSourceLoaders.call(_this, mapName); },
            getMockMode: function () { return _this.getMockMode(); },
            incrementBusyWorker: function () { return _this.incrementBusyWorker(); },
            decrementBusyWorker: function () { return _this.decrementBusyWorker(); },
            addImageLoading: function () { var _a; return (_a = _this._comp) === null || _a === void 0 ? void 0 : _a.addImageLoading(); },
            addImageLoaded: function () { var _a; return (_a = _this._comp) === null || _a === void 0 ? void 0 : _a.addImageLoaded(); },
            onImageError: function (e) { return _this.onImageError(e); },
            onSessionExpired: function () { return _this.onSessionExpired(); },
            getSelectableLayers: function () { return _this.getSelectableLayers(); },
            getClient: function () { return _this._client; },
            isContextMenuOpen: function () { var _a, _b; return (_b = (_a = _this._comp) === null || _a === void 0 ? void 0 : _a.isContextMenuOpen()) !== null && _b !== void 0 ? _b : false; },
            getAgentUri: function () { return _this._state.agentUri; },
            getAgentKind: function () { return _this._state.agentKind; },
            getMapName: function () { return _this._state.mapName; },
            getSessionId: function () { return _this._state.sessionId; },
            getLocale: function () { return _this._state.locale; },
            isFeatureTooltipEnabled: function () { return _this.isFeatureTooltipEnabled(); },
            getPointSelectionBox: function (pt) { return _this.getPointSelectionBox(pt, _this._state.pointSelectionBuffer); },
            openTooltipLink: function (url) { return _this.onOpenTooltipLink(url); },
            addFeatureToHighlight: function (feat, bAppend) { return _this.addFeatureToHighlight(feat, bAppend); }
        });
        this._layerSetGroups[mapName] = layerSet;
        layerSet.update(nextState.showGroups, nextState.showLayers, nextState.hideGroups, nextState.hideLayers);
        return layerSet;
    };
    /**
     * @override
     * @readonly
     * @memberof MapGuideMapProviderContext
     */
    MapGuideMapProviderContext.prototype.isMouseOverTooltip = function () { var _a, _b; return ((_a = this._featureTooltip) === null || _a === void 0 ? void 0 : _a.isMouseOver) == true || ((_b = this._selectTooltip) === null || _b === void 0 ? void 0 : _b.isMouseOver) == true; };
    /**
     * @override
     */
    MapGuideMapProviderContext.prototype.detachFromComponent = function () {
        var _a, _b;
        (_a = this._keepAlive) === null || _a === void 0 ? void 0 : _a.dispose();
        this._keepAlive = undefined;
        (_b = this._featureTooltip) === null || _b === void 0 ? void 0 : _b.dispose();
        this._featureTooltip = undefined;
        _super.prototype.detachFromComponent.call(this);
    };
    /**
     * @override
     * @param {HTMLElement} el
     * @param {IViewerComponent} comp
     * @memberof MapGuideMapProviderContext
     */
    MapGuideMapProviderContext.prototype.attachToComponent = function (el, comp) {
        var _this = this;
        var _a, _b, _c, _d;
        _super.prototype.attachToComponent.call(this, el, comp);
        var bCheckSession = (_a = (this._state.map && (0, type_guards_1.isRuntimeMap)(this._state.map))) !== null && _a !== void 0 ? _a : false;
        this._keepAlive = new session_keep_alive_1.SessionKeepAlive(function () { return _this._state.sessionId; }, this._client, this.onSessionExpired.bind(this), bCheckSession);
        var utfGridLayer = (0, base_1.recursiveFindLayer)(this._map.getLayers(), function (oll) {
            if (oll instanceof Tile_1.default) {
                var source = oll.getSource();
                if (source instanceof UTFGrid_1.default) {
                    return true;
                }
            }
            return false;
        });
        if (utfGridLayer) {
            var source = utfGridLayer.getSource();
            this._utfGridTooltip = new utfgrid_1.UTFGridTrackingTooltip(this._map, source, (_c = (_b = this._comp) === null || _b === void 0 ? void 0 : _b.isContextMenuOpen) !== null && _c !== void 0 ? _c : (function () { return false; }));
        }
        var bEnable = (_d = (this._state.map && (0, type_guards_1.isRuntimeMap)(this._state.map))) !== null && _d !== void 0 ? _d : false;
        if (bEnable) {
            this._featureTooltip = new feature_1.FeatureQueryTooltip(this._map, {
                incrementBusyWorker: function () { return _this.incrementBusyWorker(); },
                decrementBusyWorker: function () { return _this.decrementBusyWorker(); },
                onSessionExpired: function () { return _this.onSessionExpired(); },
                getAgentUri: function () { return _this._state.agentUri; },
                getAgentKind: function () { return _this._state.agentKind; },
                getMapName: function () { return _this._state.mapName; },
                getSessionId: function () { return _this._state.sessionId; },
                getLocale: function () { return _this._state.locale; },
                getPointSelectionBox: function (pt) { return _this.getPointSelectionBox(pt, _this._state.pointSelectionBuffer); },
                openTooltipLink: function (url) { return _this.onOpenTooltipLink(url); }
            });
            this._featureTooltip.setEnabled(this._state.featureTooltipsEnabled);
        }
    };
    /**
     * @override
     * @param {RefreshMode} [mode=RefreshMode.LayersOnly | RefreshMode.SelectionOnly]
     * @memberof MapGuideMapProviderContext
     */
    MapGuideMapProviderContext.prototype.refreshMap = function (mode) {
        if (mode === void 0) { mode = common_1.RefreshMode.LayersOnly | common_1.RefreshMode.SelectionOnly; }
        (0, assert_1.assertIsDefined)(this._state.mapName);
        this.refreshMapInternal(this._state.mapName, mode);
    };
    /**
     * @override
     * @protected
     * @param {MgLayerSetGroup} layerSetGroup
     * @memberof MapGuideMapProviderContext
     */
    MapGuideMapProviderContext.prototype.onBeforeAttachingLayerSetGroup = function (layerSetGroup) {
        layerSetGroup.setMapGuideMocking(this.getMockMode());
    };
    /**
     *
     * @virtual
     * @param {IMapGuideProviderState} nextState
     * @memberof MapGuideMapProviderContext
     */
    MapGuideMapProviderContext.prototype.setProviderState = function (nextState) {
        var _this = this;
        // If viewer not mounted yet, just accept the next state and bail
        if (!this._comp || !this._map) {
            if (nextState.agentUri) {
                this._client = new client_1.Client(nextState.agentUri, nextState.agentKind);
            }
            this._state = nextState;
            return;
        }
        //
        // React (no pun intended) to prop changes
        //
        if (nextState.imageFormat != this._state.imageFormat) {
            (0, logger_1.warn)("Unsupported change of props: imageFormat");
        }
        if (nextState.agentUri && nextState.agentUri != this._state.agentUri) {
            (0, logger_1.warn)("Unsupported change of props: agentUri");
            this._client = new client_1.Client(nextState.agentUri, nextState.agentKind);
        }
        if (nextState.agentUri && nextState.agentKind != this._state.agentKind) {
            (0, logger_1.warn)("Unsupported change of props: agentKind");
            this._client = new client_1.Client(nextState.agentUri, nextState.agentKind);
        }
        var bChangedView = false;
        //map
        if (nextState.mapName != this._state.mapName && this._map && this._ovMap) {
            this.hideAllPopups();
            var oldLayerSet = this.getLayerSetGroup(this._state.mapName);
            var newLayerSet = this.ensureAndGetLayerSetGroup(nextState);
            //Clear any stray hover highlighted features as part of switch
            oldLayerSet === null || oldLayerSet === void 0 ? void 0 : oldLayerSet.clearHighlightedFeatures();
            newLayerSet.clearHighlightedFeatures();
            oldLayerSet === null || oldLayerSet === void 0 ? void 0 : oldLayerSet.detach(this._map, this._ovMap);
            newLayerSet.setMapGuideMocking(this.getMockMode());
            newLayerSet.attach(this._map, this._ovMap);
            //This would happen if we switch to a map we haven't visited yet
            if (!nextState.view) {
                newLayerSet.fitViewToExtent();
                bChangedView = true;
            }
            else {
                var layerSet = this.getLayerSetGroup(nextState.mapName);
                if (layerSet) {
                    this.applyView(layerSet, nextState.view);
                }
            }
        }
        //selectionColor
        if (nextState.selectionColor && nextState.selectionColor != this._state.selectionColor) {
            var layerSet = this.getLayerSetGroup(nextState.mapName);
            layerSet === null || layerSet === void 0 ? void 0 : layerSet.updateSelectionColor(nextState.selectionColor);
        }
        //featureTooltipsEnabled
        if (nextState.featureTooltipsEnabled != this._state.featureTooltipsEnabled) {
            this.enableFeatureTooltips(nextState.featureTooltipsEnabled);
        }
        //externalBaseLayers
        if (nextState.externalBaseLayers != null &&
            nextState.externalBaseLayers.length > 0) {
            var layerSet = this.getLayerSetGroup(nextState.mapName);
            layerSet === null || layerSet === void 0 ? void 0 : layerSet.updateExternalBaseLayers(nextState.externalBaseLayers);
        }
        //Layer transparency
        if (nextState.layerTransparency && (0, viewer_state_1.layerTransparencyChanged)(nextState.layerTransparency, this._state.layerTransparency)) {
            var layerSet = this.getLayerSetGroup(nextState.mapName);
            layerSet === null || layerSet === void 0 ? void 0 : layerSet.updateTransparency(nextState.layerTransparency);
        }
        //Layer/Group visibility
        if (nextState.mapName && ((0, array_1.areArraysDifferent)(nextState.showGroups, this._state.showGroups) ||
            (0, array_1.areArraysDifferent)(nextState.hideGroups, this._state.hideGroups) ||
            (0, array_1.areArraysDifferent)(nextState.showLayers, this._state.showLayers) ||
            (0, array_1.areArraysDifferent)(nextState.hideLayers, this._state.hideLayers))) {
            this.refreshOnStateChange(nextState.mapName, nextState.showGroups, nextState.showLayers, nextState.hideGroups, nextState.hideLayers);
        }
        //view
        var bViewChanged = false;
        if (!(0, viewer_state_1.areViewsCloseToEqual)(nextState.view, this._state.view)) {
            var vw = nextState.view;
            if (vw != null && !bChangedView) {
                var layerSet = this.ensureAndGetLayerSetGroup(nextState);
                this.applyView(layerSet, vw);
                bViewChanged = true;
            }
            else {
                (0, logger_1.debug)("Skipping zoomToView as next/current views are close enough or target view is null");
            }
        }
        //overviewMapElement
        if (nextState.overviewMapElementSelector) {
            this.updateOverviewMapElement(nextState.overviewMapElementSelector);
        }
        //viewRotation
        if (this._state.viewRotation != nextState.viewRotation) {
            this.getOLView().setRotation(nextState.viewRotation);
        }
        //viewRotationEnabled
        if (this._state.viewRotationEnabled != nextState.viewRotationEnabled) {
            if (this._map) {
                var view = this.getOLView();
                var newView = new View_1.default({
                    enableRotation: nextState.viewRotationEnabled,
                    rotation: nextState.viewRotation,
                    center: view.getCenter(),
                    resolution: view.getResolution(),
                    resolutions: view.getResolutions(),
                    minResolution: view.getMinResolution(),
                    maxResolution: view.getMaxResolution(),
                    maxZoom: view.getMaxZoom(),
                    minZoom: view.getMinZoom(),
                    //constrainRotation: view.constrainRotation(),
                    projection: view.getProjection(),
                    zoom: view.getZoom()
                });
                this._map.setView(newView);
            }
        }
        //activeSelectedFeatureXml
        var bDiffSelectionXml = this._state.activeSelectedFeatureXml != nextState.activeSelectedFeatureXml;
        var bRefreshActiveFeatureSelection = !(0, string_1.strIsNullOrEmpty)(nextState.activeSelectedFeatureXml) && bViewChanged;
        if (bDiffSelectionXml || bRefreshActiveFeatureSelection) {
            if (this._map && nextState.map) {
                var ms_1 = this._map.getSize();
                if (ms_1 && (0, type_guards_1.isRuntimeMap)(nextState.map)) {
                    var nmap_1 = nextState.map;
                    // We don't want to request for an updated feature selection while there are still rendering operations in progress
                    // otherwise we may request a feature selection for a map whose internal view has been changed by the in-progress rendering
                    // operation
                    var checkReady_1 = function () {
                        if (_this._busyWorkers == 0) {
                            //console.log("Ready to request updated feature selection");
                            var view = _this.getOLView();
                            var me = view.calculateExtent(ms_1);
                            var size = { w: ms_1[0], h: ms_1[1] };
                            _this.showSelectedFeature(me, size, nmap_1, nextState.activeSelectedFeatureColor, nextState.activeSelectedFeatureXml);
                        }
                        else {
                            //console.log("Still busy. Hold off on request for updated feature selection");
                            window.setTimeout(checkReady_1, 100);
                        }
                    };
                    checkReady_1();
                }
            }
        }
        this._state = nextState;
    };
    MapGuideMapProviderContext.prototype.setSelectionXml = function (xml, queryOpts, success, failure) {
        var _this = this;
        var _a;
        if (!this._state.mapName || !this._comp || !this._state.sessionId || !this._state.selectionColor) {
            return;
        }
        //NOTE: A quirk of QUERYMAPFEATURES is that when passing in selection XML (instead of geometry),
        //you must set the layerattributefilter to the full bit mask otherwise certain features in the
        //selection XML will not be rendered because they may not pass the layer attribute filter
        var reqQueryFeatures = 1; //Attributes
        this.incrementBusyWorker();
        var mapName = this._state.mapName;
        var qOrig = {
            mapname: mapName,
            session: this._state.sessionId,
            persist: 1,
            featurefilter: xml,
            selectioncolor: this._state.selectionColor,
            selectionformat: (_a = this._state.selectionImageFormat) !== null && _a !== void 0 ? _a : "PNG8",
            maxfeatures: -1,
            requestdata: reqQueryFeatures
        };
        var queryOptions = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, qOrig), queryOpts);
        var action = (0, map_1.queryMapFeatures)(mapName, {
            options: queryOptions,
            callback: function (res) {
                _this.decrementBusyWorker();
                if (success) {
                    success(res);
                }
            },
            errBack: function (err) {
                _this.decrementBusyWorker();
                if (failure) {
                    failure(err);
                }
            }
        });
        this._comp.onDispatch(action);
    };
    MapGuideMapProviderContext.prototype.clearSelection = function () {
        this.setSelectionXml("");
    };
    MapGuideMapProviderContext.prototype.selectByGeometry = function (geom, selectionMethod) {
        var options = this.buildDefaultQueryOptions(geom);
        if (selectionMethod) {
            options.selectionvariant = selectionMethod;
        }
        this.sendSelectionQuery(options);
    };
    MapGuideMapProviderContext.prototype.queryMapFeatures = function (options, success, failure) {
        this.sendSelectionQuery(options, success, failure);
    };
    MapGuideMapProviderContext.prototype.isFeatureTooltipEnabled = function () {
        var _a;
        return ((_a = this._featureTooltip) === null || _a === void 0 ? void 0 : _a.isEnabled()) == true;
    };
    // ================= MapGuide-specific =================== //
    MapGuideMapProviderContext.prototype.sendSelectionQuery = function (queryOpts, success, failure) {
        var _this = this;
        var _a, _b;
        if (!this._state.mapName || !this._comp || !this._state.sessionId || !this._state.selectionColor || (queryOpts != null && ((_a = queryOpts.layernames) !== null && _a !== void 0 ? _a : []).length == 0)) {
            return;
        }
        this.incrementBusyWorker();
        var mapName = this._state.mapName;
        var qOrig = {
            mapname: mapName,
            session: this._state.sessionId,
            persist: 1,
            selectionvariant: "INTERSECTS",
            selectioncolor: this._state.selectionColor,
            selectionformat: (_b = this._state.selectionImageFormat) !== null && _b !== void 0 ? _b : "PNG8",
            maxfeatures: -1
        };
        var queryOptions = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, qOrig), queryOpts);
        var action = (0, map_1.queryMapFeatures)(mapName, {
            options: queryOptions,
            callback: function (res) {
                _this.decrementBusyWorker();
                if (success) {
                    success(res);
                }
            },
            errBack: function (err) {
                _this.decrementBusyWorker();
                if (failure) {
                    failure(err);
                }
            }
        });
        this._comp.onDispatch(action);
    };
    return MapGuideMapProviderContext;
}(base_1.BaseMapProviderContext));
exports.MapGuideMapProviderContext = MapGuideMapProviderContext;


/***/ }),

/***/ "./src/components/mapguide-debug-context.ts":
/*!**************************************************!*\
  !*** ./src/components/mapguide-debug-context.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapDebugContext = exports.MapGuideMockMode = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
/**
 * @since 0.13
 */
var MapGuideMockMode;
(function (MapGuideMockMode) {
    /**
     * Render a placeholder image showing the key mapagent parameters
     */
    MapGuideMockMode[MapGuideMockMode["RenderPlaceholder"] = 0] = "RenderPlaceholder";
    /**
     * Do not render anything
     */
    MapGuideMockMode[MapGuideMockMode["DoNotRender"] = 1] = "DoNotRender";
})(MapGuideMockMode = exports.MapGuideMockMode || (exports.MapGuideMockMode = {}));
exports.MapDebugContext = React.createContext({});


/***/ }),

/***/ "./src/components/menu.tsx":
/*!*********************************!*\
  !*** ./src/components/menu.tsx ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MenuComponent = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var type_guards_1 = __webpack_require__(/*! ../utils/type-guards */ "./src/utils/type-guards.ts");
var toolbar_1 = __webpack_require__(/*! ./toolbar */ "./src/components/toolbar.tsx");
var icon_1 = __webpack_require__(/*! ./icon */ "./src/components/icon.tsx");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var MENU_ITEM_HEIGHT = 30;
/**
 * A generic menu component
 * @param props
 */
var MenuComponent = function (props) {
    var onClick = function (item) {
        var _a, _b;
        if ((0, toolbar_1.getEnabled)(item)) {
            (_a = item === null || item === void 0 ? void 0 : item.invoke) === null || _a === void 0 ? void 0 : _a.call(item);
            (_b = props.onInvoked) === null || _b === void 0 ? void 0 : _b.call(props);
        }
    };
    return React.createElement(core_1.Menu, { className: "bp3-elevation-1" }, props.items.map(function (item, index) {
        if (item.isSeparator) {
            return React.createElement(core_1.MenuDivider, { key: index });
        }
        else if ((0, type_guards_1.isMenu)(item)) {
            var text = "";
            if (typeof (item.label) == 'function') {
                text = item.label();
            }
            else {
                text = item.label || "";
            }
            return React.createElement(core_1.MenuItem, { key: index, text: text, icon: "menu-open" },
                React.createElement(exports.MenuComponent, { items: item.childItems, onInvoked: props.onInvoked }));
        }
        else {
            var height = MENU_ITEM_HEIGHT;
            var enabled = true;
            if (item.enabled != null) {
                if (typeof (item.enabled) == 'function') {
                    enabled = item.enabled();
                }
                else {
                    enabled = item.enabled;
                }
            }
            var imgStyle = (0, tslib_1.__assign)({ marginRight: 5 }, (0, toolbar_1.getIconStyle)(enabled, height));
            var text = item.label || "";
            //NOTE: Not using MenuItem here as we want fine control over the item content
            return React.createElement("li", { key: index },
                React.createElement("a", { className: "bp3-menu-item", onClick: function () { return onClick(item); } },
                    React.createElement(icon_1.ImageIcon, { style: imgStyle, url: item.icon, spriteClass: item.iconClass }),
                    " ",
                    text));
        }
    }));
};
exports.MenuComponent = MenuComponent;


/***/ }),

/***/ "./src/components/modal-dialog.tsx":
/*!*****************************************!*\
  !*** ./src/components/modal-dialog.tsx ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RndModalDialog = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var react_rnd_1 = __webpack_require__(/*! react-rnd */ "./node_modules/react-rnd/lib/index.js");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var DIAG_HEADER_HEIGHT = 40;
var RndModalDialog = function (props) {
    if (props.isOpen === false)
        return React.createElement("div", null);
    var modalBodyStyle = {
        margin: 0
    };
    if (!props.disableYOverflow) {
        modalBodyStyle.overflowY = "auto";
    }
    var _a = React.useState(false), isDragging = _a[0], setIsDragging = _a[1];
    var _b = React.useState(false), isResizing = _b[0], setIsResizing = _b[1];
    var _c = React.useState(props.width), diagWidth = _c[0], setDiagWidth = _c[1];
    var _d = React.useState(props.height), diagHeight = _d[0], setDiagHeight = _d[1];
    var _e = React.useState(props.x), diagX = _e[0], setDiagX = _e[1];
    var _f = React.useState(props.y), diagY = _f[0], setDiagY = _f[1];
    var ZINDEX = {
        zIndex: 1980 //So flyouts will appear above it
    };
    var modalStyle = (0, tslib_1.__assign)({ width: diagWidth, height: diagHeight, 
        //bp defaults this to 30, which invisibly offsets the 
        //position of expected rnd drag/resize handles
        marginTop: 0 }, ZINDEX);
    var rndStyle = (0, tslib_1.__assign)({}, ZINDEX);
    var diagSize = [diagWidth, diagHeight - DIAG_HEADER_HEIGHT];
    //console.log(`Resizing: ${isResizing}, Dragging: ${isDragging}`);
    return React.createElement(react_rnd_1.Rnd, { style: rndStyle, enableResizing: {
            bottomRight: true,
            bottomLeft: true,
            topLeft: true,
            topRight: true
        }, enableUserSelectHack: false, onDragStart: function () { return setIsDragging(true); }, onDragStop: function (e, d) {
            setDiagX(d.x);
            setDiagY(d.y);
            setIsDragging(false);
        }, onResizeStart: function () { return setIsResizing(true); }, onResize: function (e, direction, ref, delta, position) {
            setDiagWidth(ref.offsetWidth);
            setDiagHeight(ref.offsetHeight);
            setDiagX(position.x);
            setDiagY(position.y);
        }, onResizeStop: function (e, direction, ref, delta, position) {
            setDiagWidth(ref.offsetWidth);
            setDiagHeight(ref.offsetHeight);
            setDiagX(position.x);
            setDiagY(position.y);
            setIsResizing(false);
        }, dragHandleClassName: "bp3-heading", default: { x: props.x, y: props.y, width: props.width, height: props.height } },
        React.createElement("div", { className: "bp3-dialog-container" },
            React.createElement("div", { className: "bp3-dialog", style: modalStyle },
                React.createElement("div", { className: "bp3-dialog-header noselect" },
                    props.icon && React.createElement(core_1.Icon, { icon: props.icon }),
                    React.createElement("h4", { className: "bp3-heading" }, props.title),
                    React.createElement(core_1.Button, { onClick: props.onClose, "aria-label": "Close", className: "bp3-dialog-close-button bp3-button", minimal: true, icon: "small-cross" })),
                React.createElement("div", { className: "bp3-dialog-body", style: modalBodyStyle }, (function () {
                    //We use NonIdealState as a visual mask to suppress unwanted mouse 
                    //interaction during the act of dragging/resizing, similar to what the
                    //Task Pane does
                    if (props.enableInteractionMask && (isResizing || isDragging)) {
                        var key = isResizing ? "WINDOW_RESIZING" : "WINDOW_MOVING";
                        return React.createElement(core_1.NonIdealState, { icon: "arrows-horizontal", description: (0, i18n_1.tr)(key, props.locale) });
                    }
                    else {
                        return props.children(diagSize);
                    }
                })()))));
};
exports.RndModalDialog = RndModalDialog;


/***/ }),

/***/ "./src/components/mouse-coordinates.tsx":
/*!**********************************************!*\
  !*** ./src/components/mouse-coordinates.tsx ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MouseCoordinates = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var string_1 = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");
function formatCoordinates(props) {
    var coords = props.coords, decimals = props.decimals, format = props.format, units = props.units;
    if (coords == null) {
        return null; //TODO: Use value indicated by EmptyText extension property
    }
    var x = coords[0], y = coords[1];
    var sfmt = format || "X: {x}, Y: {y} {units}";
    var str = (0, i18n_1.fmt)(sfmt, {
        x: "" + (decimals != null ? x.toFixed(decimals) : x),
        y: "" + (decimals != null ? y.toFixed(decimals) : y),
        units: units || ""
    });
    return React.createElement("span", { dangerouslySetInnerHTML: { __html: (0, string_1.strTrim)(str) } });
}
/**
 * Displays tracked mouse coordinates
 * @param props
 */
var MouseCoordinates = function (props) {
    return React.createElement("div", { className: "status-bar-component component-mouse-coordinates", style: props.style }, formatCoordinates(props));
};
exports.MouseCoordinates = MouseCoordinates;


/***/ }),

/***/ "./src/components/navigator.tsx":
/*!**************************************!*\
  !*** ./src/components/navigator.tsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Navigator = exports.PanDirection = exports.ZoomDirection = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
// According to this (https://github.com/mzabriskie/react-draggable/issues/246#issuecomment-299698481), typings
// only works if module type is "es6". This is not the case for us, so just use untyped require()
var react_draggable_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! react-draggable */ "./node_modules/react-draggable/build/cjs/cjs.js"));
var number_1 = __webpack_require__(/*! ../utils/number */ "./src/utils/number.ts");
var assets_1 = __webpack_require__(/*! ../constants/assets */ "./src/constants/assets.ts");
var ZoomDirection;
(function (ZoomDirection) {
    ZoomDirection[ZoomDirection["In"] = 0] = "In";
    ZoomDirection[ZoomDirection["Out"] = 1] = "Out";
})(ZoomDirection = exports.ZoomDirection || (exports.ZoomDirection = {}));
var PanDirection;
(function (PanDirection) {
    PanDirection[PanDirection["East"] = 0] = "East";
    PanDirection[PanDirection["West"] = 1] = "West";
    PanDirection[PanDirection["South"] = 2] = "South";
    PanDirection[PanDirection["North"] = 3] = "North";
})(PanDirection = exports.PanDirection || (exports.PanDirection = {}));
;
var VERT_START = 10;
var VERT_SPAN = 81; //This is the pixel height of the maximum draggable scale range
var LN9 = Math.log(9);
function calculatePosForScale(scale, finiteScaleList) {
    if (finiteScaleList) {
        var index = (0, number_1.getFiniteScaleIndexForScale)(finiteScaleList, scale);
        var pos = (VERT_SPAN / finiteScaleList.length) * (index + 1);
        //console.log(`Scale: ${scale} @ ${index} / ${finiteScaleList.length} -> ${Math.floor(pos)}`);
        return Math.floor(pos);
    }
    else {
        var pos = 9 * Math.log(scale) / LN9;
        return Math.floor(pos);
    }
}
function calculateScaleForPos(pos, finiteScaleList) {
    var scale = Math.pow(9, pos / 9);
    if (finiteScaleList) {
        var index = (0, number_1.getFiniteScaleIndexForScale)(finiteScaleList, scale);
        return finiteScaleList[index];
    }
    else {
        return scale;
    }
}
/**
 * The Navigator component provides an interactive zoom slider for the map viewer
 * @param props
 */
var Navigator = function (props) {
    var busy = props.busy, locale = props.locale;
    var onPanEast = function () {
        props.onPan(PanDirection.East);
    };
    var onPanWest = function () {
        props.onPan(PanDirection.West);
    };
    var onPanSouth = function () {
        props.onPan(PanDirection.South);
    };
    var onPanNorth = function () {
        props.onPan(PanDirection.North);
    };
    var onZoomOut = function () {
        props.onZoom(ZoomDirection.Out);
    };
    var onZoomIn = function () {
        props.onZoom(ZoomDirection.In);
    };
    var onStart = function (e) {
        e.preventDefault();
        //console.log(`Drag start (dy: ${data.deltaY})`);
        setIsDragging(true);
        setPreviewPos(pos);
    };
    var onDrag = function (e, data) {
        e.preventDefault();
        //console.log(`Dragging (dy: ${data.deltaY})`);
        var pos = previewPos;
        setPreviewPos(pos + data.deltaY);
    };
    var onStop = function (e) {
        e.preventDefault();
        var newScale = calculateScaleForPos(previewPos);
        //console.log(`posDelta: ${posDelta}`);
        setIsDragging(false);
        setPos(previewPos);
        props.onRequestZoomToScale(newScale);
    };
    //Used to specify the preview destination scale "position"
    var _a = React.useState(calculatePosForScale(props.scale, props.finiteScaleList)), previewPos = _a[0], setPreviewPos = _a[1];
    //Used to specify the current scale "position"
    var _b = React.useState(calculatePosForScale(props.scale, props.finiteScaleList)), pos = _b[0], setPos = _b[1];
    var _c = React.useState(false), isDragging = _c[0], setIsDragging = _c[1];
    React.useEffect(function () {
        var pos = calculatePosForScale(props.scale, props.finiteScaleList);
        setPos(pos);
        setPreviewPos(pos);
    }, [props.scale, props.finiteScaleList]);
    return React.createElement("div", { id: "Navigator", style: props.style, className: "component-navigator noselect" },
        React.createElement("map", { name: "Navigator_ImageMap", id: "Navigator_ImageMap" },
            React.createElement("area", { onClick: onPanEast, shape: "poly", alt: (0, i18n_1.tr)("NAVIGATOR_PAN_EAST", locale), title: (0, i18n_1.tr)("NAVIGATOR_PAN_EAST", locale), coords: "27,176, 27,177, 40,190, 44,182, 44,159" }),
            React.createElement("area", { onClick: onPanWest, shape: "poly", alt: (0, i18n_1.tr)("NAVIGATOR_PAN_WEST", locale), title: (0, i18n_1.tr)("NAVIGATOR_PAN_WEST", locale), coords: "24,177, 24,176, 7,159, 7,182, 11,190" }),
            React.createElement("area", { onClick: onPanSouth, shape: "poly", alt: (0, i18n_1.tr)("NAVIGATOR_PAN_SOUTH", locale), title: (0, i18n_1.tr)("NAVIGATOR_PAN_SOUTH", locale), coords: "25,178, 12,191, 21,197, 30,197, 39,191, 26,178" }),
            React.createElement("area", { onClick: onPanNorth, shape: "poly", alt: (0, i18n_1.tr)("NAVIGATOR_PAN_NORTH", locale), title: (0, i18n_1.tr)("NAVIGATOR_PAN_NORTH", locale), coords: "26,175, 43,158, 8,158, 25,175" }),
            React.createElement("area", { onClick: onZoomOut, shape: "circle", alt: (0, i18n_1.tr)("NAVIGATOR_ZOOM_OUT", locale), title: (0, i18n_1.tr)("NAVIGATOR_ZOOM_OUT", locale), coords: "25,142,8" }),
            React.createElement("area", { onClick: onZoomIn, shape: "circle", alt: (0, i18n_1.tr)("NAVIGATOR_ZOOM_IN", locale), title: (0, i18n_1.tr)("NAVIGATOR_ZOOM_IN", locale), coords: "25,34,8" })),
        React.createElement("img", { src: assets_1.IMG_SLIDER_SCALE, className: "png24", width: "51", height: "201", useMap: "#Navigator_ImageMap", style: { position: "absolute", left: 0, top: 0 } }),
        React.createElement("div", { style: { position: "absolute", top: 6, left: 6, width: 39, height: 16 } },
            React.createElement("img", { src: assets_1.GIF_SPINNER, className: "navigator-spinner", width: "18", height: "6", style: { position: "absolute", top: 3, right: 4, visibility: busy ? "visible" : "hidden" } })),
        React.createElement(react_draggable_1.default, { axis: "y", handle: "img.navigator-drag-handle", position: { x: 0, y: (VERT_START + pos) }, bounds: { top: VERT_START, bottom: (VERT_START + VERT_SPAN), left: 0, right: 0 }, onStart: onStart, onDrag: onDrag, onStop: onStop },
            React.createElement("div", null,
                React.createElement("img", { src: assets_1.IMG_SLIDER, className: "png24 navigator-drag-handle", width: "29", height: "12", style: { position: "relative", left: 11, top: 28 } }),
                (function () {
                    if (isDragging === true) {
                        var dragLabel = (0, i18n_1.tr)("FMT_NAVIGATOR_ZOOM_TO_SCALE", props.locale, { scale: calculateScaleForPos(previewPos).toFixed(2) });
                        return React.createElement("div", { className: "tooltip", style: { position: "relative", width: 170, right: 190, top: 28, textAlign: "right" } }, dragLabel);
                    }
                })())));
};
exports.Navigator = Navigator;


/***/ }),

/***/ "./src/components/pbmg.tsx":
/*!*********************************!*\
  !*** ./src/components/pbmg.tsx ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PoweredByMapGuide = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var icon_1 = __webpack_require__(/*! ./icon */ "./src/components/icon.tsx");
/**
 * "Powered by MapGuide" logo
 * @param props
 */
var PoweredByMapGuide = function (props) {
    return React.createElement("div", (0, tslib_1.__assign)({ className: "status-bar-component component-pbmg" }, props),
        React.createElement(icon_1.ImageIcon, { style: { display: "block" }, spriteClass: "PoweredBy_en" }));
};
exports.PoweredByMapGuide = PoweredByMapGuide;


/***/ }),

/***/ "./src/components/scale-display.tsx":
/*!******************************************!*\
  !*** ./src/components/scale-display.tsx ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScaleDisplay = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var number_1 = __webpack_require__(/*! ../utils/number */ "./src/utils/number.ts");
/**
 * A component that displays the map scale
 * @param props
 */
var ScaleDisplay = function (props) {
    var view = props.view, style = props.style, locale = props.locale, finiteScales = props.finiteScales, onScaleChanged = props.onScaleChanged;
    var _a = React.useState(undefined), localScale = _a[0], setLocalScale = _a[1];
    var onFiniteScaleChanged = function (e) { return onScaleChanged === null || onScaleChanged === void 0 ? void 0 : onScaleChanged(parseFloat(e.target.value)); };
    var onScaleKeyPressed = function (e) {
        if (e.key == 'Enter' && localScale) {
            onScaleChanged === null || onScaleChanged === void 0 ? void 0 : onScaleChanged(localScale);
        }
    };
    var onScaleInputChanged = function (e) { return setLocalScale(parseFloat(e.target.value)); };
    React.useEffect(function () {
        if (!finiteScales && view && view.scale != localScale) {
            setLocalScale(view.scale);
        }
    }, [finiteScales, view]);
    var label = (0, i18n_1.tr)("FMT_SCALE_DISPLAY", locale, {
        scale: ""
    });
    if (finiteScales) {
        var fi = (0, number_1.getFiniteScaleIndexForScale)(finiteScales, view.scale);
        var fiScale = finiteScales[fi];
        //NOTE: Not using BP styled HTML select as the size imposed is not acceptable
        return React.createElement("div", { className: "status-bar-component component-scale-display", style: style },
            label,
            " ",
            React.createElement("select", { className: "scale-input", value: fiScale, onChange: onFiniteScaleChanged }, finiteScales.map(function (s) {
                return React.createElement("option", { key: s, value: s }, s);
            })));
    }
    else {
        return React.createElement("div", { className: "status-bar-component component-scale-display", style: style },
            label,
            " ",
            React.createElement("input", { className: "scale-input", type: "number", value: localScale || "", onChange: onScaleInputChanged, onKeyPress: onScaleKeyPressed }));
    }
};
exports.ScaleDisplay = ScaleDisplay;


/***/ }),

/***/ "./src/components/selected-feature-count.tsx":
/*!***************************************************!*\
  !*** ./src/components/selected-feature-count.tsx ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectedFeatureCount = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
/**
 * Displays the number of selected features on the map
 */
var SelectedFeatureCount = function (props) {
    var format = props.format || (0, i18n_1.tr)("FMT_SELECTION_COUNT", props.locale);
    var label;
    if (props.summary) {
        label = (0, i18n_1.fmt)(format, props.summary);
    }
    return React.createElement("div", { className: "status-bar-component component-selected-feature-count", style: props.style }, label);
};
exports.SelectedFeatureCount = SelectedFeatureCount;


/***/ }),

/***/ "./src/components/selection-panel.tsx":
/*!********************************************!*\
  !*** ./src/components/selection-panel.tsx ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionPanel = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var toolbar_1 = __webpack_require__(/*! ./toolbar */ "./src/components/toolbar.tsx");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var string_1 = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");
var DefaultSelectedFeature = function (props) {
    var selectedFeature = props.selectedFeature, selectedLayer = props.selectedLayer, locale = props.locale, allowHtmlValues = props.allowHtmlValues, cleanHTML = props.cleanHTML;
    var featureProps = [];
    if (selectedLayer === null || selectedLayer === void 0 ? void 0 : selectedLayer.Property) {
        var _loop_1 = function (lp) {
            var matches = selectedFeature.Property.filter(function (fp) { return fp.Name === lp.DisplayName; });
            if (matches.length === 1) {
                featureProps.push(matches[0]);
            }
        };
        for (var _i = 0, _a = selectedLayer.Property; _i < _a.length; _i++) {
            var lp = _a[_i];
            _loop_1(lp);
        }
    }
    else {
        for (var _b = 0, _c = selectedFeature.Property; _b < _c.length; _b++) {
            var fp = _c[_b];
            featureProps.push(fp);
        }
    }
    return React.createElement("table", { className: "selection-panel-property-grid bp3-html-table bp3-html-table-condensed bp3-html-table-bordered" },
        React.createElement("thead", null,
            React.createElement("tr", null,
                React.createElement("th", null, (0, i18n_1.tr)("SELECTION_PROPERTY", locale)),
                React.createElement("th", null, (0, i18n_1.tr)("SELECTION_VALUE", locale)))),
        React.createElement("tbody", null, featureProps.map(function (prop) {
            return React.createElement("tr", { key: prop.Name },
                React.createElement("td", { className: "property-name-cell", "data-property-name": prop.Name }, prop.Name),
                (function () {
                    var value = prop.Value;
                    if (allowHtmlValues && !(0, string_1.strIsNullOrEmpty)(value)) {
                        if (cleanHTML) {
                            value = cleanHTML(value);
                        }
                        return React.createElement("td", { className: "property-value-cell", "data-property-value-for": prop.Name, dangerouslySetInnerHTML: { __html: value } });
                    }
                    else {
                        return React.createElement("td", { className: "property-value-cell", "data-property-value-for": prop.Name }, prop.Value);
                    }
                })());
        })));
};
function buildToolbarItems(selPanel) {
    return [
        {
            bpIconName: "arrow-left",
            tooltip: (0, i18n_1.tr)("SELECTION_PREV_FEATURE", selPanel.locale),
            enabled: function () { return selPanel.canGoPrev(); },
            invoke: function () { return selPanel.prevFeature(); }
        },
        {
            bpIconName: "arrow-right",
            tooltip: (0, i18n_1.tr)("SELECTION_NEXT_FEATURE", selPanel.locale),
            enabled: function () { return selPanel.canGoNext(); },
            invoke: function () { return selPanel.nextFeature(); }
        },
        { isSeparator: true },
        {
            bpIconName: "path-search",
            tooltip: (0, i18n_1.tr)("SELECTION_ZOOMTO_FEATURE", selPanel.locale),
            enabled: function () { return selPanel.canZoomSelectedFeature(); },
            invoke: function () { return selPanel.zoomSelectedFeature(); }
        }
    ];
}
var SELECTION_TOOLBAR_STYLE = { float: "right", height: toolbar_1.DEFAULT_TOOLBAR_SIZE };
var SELECTION_PANEL_TOOLBAR_STYLE = { height: toolbar_1.DEFAULT_TOOLBAR_SIZE, backgroundColor: toolbar_1.TOOLBAR_BACKGROUND_COLOR };
var LAYER_COMBO_STYLE = { float: "left", height: toolbar_1.DEFAULT_TOOLBAR_SIZE };
var FloatClear = function () { return React.createElement("div", { style: { clear: "both" } }); };
/**
 * Displays attributes of selected features with the ability to zoom in on selected features
 * @param props
 */
var SelectionPanel = function (props) {
    var maxHeight = props.maxHeight, selection = props.selection, selectedFeatureRenderer = props.selectedFeatureRenderer, allowHtmlValues = props.allowHtmlValues, cleanHTML = props.cleanHTML, onShowSelectedFeature = props.onShowSelectedFeature, onRequestZoomToFeature = props.onRequestZoomToFeature;
    var _a = React.useState(-1), selectedLayerIndex = _a[0], setSelectedLayerIndex = _a[1];
    var _b = React.useState(-1), featureIndex = _b[0], setFeatureIndex = _b[1];
    React.useEffect(function () {
        if (selection.getLayerCount() > 0) {
            if (selectedLayerIndex < 0) {
                setSelectedLayerIndex(0);
                setFeatureIndex(0);
            }
            else {
                var sl = selection.getLayerAt(selectedLayerIndex);
                if (!sl) {
                    setSelectedLayerIndex(0);
                    setFeatureIndex(0);
                }
                else {
                    if (featureIndex < 0 && sl.getFeatureCount() > 0) {
                        setFeatureIndex(0);
                    }
                }
            }
        }
    }, [selection]);
    var getCurrentLayer = function () {
        return selection.getLayerAt(selectedLayerIndex);
    };
    var getFeatureAt = function (index) {
        return selection.getFeatureAt(selectedLayerIndex, index);
    };
    var getCurrentFeature = function () {
        return getFeatureAt(featureIndex);
    };
    var canGoPrev = function () {
        return featureIndex > 0;
    };
    var canGoNext = function () {
        var layer = getCurrentLayer();
        if (layer != null) {
            return featureIndex + 1 < layer.getFeatureCount();
        }
        return false;
    };
    var canZoomSelectedFeature = function () {
        var feat = getCurrentFeature();
        return (feat === null || feat === void 0 ? void 0 : feat.Bounds) != null;
    };
    var prevFeature = function () {
        var _a;
        var newIndex = featureIndex - 1;
        setFeatureIndex(newIndex);
        var layer = getCurrentLayer();
        if (layer) {
            var layerId = layer.getLayerId();
            var sKey = (_a = getFeatureAt(newIndex)) === null || _a === void 0 ? void 0 : _a.SelectionKey;
            if (sKey && layerId) {
                onShowSelectedFeature === null || onShowSelectedFeature === void 0 ? void 0 : onShowSelectedFeature(layerId, sKey);
            }
        }
    };
    var nextFeature = function () {
        var _a;
        var newIndex = featureIndex + 1;
        setFeatureIndex(newIndex);
        var layer = getCurrentLayer();
        if (layer) {
            var layerId = layer.getLayerId();
            var sKey = (_a = getFeatureAt(newIndex)) === null || _a === void 0 ? void 0 : _a.SelectionKey;
            if (sKey && layerId) {
                onShowSelectedFeature === null || onShowSelectedFeature === void 0 ? void 0 : onShowSelectedFeature(layerId, sKey);
            }
        }
    };
    var zoomSelectedFeature = function () {
        var feat = getCurrentFeature();
        if (feat) {
            onRequestZoomToFeature(feat);
        }
    };
    var onSelectedLayerChanged = function (e) {
        setSelectedLayerIndex(e.target.value);
        setFeatureIndex(0);
    };
    var locale = props.locale || i18n_1.DEFAULT_LOCALE;
    var feat;
    var meta;
    if (selection != null && selectedLayerIndex >= 0 && featureIndex >= 0) {
        var selLayer = selection.getLayerAt(selectedLayerIndex);
        feat = selLayer === null || selLayer === void 0 ? void 0 : selLayer.getFeatureAt(featureIndex);
        meta = selLayer === null || selLayer === void 0 ? void 0 : selLayer.getLayerMetadata();
    }
    var selBodyStyle;
    if (maxHeight) {
        selBodyStyle = {
            overflowY: "auto",
            maxHeight: maxHeight - toolbar_1.DEFAULT_TOOLBAR_SIZE
        };
    }
    else {
        selBodyStyle = {
            overflow: "auto",
            position: "absolute",
            top: toolbar_1.DEFAULT_TOOLBAR_SIZE,
            bottom: 0,
            right: 0,
            left: 0
        };
    }
    return React.createElement("div", null,
        (function () {
            if ((selection === null || selection === void 0 ? void 0 : selection.getLayerCount()) > 0) {
                var selectionToolbarItems = buildToolbarItems({
                    locale: locale,
                    canGoPrev: canGoPrev,
                    canGoNext: canGoNext,
                    prevFeature: prevFeature,
                    nextFeature: nextFeature,
                    canZoomSelectedFeature: canZoomSelectedFeature,
                    zoomSelectedFeature: zoomSelectedFeature
                });
                return React.createElement("div", { className: "selection-panel-toolbar", style: SELECTION_PANEL_TOOLBAR_STYLE },
                    React.createElement("div", { className: "bp3-select selection-panel-layer-selector" },
                        React.createElement(core_1.HTMLSelect, { value: selectedLayerIndex, style: LAYER_COMBO_STYLE, onChange: onSelectedLayerChanged }, selection.getLayers().map(function (layer, index) {
                            var _a, _b;
                            var lid = layer.getLayerId();
                            var lname = layer.getName();
                            var lkey = lid !== null && lid !== void 0 ? lid : index;
                            var label = lid ? ((_b = (_a = props === null || props === void 0 ? void 0 : props.onResolveLayerLabel) === null || _a === void 0 ? void 0 : _a.call(props, lid, lname)) !== null && _b !== void 0 ? _b : lname)
                                : lname;
                            return React.createElement("option", { key: "selected-layer-" + lkey, value: "" + index }, label);
                        }))),
                    React.createElement(toolbar_1.Toolbar, { childItems: selectionToolbarItems, containerStyle: SELECTION_TOOLBAR_STYLE }),
                    React.createElement(FloatClear, null));
            }
        })(),
        React.createElement("div", { className: "selection-panel-body", style: selBodyStyle }, (function () {
            if (feat) {
                if (selectedFeatureRenderer) {
                    return selectedFeatureRenderer({ selectedFeature: feat, cleanHTML: cleanHTML, allowHtmlValues: allowHtmlValues, selectedLayer: meta, locale: locale });
                }
                else {
                    return React.createElement(DefaultSelectedFeature, { selectedFeature: feat, cleanHTML: cleanHTML, allowHtmlValues: allowHtmlValues, selectedLayer: meta, locale: locale });
                }
            }
            else if (!((selection === null || selection === void 0 ? void 0 : selection.getLayerCount()) > 0)) {
                return React.createElement(core_1.Callout, { intent: core_1.Intent.PRIMARY, icon: "info-sign" },
                    React.createElement("p", { className: "selection-panel-no-selection" }, (0, i18n_1.tr)("NO_SELECTED_FEATURES", locale)));
            }
        })()));
};
exports.SelectionPanel = SelectionPanel;


/***/ }),

/***/ "./src/components/session-expired.tsx":
/*!********************************************!*\
  !*** ./src/components/session-expired.tsx ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionExpired = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
function reload(e) {
    e.preventDefault();
    //TODO: This is obviously the nuclear solution.
    //
    //The more graceful solution is to re-create the runtime map and interleave the response
    //into the current redux store and preserve the existing view and layer/group state and
    //we should be able to continue where we left off
    window.location.reload();
    return false;
}
/**
 * Displays the "session expired" error message with possible recovery actions
 * @param props
 */
var SessionExpired = function (props) {
    return React.createElement("div", { className: "component-session-expired" },
        React.createElement("p", null, (0, i18n_1.tr)("SESSION_EXPIRED_DETAILED", props.locale)),
        React.createElement("p", null,
            React.createElement("strong", null, (0, i18n_1.tr)("SESSION_EXPIRED_AVAILABLE_ACTIONS", props.locale))),
        React.createElement("ul", null,
            React.createElement("li", null,
                React.createElement("a", { href: "#", onClick: reload }, (0, i18n_1.tr)("SESSION_EXPIRED_RELOAD_VIEWER", props.locale)))));
};
exports.SessionExpired = SessionExpired;


/***/ }),

/***/ "./src/components/session-keep-alive.tsx":
/*!***********************************************!*\
  !*** ./src/components/session-keep-alive.tsx ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionKeepAlive = void 0;
var SessionKeepAlive = /** @class */ (function () {
    function SessionKeepAlive(getSession, client, onSessionExpired, check) {
        var _this = this;
        this.check = check;
        this.getSession = getSession;
        this.client = client;
        if (this.check) {
            this.client.getServerSessionTimeout(this.getSession()).then(function (tm) {
                _this.interval = tm / 5 * 1000; //Ping server 5 times each period. Timeout is returned in seconds.
                _this.timeoutID = setTimeout(_this.tick.bind(_this), _this.interval);
            });
        }
    }
    SessionKeepAlive.prototype.dispose = function () {
        clearTimeout(this.timeoutID);
    };
    SessionKeepAlive.prototype.tick = function () {
        var _this = this;
        this.client.getServerSessionTimeout(this.getSession()).then(function (tm) {
            _this.timeoutID = setTimeout(_this.tick.bind(_this), _this.interval);
        });
    };
    SessionKeepAlive.prototype.lastTry = function () {
        if (this.check) {
            return this.client.getServerSessionTimeout(this.getSession());
        }
        else {
            return Promise.resolve(-1);
        }
    };
    return SessionKeepAlive;
}());
exports.SessionKeepAlive = SessionKeepAlive;


/***/ }),

/***/ "./src/components/task-pane.tsx":
/*!**************************************!*\
  !*** ./src/components/task-pane.tsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskPane = exports.TASK_PANE_OVERLAY_BGCOLOR = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var ReactDOM = (0, tslib_1.__importStar)(__webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"));
var toolbar_1 = __webpack_require__(/*! ./toolbar */ "./src/components/toolbar.tsx");
var component_1 = __webpack_require__(/*! ../api/registry/component */ "./src/api/registry/component.tsx");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var url_1 = __webpack_require__(/*! ../utils/url */ "./src/utils/url.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
exports.TASK_PANE_OVERLAY_BGCOLOR = "#dee8f9";
function currentUrlDoesNotMatchMapName(currentUrl, mapName) {
    var normUrl = currentUrl.toLowerCase();
    //Only invalidate if url has mapname and it doesn't match our current one
    if (normUrl.indexOf("mapname=") >= 0 && mapName) {
        return normUrl.indexOf("mapname=" + mapName.toLowerCase()) < 0;
    }
    else {
        return false;
    }
}
// HACK:
//
// Having the lastUrlPushed props sounds extremely hacky, but we need a way to signal that
// the url its about to receive was pushed and should not be reloaded into the internal iframe
//
// This is because we want internal url transitions (eg. Clicking a link, submitting a form) to
// be recorded in the navigation stack so we can properly go back/forward just like a web browser.
// But we don't want these recorded URLs to accidentally trigger a re-load of the same url.
/**
 * A component that serves as a generic container for content or User Interface for custom functionality
 *
 * @export
 * @class TaskPane
 * @extends {React.Component<ITaskPaneProps, any>}
 */
var TaskPane = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(TaskPane, _super);
    function TaskPane(props) {
        var _this = _super.call(this, props) || this;
        _this.onCloseFlyout = function (id) { var _a, _b; return (_b = (_a = _this.props).onCloseFlyout) === null || _b === void 0 ? void 0 : _b.call(_a, id); };
        _this.onOpenFlyout = function (id, metrics) { var _a, _b; return (_b = (_a = _this.props).onOpenFlyout) === null || _b === void 0 ? void 0 : _b.call(_a, id, metrics); };
        _this.onFrameMounted = function (iframe) {
            _this._iframe = iframe;
            if (_this._iframe) {
                var el = ReactDOM.findDOMNode(_this._iframe);
                //This is needed for backcompat with certain fusion widgets
                el.taskPaneId = constants_1.FUSION_TASKPANE_NAME;
            }
        };
        _this.onFrameLoaded = function (e) {
            var frame = e.currentTarget;
            if (frame.contentWindow) {
                _this.setState({ frameContentLoaded: true });
                _this.props.onUrlLoaded(frame.contentWindow.location.href);
            }
        };
        _this.taskButtons = [
            props.homeAction,
            { isSeparator: true },
            props.backAction,
            props.forwardAction
        ];
        _this.state = {
            activeComponent: null,
            invalidated: false,
            frameContentLoaded: false
        };
        return _this;
    }
    TaskPane.prototype.componentDidUpdate = function (prevProps) {
        var nextProps = this.props;
        if (prevProps.currentUrl != nextProps.currentUrl) {
            if (nextProps.currentUrl && nextProps.lastUrlPushed === false) {
                this.loadUrl(nextProps.currentUrl);
            }
        }
        if (!this.state.invalidated && nextProps.currentUrl && nextProps.currentUrl.indexOf("component://") != 0 && currentUrlDoesNotMatchMapName(nextProps.currentUrl, nextProps.mapName)) {
            //TODO: If we want to be smart, we could have the TaskPane amend the currentUrl with the new map name
            this.setState({ invalidated: true });
        }
        else if (this.state.invalidated && nextProps.currentUrl && (nextProps.currentUrl.indexOf("component://") == 0 || !currentUrlDoesNotMatchMapName(nextProps.currentUrl, nextProps.mapName))) {
            this.setState({ invalidated: false });
        }
    };
    TaskPane.prototype.componentDidMount = function () {
        if (this.props.currentUrl) {
            this.loadUrl(this.props.currentUrl);
        }
    };
    TaskPane.prototype.loadUrl = function (url) {
        var _this = this;
        //TODO: Can't convert this to functional component with hooks, until this type
        //of pattern is possible
        var compUri = (0, url_1.parseComponentUri)(url);
        if (compUri) {
            this.setState({ activeComponent: compUri.name, activeComponentProps: compUri.props });
        }
        else {
            this.setState({ activeComponent: null, frameContentLoaded: false }, function () {
                var _a;
                if (_this._iframe) {
                    (_a = _this._iframe.contentWindow) === null || _a === void 0 ? void 0 : _a.location.replace(url);
                }
            });
        }
    };
    TaskPane.prototype.render = function () {
        var _this = this;
        var _a = this.state, invalidated = _a.invalidated, activeComponent = _a.activeComponent;
        var _b = this.props, locale = _b.locale, maxHeight = _b.maxHeight, showTaskBar = _b.showTaskBar;
        var taskMenu = {
            label: (0, i18n_1.tr)("MENU_TASKS", locale),
            flyoutAlign: "bottom left",
            flyoutId: constants_1.WEBLAYOUT_TASKMENU
        };
        var rootStyle = {};
        var taskBarStyle = {
            height: toolbar_1.DEFAULT_TOOLBAR_SIZE,
            backgroundColor: toolbar_1.TOOLBAR_BACKGROUND_COLOR
        };
        var taskBodyStyle = {};
        var taskFrameStyle = {
            border: "none"
        };
        var taskComponentContainerStyle = {
            border: "none"
        };
        if (!maxHeight) {
            rootStyle.width = "100%";
            rootStyle.height = "100%";
            taskBarStyle.position = "absolute";
            taskBarStyle.top = 0;
            taskBarStyle.left = 0;
            taskBarStyle.right = 0;
            taskBodyStyle.position = "absolute";
            taskBodyStyle.top = (showTaskBar === true ? toolbar_1.DEFAULT_TOOLBAR_SIZE : 0);
            taskBodyStyle.left = 0;
            taskBodyStyle.right = 0;
            taskBodyStyle.bottom = 0;
            taskBodyStyle.overflow = "hidden";
            taskFrameStyle.width = "100%";
            taskFrameStyle.height = "100%";
            taskComponentContainerStyle.width = "100%";
            taskComponentContainerStyle.height = "100%";
        }
        else {
            taskFrameStyle.width = "100%";
            taskFrameStyle.height = (showTaskBar === true ? (maxHeight - toolbar_1.DEFAULT_TOOLBAR_SIZE) : maxHeight);
            taskComponentContainerStyle.width = "100%";
            taskComponentContainerStyle.maxHeight = (showTaskBar === true ? (maxHeight - toolbar_1.DEFAULT_TOOLBAR_SIZE) : maxHeight);
            taskComponentContainerStyle.overflowY = "auto";
        }
        return React.createElement("div", { style: rootStyle },
            (function () {
                if (showTaskBar === true) {
                    return React.createElement("div", { style: taskBarStyle },
                        React.createElement(toolbar_1.Toolbar, { childItems: _this.taskButtons, containerStyle: { float: "left", height: toolbar_1.DEFAULT_TOOLBAR_SIZE }, onCloseFlyout: _this.onCloseFlyout, onOpenFlyout: _this.onOpenFlyout, flyoutStates: _this.props.flyoutStates }),
                        React.createElement(toolbar_1.Toolbar, { childItems: [taskMenu], containerStyle: { float: "right", height: toolbar_1.DEFAULT_TOOLBAR_SIZE }, onCloseFlyout: _this.onCloseFlyout, onOpenFlyout: _this.onOpenFlyout, flyoutStates: _this.props.flyoutStates }),
                        React.createElement("div", { style: { clear: "both" } }));
                }
            })(),
            React.createElement("div", { style: taskBodyStyle },
                (function () {
                    if (activeComponent != null) {
                        var cpp = _this.state.activeComponentProps;
                        taskComponentContainerStyle.overflowY = "auto";
                        return React.createElement("div", { style: taskComponentContainerStyle },
                            React.createElement(component_1.PlaceholderComponent, { id: activeComponent, componentProps: cpp, locale: _this.props.locale }));
                    }
                    else {
                        var frameContentLoaded = _this.state.frameContentLoaded;
                        var components = [
                            React.createElement("iframe", { key: "taskPaneFrame", name: "taskPaneFrame", ref: _this.onFrameMounted, onLoad: _this.onFrameLoaded, style: taskFrameStyle })
                        ];
                        if (frameContentLoaded == false) {
                            components.push(React.createElement("div", { key: "taskPaneFrameLoadingOverlay", style: { position: "absolute", left: 0, right: 0, top: 0, bottom: 0, backgroundColor: exports.TASK_PANE_OVERLAY_BGCOLOR } },
                                React.createElement(core_1.NonIdealState, { icon: React.createElement(core_1.Spinner, { intent: core_1.Intent.NONE, size: core_1.Spinner.SIZE_LARGE }), title: (0, i18n_1.tr)("TASK_PANE_LOADING", locale), description: (0, i18n_1.tr)("TASK_PANE_LOADING_DESC", locale) })));
                        }
                        return components;
                    }
                })(),
                React.createElement("iframe", { name: "scriptFrame", style: { width: 0, height: 0, visibility: "hidden" } })));
    };
    return TaskPane;
}(React.Component));
exports.TaskPane = TaskPane;


/***/ }),

/***/ "./src/components/toolbar.tsx":
/*!************************************!*\
  !*** ./src/components/toolbar.tsx ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Toolbar = exports.FlyoutMenuChildItem = exports.getIconStyle = exports.getEnabled = exports.TOOLBAR_BACKGROUND_COLOR = exports.DEFAULT_TOOLBAR_SIZE = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var type_guards_1 = __webpack_require__(/*! ../utils/type-guards */ "./src/utils/type-guards.ts");
var context_1 = __webpack_require__(/*! ./context */ "./src/components/context.ts");
var string_1 = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");
var icon_1 = __webpack_require__(/*! ./icon */ "./src/components/icon.tsx");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
exports.DEFAULT_TOOLBAR_SIZE = 29;
exports.TOOLBAR_BACKGROUND_COLOR = "#f0f0f0";
// Custom type guard to workaround: https://github.com/microsoft/TypeScript/issues/39879
function isNumeric(arg) {
    return typeof (arg) == 'number';
}
// Size is based on the default toolbar height of 29 (with base image icon size of 16x16)
// This ratio will help "scale" SVG icons to match
var SVG_SIZE_RATIO = 16 / exports.DEFAULT_TOOLBAR_SIZE;
function getSelected(item) {
    var sel = item.selected;
    if (sel != null) {
        if (typeof sel === 'function') {
            return sel();
        }
        else {
            return sel;
        }
    }
    return false;
}
function getEnabled(item) {
    var en = item.enabled;
    if (en != null) {
        if (typeof en === 'function') {
            return en();
        }
        else {
            return en;
        }
    }
    return true;
}
exports.getEnabled = getEnabled;
function getIconElement(item, enabled, size) {
    var iconStyle = getIconStyle(enabled, size);
    if (item.iconClass || item.icon) {
        return React.createElement(icon_1.ImageIcon, { style: iconStyle, url: item.icon, spriteClass: item.iconClass });
    }
    else if (item.bpIconName) {
        var opacity = iconStyle.opacity; //For SVG, we only care about opacity
        return React.createElement(core_1.Icon, { style: { opacity: opacity }, icon: item.bpIconName, iconSize: size * SVG_SIZE_RATIO });
    }
    else {
        return React.createElement(React.Fragment, null);
    }
}
function getFlyoutIconElement(isFlownOut, size) {
    return React.createElement(core_1.Icon, { icon: isFlownOut ? "chevron-up" : "chevron-down", iconSize: size * SVG_SIZE_RATIO });
}
function getTooltip(item) {
    var tt = item.tooltip;
    if (tt != null) {
        if (typeof tt === 'function') {
            return tt();
        }
        else {
            return tt;
        }
    }
    return string_1.STR_EMPTY;
}
function getIconStyle(enabled, height) {
    var imgStyle = {
        verticalAlign: "middle",
        lineHeight: height
    };
    return imgStyle;
}
exports.getIconStyle = getIconStyle;
function getItemStyle(enabled, selected, size, isMouseOver, vertical) {
    var pad = ((size - 16) / 2);
    var vertPad = 6;
    var style = {
        display: vertical === true ? "block" : "inline-block",
        //height: height,
        paddingLeft: pad,
        paddingRight: pad,
        paddingTop: vertPad,
        paddingBottom: vertPad
    };
    if ((isMouseOver === true && enabled === true) || selected) {
        style.borderWidth = 1;
        style.paddingLeft = pad - 1; //To compensate for border
        style.paddingRight = pad - 1; //To compensate for border
        style.paddingTop = vertPad - 1; //To compensate for border
        style.paddingBottom = vertPad - 1; //To compensate for border
    }
    return style;
}
function getToolbarSeparatorItemStyle(vertical) {
    var style = {
        display: vertical === true ? "block" : "inline-block"
    };
    if (vertical === true) {
        style.paddingTop = 2;
        style.paddingBottom = -2;
        style.marginLeft = 0;
        style.marginRight = 0;
    }
    else {
        style.paddingTop = 0;
        style.paddingBottom = 0;
        style.marginLeft = 2;
        style.marginRight = -2;
    }
    return style;
}
function getMenuItemStyle(enabled, selected, height, isMouseOver) {
    var pad = ((height - 16) / 2);
    var vertPad = 6;
    var style = {
        //height: height,
        paddingLeft: pad,
        paddingRight: pad,
        paddingTop: vertPad,
        paddingBottom: vertPad
    };
    if (enabled && (isMouseOver === true || selected)) {
        style.cursor = "pointer";
        style.border = "1px solid rgb(153, 181, 202)";
        style.paddingLeft = pad - 1; //To compensate for border
        style.paddingRight = pad - 1; //To compensate for border
        style.paddingTop = vertPad - 1; //To compensate for border
        style.paddingBottom = vertPad - 1; //To compensate for border
    }
    return style;
}
var FlyoutMenuChildItem = function (props) {
    var item = props.item;
    var _a = React.useState(false), isMouseOver = _a[0], setIsMouseOver = _a[1];
    var onClick = function () {
        var _a, _b;
        if (getEnabled(item)) {
            (_a = item.invoke) === null || _a === void 0 ? void 0 : _a.call(item);
            (_b = props.onInvoked) === null || _b === void 0 ? void 0 : _b.call(props);
        }
    };
    var onMouseLeave = function () {
        setIsMouseOver(false);
    };
    var onMouseEnter = function () {
        setIsMouseOver(true);
    };
    var height = exports.DEFAULT_TOOLBAR_SIZE;
    var selected = getSelected(item);
    var enabled = getEnabled(item);
    var tt = getTooltip(item);
    var style = getMenuItemStyle(enabled, selected, height, isMouseOver);
    var iconEl = getIconElement(item, enabled, height);
    return React.createElement("li", { className: "noselect flyout-menu-child-item", title: tt, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, onClick: onClick },
        React.createElement("div", { style: style },
            iconEl,
            " ",
            item.label));
};
exports.FlyoutMenuChildItem = FlyoutMenuChildItem;
var ComponentFlyoutItem = function (props) {
    var size = props.size, item = props.item, vertical = props.vertical, isFlownOut = props.isFlownOut;
    var toolbarCtx = React.useContext(context_1.ToolbarContext);
    var _a = React.useState(false), isMouseOver = _a[0], setIsMouseOver = _a[1];
    var onClick = function (e) {
        e.preventDefault();
        var flyoutId = item.flyoutId, componentName = item.componentName, componentProps = item.componentProps;
        var newState = !!!isFlownOut;
        if (newState) {
            var rect = e.currentTarget.getBoundingClientRect();
            var metrics = {
                posX: rect.left,
                posY: rect.top,
                width: rect.width,
                height: rect.height,
                vertical: vertical
            };
            toolbarCtx.openComponent(flyoutId, metrics, componentName, componentProps);
        }
        else {
            toolbarCtx.closeComponent(flyoutId);
        }
        return false;
    };
    var onMouseLeave = function () {
        setIsMouseOver(false);
    };
    var onMouseEnter = function () {
        setIsMouseOver(true);
    };
    var selected = getSelected(item);
    var enabled = getEnabled(item);
    var style = getItemStyle(enabled, selected, size, isMouseOver, vertical);
    var label = item.label;
    if (vertical === true) {
        label = React.createElement("div", { className: "rotated-text" },
            React.createElement("span", { className: "rotated-text__inner rotated-text-ccw" }, item.label));
    }
    var ttip = getTooltip(item);
    var iconEl = getIconElement(item, enabled, size);
    return React.createElement("div", { className: "noselect toolbar-flyout-btn " + (selected ? "selected-item" : "") + " " + (isMouseOver ? "mouse-over" : ""), onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, onClick: onClick, style: style, title: ttip },
        React.createElement("div", { "data-flyout-id": "flyout-" + item.flyoutId },
            iconEl,
            " ",
            label,
            " ",
            getFlyoutIconElement(isFlownOut, size)));
};
var FlyoutMenuReferenceItem = function (props) {
    var size = props.size, menu = props.menu, vertical = props.vertical, isFlownOut = props.isFlownOut;
    var toolbarCtx = React.useContext(context_1.ToolbarContext);
    var _a = React.useState(false), isMouseOver = _a[0], setIsMouseOver = _a[1];
    var onClick = function (e) {
        e.preventDefault();
        var newState = !!!isFlownOut;
        if (newState) {
            var rect = e.currentTarget.getBoundingClientRect();
            var metrics = {
                posX: rect.left,
                posY: rect.top,
                width: rect.width,
                height: rect.height,
                vertical: vertical
            };
            toolbarCtx.openFlyout(menu.flyoutId, metrics);
        }
        else {
            toolbarCtx.closeFlyout(menu.flyoutId);
        }
        return false;
    };
    var onMouseLeave = function () {
        setIsMouseOver(false);
    };
    var onMouseEnter = function () {
        setIsMouseOver(true);
    };
    var selected = getSelected(menu);
    var enabled = getEnabled(menu);
    var style = getItemStyle(enabled, selected, size, isMouseOver, vertical);
    var label = menu.label;
    if (vertical === true) {
        label = React.createElement("div", { className: "rotated-text" },
            React.createElement("span", { className: "rotated-text__inner rotated-text-ccw" }, menu.label));
    }
    var align = menu.flyoutAlign;
    if (!align) {
        align = (vertical === true) ? "right bottom" : "bottom right";
    }
    var ttip = getTooltip(menu);
    var iconEl = getIconElement(menu, enabled, size);
    return React.createElement("div", { className: "noselect toolbar-flyout-btn " + (selected ? "selected-item" : "") + " " + (isMouseOver ? "mouse-over" : ""), onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, onClick: onClick, style: style, title: ttip },
        React.createElement("div", { "data-flyout-id": "flyout-" + menu.flyoutId },
            iconEl,
            " ",
            label,
            " ",
            getFlyoutIconElement(isFlownOut, size)));
};
var ToolbarSeparator = function (props) {
    var style = getToolbarSeparatorItemStyle(props.vertical);
    if (props.vertical === true) {
        return React.createElement("div", { className: "noselect toolbar-separator-vertical", style: style });
    }
    else {
        return React.createElement("div", { className: "noselect toolbar-separator-horizontal", style: style }, constants_1.NBSP);
    }
};
var ToolbarButton = function (props) {
    var height = props.height, item = props.item, vertical = props.vertical, hideVerticalLabels = props.hideVerticalLabels;
    var _a = React.useState(false), isMouseOver = _a[0], setIsMouseOver = _a[1];
    var onMouseLeave = function () {
        setIsMouseOver(false);
    };
    var onMouseEnter = function () {
        setIsMouseOver(true);
    };
    var onClick = function (e) {
        e.preventDefault();
        var item = props.item;
        var enabled = getEnabled(item);
        if (enabled && item.invoke) {
            item.invoke();
        }
        return false;
    };
    var selected = getSelected(item);
    var enabled = getEnabled(item);
    var style = getItemStyle(enabled, selected, height, isMouseOver, vertical);
    var ttip = null;
    if (typeof (item.tooltip) == 'function') {
        ttip = item.tooltip();
    }
    else {
        ttip = item.tooltip;
    }
    if (!enabled) {
        style.opacity = 0.3;
    }
    var iconEl = getIconElement(item, enabled, height);
    return React.createElement("div", { className: "noselect toolbar-btn " + (selected ? "selected-item" : "") + " " + ((isMouseOver && enabled) ? "mouse-over" : ""), onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, style: style, title: ttip, onClick: onClick },
        iconEl,
        " ",
        (vertical == true && hideVerticalLabels == true) ? null : item.label);
};
/**
 * A generic toolbar component
 * @param props
 */
var Toolbar = function (props) {
    var containerStyle = props.containerStyle, containerClass = props.containerClass, childItems = props.childItems, vertical = props.vertical, hideVerticalLabels = props.hideVerticalLabels, flyoutStates = props.flyoutStates, onOpenFlyout = props.onOpenFlyout, onCloseFlyout = props.onCloseFlyout, onOpenComponent = props.onOpenComponent, onCloseComponent = props.onCloseComponent;
    var openFlyout = function (id, metrics) { return onOpenFlyout === null || onOpenFlyout === void 0 ? void 0 : onOpenFlyout(id, metrics); };
    var closeFlyout = function (id) { return onCloseFlyout === null || onCloseFlyout === void 0 ? void 0 : onCloseFlyout(id); };
    var openComponent = function (id, metrics, name, props) { return onOpenComponent === null || onOpenComponent === void 0 ? void 0 : onOpenComponent(id, metrics, name, props); };
    var closeComponent = function (id) { return onCloseComponent === null || onCloseComponent === void 0 ? void 0 : onCloseComponent(id); };
    var height = exports.DEFAULT_TOOLBAR_SIZE;
    if (containerStyle) {
        var ch = containerStyle.height;
        if (isNumeric(ch)) {
            height = ch;
        }
    }
    var providerImpl = {
        openFlyout: openFlyout,
        closeFlyout: closeFlyout,
        openComponent: openComponent,
        closeComponent: closeComponent
    };
    return React.createElement(context_1.ToolbarContext.Provider, { value: providerImpl },
        React.createElement("div", { style: containerStyle, className: "has-flyout noselect " + containerClass }, childItems.map(function (item, index) {
            if ((0, type_guards_1.isComponentFlyout)(item)) {
                var isFlownOut = flyoutStates && !!flyoutStates[item.flyoutId];
                return React.createElement(ComponentFlyoutItem, { key: index, size: height, item: item, vertical: vertical, isFlownOut: isFlownOut });
            }
            else if ((0, type_guards_1.isMenuRef)(item)) {
                var isFlownOut = flyoutStates && !!flyoutStates[item.flyoutId];
                return React.createElement(FlyoutMenuReferenceItem, { key: index, size: height, menu: item, vertical: vertical, isFlownOut: isFlownOut });
            }
            else if (item.isSeparator === true) {
                return React.createElement(ToolbarSeparator, { key: index, size: height, vertical: vertical });
            }
            else {
                return React.createElement(ToolbarButton, { key: index, height: height, item: item, vertical: vertical, hideVerticalLabels: hideVerticalLabels });
            }
        })));
};
exports.Toolbar = Toolbar;


/***/ }),

/***/ "./src/components/tooltips/feature.ts":
/*!********************************************!*\
  !*** ./src/components/tooltips/feature.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FeatureQueryTooltip = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var OverlayPositioning_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/OverlayPositioning */ "./node_modules/ol/OverlayPositioning.js"));
var lodash_debounce_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! lodash.debounce */ "./node_modules/lodash.debounce/index.js"));
var Overlay_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/Overlay */ "./node_modules/ol/Overlay.js"));
var WKT_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/format/WKT */ "./node_modules/ol/format/WKT.js"));
var Polygon_1 = __webpack_require__(/*! ol/geom/Polygon */ "./node_modules/ol/geom/Polygon.js");
var client_1 = __webpack_require__(/*! ../../api/client */ "./src/api/client.ts");
var olExtent = (0, tslib_1.__importStar)(__webpack_require__(/*! ol/extent */ "./node_modules/ol/extent.js"));
var error_1 = __webpack_require__(/*! ../../api/error */ "./src/api/error.ts");
var i18n_1 = __webpack_require__(/*! ../../api/i18n */ "./src/api/i18n.ts");
var logger_1 = __webpack_require__(/*! ../../utils/logger */ "./src/utils/logger.ts");
var FeatureQueryTooltip = /** @class */ (function () {
    function FeatureQueryTooltip(map, callback) {
        var _this = this;
        this.setLinkClickHandler = function () {
            if (_this.linkElement) {
                _this.linkElement.onclick = _this.handleLinkClick;
            }
        };
        this.handleLinkClick = function (e) {
            e.preventDefault();
            _this.callback.openTooltipLink(e.target.href);
            return false;
        };
        this.callback = callback;
        this.wktFormat = new WKT_1.default();
        this.featureTooltipElement = document.createElement("div");
        this.featureTooltipElement.addEventListener("mouseover", function () { return _this.isMouseOverTooltip = true; });
        this.featureTooltipElement.addEventListener("mouseout", function () { return _this.isMouseOverTooltip = false; });
        this.featureTooltipElement.className = 'feature-tooltip';
        this.featureTooltip = new Overlay_1.default({
            element: this.featureTooltipElement,
            offset: [15, 0],
            positioning: OverlayPositioning_1.default.CENTER_LEFT
        });
        this.map = map;
        this.map.addOverlay(this.featureTooltip);
        this.throttledMouseMove = (0, lodash_debounce_1.default)(function (e) {
            _this.raiseQueryFromPoint(e.pixel);
        }, 1000);
        this.enabled = true;
        this.isMouseOverTooltip = false;
    }
    FeatureQueryTooltip.prototype.dispose = function () {
        this.featureTooltip.dispose();
    };
    Object.defineProperty(FeatureQueryTooltip.prototype, "isMouseOver", {
        get: function () { return this.isMouseOverTooltip; },
        enumerable: false,
        configurable: true
    });
    FeatureQueryTooltip.prototype.raiseQueryFromPoint = function (pixel) {
        var box = this.callback.getPointSelectionBox(pixel);
        var geom = (0, Polygon_1.fromExtent)(box);
        (0, logger_1.debug)("[" + new Date() + "] FeatureTooltip - onMouseMove (" + box[0] + ", " + box[1] + ") (" + box[2] + ", " + box[3] + ")");
        this.sendTooltipQuery(geom);
    };
    FeatureQueryTooltip.prototype.onMouseMove = function (e) {
        this.throttledMouseMove(e);
    };
    FeatureQueryTooltip.prototype.isEnabled = function () {
        return this.enabled;
    };
    FeatureQueryTooltip.prototype.setEnabled = function (enabled) {
        this.enabled = enabled;
        if (!this.enabled) {
            this.featureTooltipElement.innerHTML = "";
            this.featureTooltipElement.classList.add("tooltip-hidden");
            if (this.linkElement) {
                this.linkElement.onclick = null;
            }
        }
    };
    FeatureQueryTooltip.prototype.sendTooltipQuery = function (geom) {
        var _this = this;
        if (!this.enabled) {
            return;
        }
        if (this.isMouseOverTooltip) {
            (0, logger_1.debug)("Mouse over tooltip. Doing nothing");
            return;
        }
        //const selectedLayerNames = this.onRequestSelectableLayers();
        //if (selectedLayerNames != null && selectedLayerNames.length == 0) {
        //    return;
        //}
        var reqQueryFeatures = 4 | 8; //Tooltips and hyperlinks
        var wkt = this.wktFormat.writeGeometry(geom);
        var client = new client_1.Client(this.callback.getAgentUri(), this.callback.getAgentKind());
        //This is probably a case of blink and you'll miss
        //
        //this.featureTooltipElement.innerHTML = "Querying tooltip data ...";
        //this.featureTooltipElement.classList.remove("tooltip-hidden");
        var coords = olExtent.getCenter(geom.getExtent());
        this.featureTooltip.setPosition(coords);
        this.callback.incrementBusyWorker();
        client.queryMapFeatures({
            mapname: this.callback.getMapName(),
            session: this.callback.getSessionId(),
            //layernames: selectedLayerNames != null ? selectedLayerNames.join(",") : null,
            geometry: wkt,
            persist: 0,
            selectionvariant: "INTERSECTS",
            maxfeatures: 1,
            requestdata: reqQueryFeatures,
            layerattributefilter: 5
        }).then(function (res) {
            var html = "";
            if (res.Tooltip) {
                html += "<div class='feature-tooltip-body'>" + res.Tooltip.replace(/\\n/g, "<br/>") + "</div>";
            }
            if (res.Hyperlink) {
                html += "<div><a id='feature-tooltip-link' href='" + res.Hyperlink + "'>" + (0, i18n_1.tr)("FEATURE_TOOLTIP_URL_HELP_TEXT", _this.callback.getLocale()) + "</a></div>";
            }
            _this.featureTooltipElement.innerHTML = html;
            _this.linkElement = document.getElementById("feature-tooltip-link");
            _this.setLinkClickHandler();
            if (html == "") {
                _this.featureTooltipElement.classList.add("tooltip-hidden");
                if (_this.linkElement) {
                    _this.linkElement.onclick = null;
                }
            }
            else {
                _this.featureTooltipElement.classList.remove("tooltip-hidden");
            }
        }).then(function () {
            _this.callback.decrementBusyWorker();
        }).catch(function (err) {
            _this.callback.decrementBusyWorker();
            if ((0, error_1.isSessionExpiredError)(err)) {
                _this.callback.onSessionExpired();
            }
        });
    };
    return FeatureQueryTooltip;
}());
exports.FeatureQueryTooltip = FeatureQueryTooltip;


/***/ }),

/***/ "./src/components/tooltips/mouse.ts":
/*!******************************************!*\
  !*** ./src/components/tooltips/mouse.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MouseTrackingTooltip = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var Overlay_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/Overlay */ "./node_modules/ol/Overlay.js"));
var OverlayPositioning_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/OverlayPositioning */ "./node_modules/ol/OverlayPositioning.js"));
var HIDDEN_CLASS_NAME = "tooltip-hidden";
var MouseTrackingTooltip = /** @class */ (function () {
    function MouseTrackingTooltip(map, contextMenuTest) {
        this.map = map;
        this.isContextMenuOpen = contextMenuTest;
        this.map.getViewport().addEventListener("mouseout", this.onMouseOut.bind(this));
        this.tooltipElement = document.createElement("div");
        this.tooltipElement.className = 'tooltip';
        this.tooltip = new Overlay_1.default({
            element: this.tooltipElement,
            offset: [15, 0],
            positioning: OverlayPositioning_1.default.CENTER_LEFT
        });
        this.map.addOverlay(this.tooltip);
        this.text = null;
        this.tooltipElement.classList.add(HIDDEN_CLASS_NAME);
    }
    MouseTrackingTooltip.prototype.dispose = function () {
        this.tooltip.dispose();
    };
    MouseTrackingTooltip.prototype.onMouseMove = function (e) {
        if (this.isContextMenuOpen())
            return;
        this.tooltip.setPosition(e.coordinate);
        if (this.text)
            this.tooltipElement.classList.remove(HIDDEN_CLASS_NAME);
        else
            this.tooltipElement.classList.add(HIDDEN_CLASS_NAME);
    };
    MouseTrackingTooltip.prototype.onMouseOut = function () {
        this.tooltipElement.classList.add(HIDDEN_CLASS_NAME);
    };
    MouseTrackingTooltip.prototype.setText = function (prompt) {
        this.text = prompt;
        this.tooltipElement.innerHTML = this.text;
    };
    MouseTrackingTooltip.prototype.clear = function () {
        this.text = null;
        this.tooltipElement.innerHTML = "";
    };
    MouseTrackingTooltip.prototype.destroy = function () {
        if (this.tooltipElement && this.tooltipElement.parentNode) {
            this.tooltipElement.parentNode.removeChild(this.tooltipElement);
        }
    };
    return MouseTrackingTooltip;
}());
exports.MouseTrackingTooltip = MouseTrackingTooltip;


/***/ }),

/***/ "./src/components/tooltips/selected-features.ts":
/*!******************************************************!*\
  !*** ./src/components/tooltips/selected-features.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectedFeaturesTooltip = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var Overlay_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/Overlay */ "./node_modules/ol/Overlay.js"));
var Image_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Image */ "./node_modules/ol/layer/Image.js"));
var Tile_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Tile */ "./node_modules/ol/layer/Tile.js"));
var ImageWMS_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/ImageWMS */ "./node_modules/ol/source/ImageWMS.js"));
var TileWMS_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/TileWMS */ "./node_modules/ol/source/TileWMS.js"));
var GeoJSON_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/format/GeoJSON */ "./node_modules/ol/format/GeoJSON.js"));
var OverlayPositioning_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/OverlayPositioning */ "./node_modules/ol/OverlayPositioning.js"));
var i18n_1 = __webpack_require__(/*! ../../api/i18n */ "./src/api/i18n.ts");
var common_1 = __webpack_require__(/*! ../../api/common */ "./src/api/common.ts");
var client_1 = __webpack_require__(/*! ../../api/client */ "./src/api/client.ts");
var wfs_capabilities_panel_1 = __webpack_require__(/*! ../layer-manager/wfs-capabilities-panel */ "./src/components/layer-manager/wfs-capabilities-panel.tsx");
var string_1 = __webpack_require__(/*! ../../utils/string */ "./src/utils/string.ts");
var ol_style_helpers_1 = __webpack_require__(/*! ../../api/ol-style-helpers */ "./src/api/ol-style-helpers.ts");
var stickybits_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! stickybits */ "./node_modules/stickybits/dist/stickybits.es.js"));
function defaultPopupContentRenderer(feat, locale, popupConfig) {
    var _a, _b, _c, _d;
    var html = "";
    var bClustered = (0, ol_style_helpers_1.isClusteredFeature)(feat);
    var title = (_a = popupConfig === null || popupConfig === void 0 ? void 0 : popupConfig.title) !== null && _a !== void 0 ? _a : (0, i18n_1.tr)("SEL_FEATURE_PROPERTIES", locale);
    var size = (_b = (0, ol_style_helpers_1.getClusterSubFeatures)(feat)) === null || _b === void 0 ? void 0 : _b.length;
    ;
    if (bClustered && size > 1) {
        title = (_d = (_c = popupConfig === null || popupConfig === void 0 ? void 0 : popupConfig.clusteredTitle) === null || _c === void 0 ? void 0 : _c.call(popupConfig, size)) !== null && _d !== void 0 ? _d : (0, i18n_1.tr)("SEL_CLUSTER_PROPERTIES", locale, { size: size });
    }
    html += "<div class='selected-popup-header'><div>" + title + "</div><a id='feat-popup-closer' class='closer' href='#'>[x]</a><div class='clearit'></div></div>";
    var renderForMultiple = function (subFeatures) {
        var table = "<table class='selected-popup-cluster-table'>";
        var fheadings = (popupConfig === null || popupConfig === void 0 ? void 0 : popupConfig.propertyMappings)
            ? popupConfig.propertyMappings.filter(function (pm) { return pm.name != subFeatures[0].getGeometryName(); }).map(function (pm) { return pm.value; })
            : Object.keys(subFeatures[0].getProperties()).filter(function (pn) { return pn != subFeatures[0].getGeometryName(); });
        var fprops = (popupConfig === null || popupConfig === void 0 ? void 0 : popupConfig.propertyMappings)
            ? popupConfig.propertyMappings.map(function (pm) { return pm.value; })
            : Object.keys(subFeatures[0].getProperties()).filter(function (pn) { return pn != subFeatures[0].getGeometryName(); });
        table += "<thead><tr>";
        for (var _i = 0, fheadings_1 = fheadings; _i < fheadings_1.length; _i++) {
            var heading = fheadings_1[_i];
            table += "<th>" + heading + "</th>";
        }
        table += "</tr></thead>";
        table += "<tbody>";
        for (var _a = 0, subFeatures_1 = subFeatures; _a < subFeatures_1.length; _a++) {
            var f = subFeatures_1[_a];
            table += "<tr>";
            for (var _b = 0, fprops_1 = fprops; _b < fprops_1.length; _b++) {
                var property = fprops_1[_b];
                table += "<td>" + f.get(property) + "</td>";
            }
            table += "</tr>";
        }
        table += "</tbody>";
        table += "</table>";
        return table;
    };
    var renderForSingle = function (feature) {
        var _a, _b, _c;
        var linkFragment;
        var table = "<table class='selected-popup-single-properties-table'>";
        table += "<tbody>";
        var f = feature.getProperties();
        var pc = 0;
        if (popupConfig === null || popupConfig === void 0 ? void 0 : popupConfig.propertyMappings) {
            for (var _i = 0, _d = popupConfig.propertyMappings; _i < _d.length; _i++) {
                var pm = _d[_i];
                if (pm.name == feat.getGeometryName()) {
                    continue;
                }
                table += "<tr>";
                table += "<td class='property-name-cell'>" + pm.value + "</td>";
                table += "<td class='property-value-cell'>" + f[pm.name] + "</td>";
                table += "</tr>";
                pc++;
            }
        }
        else {
            for (var key in f) {
                if (key == feat.getGeometryName()) {
                    continue;
                }
                table += "<tr>";
                table += "<td class='property-name-cell'>" + key + "</td>";
                table += "<td class='property-value-cell'>" + f[key] + "</td>";
                table += "</tr>";
                pc++;
            }
        }
        table += "</tbody>";
        table += "</table>";
        if (popupConfig === null || popupConfig === void 0 ? void 0 : popupConfig.linkProperty) {
            var _e = popupConfig.linkProperty, name_1 = _e.name, label = _e.label, linkTarget = _e.linkTarget;
            var linkHref = void 0;
            if (typeof (name_1) == 'string') {
                linkHref = encodeURI(f[name_1]);
            }
            else {
                var expr = name_1.expression;
                var url = expr;
                var pBegin = (_a = name_1.placeholderBegin) !== null && _a !== void 0 ? _a : "{";
                var pEnd = (_b = name_1.placeholderEnd) !== null && _b !== void 0 ? _b : "}";
                var tokens = (0, string_1.extractPlaceholderTokens)(expr, pBegin, pEnd);
                for (var _f = 0, tokens_1 = tokens; _f < tokens_1.length; _f++) {
                    var t = tokens_1[_f];
                    var al = encodeURIComponent((_c = f[t]) !== null && _c !== void 0 ? _c : "");
                    url = (0, string_1.strReplaceAll)(url, "" + pBegin + t + pEnd, al);
                }
                linkHref = url;
            }
            if (!(0, string_1.strIsNullOrEmpty)(linkHref)) {
                linkFragment = "<div class='select-popup-single-link-wrapper'><a href=\"" + linkHref + "\" target='" + linkTarget + "'>" + label + "</a></div>";
            }
        }
        return [table, pc, linkFragment];
    };
    var singlePopupContentRender = function (feature, appendHtml) {
        var _a = renderForSingle(feature), table = _a[0], pc = _a[1], linkFragment = _a[2];
        if (pc > 0) {
            appendHtml("<div class='selected-popup-content-wrapper'>" + table + "</div>");
        }
        else {
            appendHtml("<div class='selected-popup-content-none'>" + (0, i18n_1.tr)("SEL_FEATURE_PROPERTIES_NONE", locale) + "</div>");
        }
        if (!(0, string_1.strIsNullOrEmpty)(linkFragment)) {
            appendHtml(linkFragment);
        }
    };
    if (bClustered) {
        var subFeatures = (0, ol_style_helpers_1.getClusterSubFeatures)(feat);
        if (subFeatures.length == 1) {
            singlePopupContentRender(subFeatures[0], function (h) { return html += h; });
        }
        else {
            var table = renderForMultiple(subFeatures);
            html += "<div class='selected-popup-content-wrapper'>" + table + "</div>";
        }
    }
    else {
        singlePopupContentRender(feat, function (h) { return html += h; });
    }
    return html;
}
var SelectedFeaturesTooltip = /** @class */ (function () {
    function SelectedFeaturesTooltip(map, parent) {
        var _this = this;
        this.parent = parent;
        this.setPopupCloseHandler = function () {
            if (_this.closerEl) {
                _this.closerEl.onclick = _this.closePopup;
            }
        };
        this.closePopup = function (e) {
            e.preventDefault();
            _this.hide();
            if (_this.closerEl) {
                _this.closerEl.onclick = null;
            }
            return false;
        };
        this.featureTooltipElement = document.createElement("div");
        this.featureTooltipElement.addEventListener("mouseover", function () { return _this.isMouseOverTooltip = true; });
        this.featureTooltipElement.addEventListener("mouseout", function () { return _this.isMouseOverTooltip = false; });
        this.featureTooltipElement.className = 'selected-tooltip';
        this.featureTooltip = new Overlay_1.default({
            element: this.featureTooltipElement,
            offset: [15, 0],
            positioning: OverlayPositioning_1.default.CENTER_LEFT
        });
        this.map = map;
        this.map.addOverlay(this.featureTooltip);
        this.enabled = true;
        this.isMouseOverTooltip = false;
    }
    SelectedFeaturesTooltip.prototype.dispose = function () {
        this.featureTooltip.dispose();
    };
    Object.defineProperty(SelectedFeaturesTooltip.prototype, "isMouseOver", {
        get: function () { return this.isMouseOverTooltip; },
        enumerable: false,
        configurable: true
    });
    SelectedFeaturesTooltip.prototype.isEnabled = function () {
        return this.enabled;
    };
    SelectedFeaturesTooltip.prototype.setEnabled = function (enabled) {
        this.enabled = enabled;
        if (!this.enabled) {
            this.featureTooltipElement.innerHTML = "";
            this.featureTooltipElement.classList.add("tooltip-hidden");
        }
    };
    SelectedFeaturesTooltip.prototype.hide = function () {
        this.featureTooltipElement.innerHTML = "";
        this.featureTooltipElement.classList.add("tooltip-hidden");
    };
    SelectedFeaturesTooltip.prototype.queryWmsFeatures = function (currentLayerSet, layerMgr, coord, resolution, bAppendMode, callback) {
        var _a, _b, _c;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var selected, client, format, wmsSources, currentWmsSource, layers, _i, layers_1, layer, wmsLayer, source, _d, wmsSources_1, pair, layer, source, url, layerName, augs, resp, json, srcProj, epsg, features, popupConf, html;
            return (0, tslib_1.__generator)(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        selected = 0;
                        client = new client_1.Client("", "mapagent");
                        format = new GeoJSON_1.default();
                        wmsSources = [];
                        currentWmsSource = currentLayerSet === null || currentLayerSet === void 0 ? void 0 : currentLayerSet.tryGetWmsSource();
                        if (currentWmsSource) {
                            wmsSources.push(currentWmsSource);
                        }
                        layers = layerMgr.getLayers().filter(function (l) { return l.visible && l.selectable && l.type == "WMS"; });
                        for (_i = 0, layers_1 = layers; _i < layers_1.length; _i++) {
                            layer = layers_1[_i];
                            wmsLayer = layerMgr.getLayer(layer.name);
                            if (wmsLayer instanceof Image_1.default || wmsLayer instanceof Tile_1.default) {
                                source = wmsLayer.getSource();
                                if (source instanceof ImageWMS_1.default || source instanceof TileWMS_1.default) {
                                    wmsSources.push([wmsLayer, source]);
                                }
                            }
                        }
                        _d = 0, wmsSources_1 = wmsSources;
                        _e.label = 1;
                    case 1:
                        if (!(_d < wmsSources_1.length)) return [3 /*break*/, 4];
                        pair = wmsSources_1[_d];
                        layer = pair[0], source = pair[1];
                        url = source.getFeatureInfoUrl(coord, resolution, this.map.getView().getProjection(), {
                            'INFO_FORMAT': "application/json"
                        });
                        if (!url) return [3 /*break*/, 3];
                        layerName = layer.get(common_1.LayerProperty.LAYER_NAME);
                        augs = callback.getWmsRequestAugmentations();
                        if (augs[layerName]) {
                            url = augs[layerName](url);
                        }
                        return [4 /*yield*/, client.getText(url)];
                    case 2:
                        resp = _e.sent();
                        json = JSON.parse(resp);
                        if (((_a = json.features) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                            srcProj = source.getProjection();
                            if (!srcProj) {
                                epsg = (0, wfs_capabilities_panel_1.parseEpsgCodeFromCRS)((_c = (_b = json.crs) === null || _b === void 0 ? void 0 : _b.properties) === null || _c === void 0 ? void 0 : _c.name);
                                if (epsg) {
                                    srcProj = "EPSG:" + epsg;
                                }
                            }
                            features = format.readFeatures(resp, {
                                dataProjection: srcProj,
                                featureProjection: this.map.getView().getProjection()
                            });
                            this.featureTooltip.setPosition(coord);
                            popupConf = layer.get(common_1.LayerProperty.SELECTED_POPUP_CONFIGURATION);
                            html = this.generateFeatureHtml(layerName, features[0], callback.getLocale(), popupConf);
                            callback.addClientSelectedFeature(features[0], layer);
                            currentLayerSet === null || currentLayerSet === void 0 ? void 0 : currentLayerSet.clearWmsSelectionOverlay();
                            currentLayerSet === null || currentLayerSet === void 0 ? void 0 : currentLayerSet.addWmsSelectionOverlay(features[0]);
                            callback.addFeatureToHighlight(features[0], bAppendMode);
                            selected++;
                            this.featureTooltipElement.innerHTML = html;
                            (0, stickybits_1.default)(".selected-popup-cluster-table th");
                            this.closerEl = document.getElementById("feat-popup-closer");
                            this.setPopupCloseHandler();
                            if (html == "") {
                                this.featureTooltipElement.classList.add("tooltip-hidden");
                            }
                            else {
                                this.featureTooltipElement.classList.remove("tooltip-hidden");
                            }
                            return [2 /*return*/, true];
                        }
                        _e.label = 3;
                    case 3:
                        _d++;
                        return [3 /*break*/, 1];
                    case 4:
                        // Clear if there was no selection made
                        if (selected == 0) {
                            callback.addFeatureToHighlight(undefined, false);
                            this.hide();
                        }
                        return [2 /*return*/, false];
                }
            });
        });
    };
    SelectedFeaturesTooltip.prototype.generateFeatureHtml = function (layerName, feat, locale, popupConfig) {
        if (layerName) {
            var customRenderer = this.parent.getSelectionPopupRenderer(layerName);
            if (customRenderer) {
                return customRenderer(feat, locale, popupConfig);
            }
            else {
                return defaultPopupContentRenderer(feat, locale, popupConfig);
            }
        }
        return defaultPopupContentRenderer(feat, locale, popupConfig);
    };
    SelectedFeaturesTooltip.prototype.showSelectedVectorFeatures = function (features, pixel, featureToLayerMap, locale) {
        var coords = this.map.getCoordinateFromPixel(pixel);
        if (features.getLength() > 0) {
            this.featureTooltip.setPosition(coords);
            var f_1 = features.item(0);
            var popupConf = void 0;
            var pair = featureToLayerMap.find(function (_a) {
                var feat = _a[0], _ = _a[1];
                return feat == f_1;
            });
            var layerName = void 0;
            if (pair) {
                var layer = pair[1];
                popupConf = layer.get(common_1.LayerProperty.SELECTED_POPUP_CONFIGURATION);
                layerName = layer.get(common_1.LayerProperty.LAYER_NAME);
            }
            var html = this.generateFeatureHtml(layerName, f_1, locale, popupConf);
            this.featureTooltipElement.innerHTML = html;
            (0, stickybits_1.default)(".selected-popup-cluster-table th");
            this.closerEl = document.getElementById("feat-popup-closer");
            this.setPopupCloseHandler();
            if (html == "") {
                this.featureTooltipElement.classList.add("tooltip-hidden");
            }
            else {
                this.featureTooltipElement.classList.remove("tooltip-hidden");
            }
        }
        else {
            this.featureTooltipElement.innerHTML = "";
            this.featureTooltipElement.classList.add("tooltip-hidden");
        }
    };
    return SelectedFeaturesTooltip;
}());
exports.SelectedFeaturesTooltip = SelectedFeaturesTooltip;


/***/ }),

/***/ "./src/components/tooltips/utfgrid.ts":
/*!********************************************!*\
  !*** ./src/components/tooltips/utfgrid.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UTFGridTrackingTooltip = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var Overlay_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/Overlay */ "./node_modules/ol/Overlay.js"));
var OverlayPositioning_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/OverlayPositioning */ "./node_modules/ol/OverlayPositioning.js"));
var UTFGridTrackingTooltip = /** @class */ (function () {
    function UTFGridTrackingTooltip(map, gridSource, isContextMenuOpen) {
        this.map = map;
        this.gridSource = gridSource;
        this.isContextMenuOpen = isContextMenuOpen;
        this.map.getViewport().addEventListener("mouseout", this.onMouseOut.bind(this));
        this.tooltipElement = document.createElement("div");
        this.tooltipElement.className = 'feature-tooltip';
        this.tooltip = new Overlay_1.default({
            element: this.tooltipElement,
            offset: [15, 0],
            positioning: OverlayPositioning_1.default.CENTER_LEFT
        });
        this.map.addOverlay(this.tooltip);
        this.text = null;
    }
    UTFGridTrackingTooltip.prototype.dispose = function () {
        this.tooltip.dispose();
    };
    UTFGridTrackingTooltip.prototype.onMouseMove = function (e) {
        var _this = this;
        if (this.isContextMenuOpen())
            return;
        //this.tooltip.setPosition(e.coordinate);
        var viewResolution = /** @type {number} */ (this.map.getView().getResolution());
        if (viewResolution) {
            this.gridSource.forDataAtCoordinateAndResolution(e.coordinate, viewResolution, function (data) {
                // If you want to use the template from the TileJSON,
                //  load the mustache.js library separately and call
                //
                //mapElement.style.cursor = data ? 'pointer' : '';
                if (data) {
                    /*
                    var html = "<table>";
                    for (var key in data) {
                        html += "<tr><td>" + key + "</td><td>" + data[key] + "</td></tr>";
                    }
                    html += "</table>";
                    */
                    var html = "";
                    if (data.MG_TOOLTIP)
                        html += data.MG_TOOLTIP.replace(/(\\n)+/g, '<br />');
                    if (data.MG_URL) {
                        html += "<br/><br/>";
                        html += "<strong>CTRL + Click for more information</strong>";
                    }
                    _this.tooltipElement.innerHTML = html;
                }
                _this.tooltip.setPosition(data ? e.coordinate : undefined);
            });
        }
    };
    UTFGridTrackingTooltip.prototype.onMouseOut = function () {
    };
    UTFGridTrackingTooltip.prototype.setText = function (prompt) {
        this.text = prompt;
        this.tooltipElement.innerHTML = this.text;
    };
    UTFGridTrackingTooltip.prototype.clear = function () {
        this.text = null;
        this.tooltipElement.innerHTML = "";
    };
    UTFGridTrackingTooltip.prototype.destroy = function () {
        if (this.tooltipElement && this.tooltipElement.parentNode) {
            this.tooltipElement.parentNode.removeChild(this.tooltipElement);
        }
    };
    return UTFGridTrackingTooltip;
}());
exports.UTFGridTrackingTooltip = UTFGridTrackingTooltip;


/***/ }),

/***/ "./src/components/vector-style-editor.tsx":
/*!************************************************!*\
  !*** ./src/components/vector-style-editor.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VectorLayerStyleEditor = exports.VectorStyleEditor = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var ol_style_contracts_1 = __webpack_require__(/*! ../api/ol-style-contracts */ "./src/api/ol-style-contracts.ts");
var ol_style_helpers_1 = __webpack_require__(/*! ../api/ol-style-helpers */ "./src/api/ol-style-helpers.ts");
var expr_eval_1 = __webpack_require__(/*! expr-eval */ "./node_modules/expr-eval/dist/index.mjs");
var common_1 = __webpack_require__(/*! ./layer-manager/common */ "./src/components/layer-manager/common.tsx");
var string_1 = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");
var legend_1 = __webpack_require__(/*! ./layer-manager/legend */ "./src/components/layer-manager/legend.ts");
var ol_style_map_set_1 = __webpack_require__(/*! ../api/ol-style-map-set */ "./src/api/ol-style-map-set.ts");
function assertValue(val) {
    if ((0, ol_style_contracts_1.isEvaluatable)(val))
        throw new Error("Value is expression instead of a raw value");
}
function ExprEditor(props) {
    assertValue(props.expr);
    return React.createElement(React.Fragment, null,
        "Expr: ",
        React.createElement("input", { type: "text", value: "" + props.expr, onChange: function (e) { return props.onExprChanged(props.converter(e.target.value)); } }));
}
var DynamicSwitch = function (props) {
    if ((0, ol_style_contracts_1.isEvaluatable)(props.expr)) {
        return React.createElement(ExprEditor, (0, tslib_1.__assign)({}, props, { converter: function (v) { return (v === null || v === void 0 ? void 0 : v.toLowerCase()) == "true"; } }));
    }
    else {
        var expr = props.expr, onExprChanged = props.onExprChanged, rest = (0, tslib_1.__rest)(props, ["expr", "onExprChanged"]);
        var innerProps = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, rest), { checked: props.expr, onChange: function (e) { return props.onExprChanged(e.target.checked); } });
        return React.createElement(core_1.Switch, (0, tslib_1.__assign)({}, innerProps));
    }
};
//TODO: Either surface the font as another editable property or offload to configuration
var buildFont = function (size, bold, italic, font) {
    if (font === void 0) { font = "sans-serif"; }
    return (bold ? "bold" : string_1.STR_EMPTY) + " " + (italic ? "italic" : string_1.STR_EMPTY) + " " + size + "px " + font;
};
function coalesceExpr(expr, defaultVal) {
    if ((0, ol_style_contracts_1.isEvaluatable)(expr)) {
        return defaultVal;
    }
    return expr !== null && expr !== void 0 ? expr : defaultVal;
}
var DEFAULT_FONT_SIZE = 14;
var LabelStyleEditor = function (props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    var style = props.style, locale = props.locale, onChange = props.onChange, isLine = props.isLine;
    var _o = React.useState(false), bold = _o[0], setBold = _o[1];
    var _p = React.useState(false), italic = _p[0], setItalic = _p[1];
    var _q = React.useState((_c = (_b = (_a = style.label) === null || _a === void 0 ? void 0 : _a.fill) === null || _b === void 0 ? void 0 : _b.color) !== null && _c !== void 0 ? _c : "#000000"), localBgColor = _q[0], setLocalBgColor = _q[1];
    var _r = React.useState((_f = (_e = (_d = style.label) === null || _d === void 0 ? void 0 : _d.fill) === null || _e === void 0 ? void 0 : _e.alpha) !== null && _f !== void 0 ? _f : 255), localBgColorAlpha = _r[0], setLocalColorAlpha = _r[1];
    var _s = React.useState((_j = (_h = (_g = style.label) === null || _g === void 0 ? void 0 : _g.stroke) === null || _h === void 0 ? void 0 : _h.color) !== null && _j !== void 0 ? _j : "#ffffff"), localStrokeColor = _s[0], setLocalStrokeColor = _s[1];
    var _t = React.useState((_m = (_l = (_k = style.label) === null || _k === void 0 ? void 0 : _k.stroke) === null || _l === void 0 ? void 0 : _l.width) !== null && _m !== void 0 ? _m : 1), localStrokeWidth = _t[0], setLocalStrokeWidth = _t[1];
    var _u = React.useState(DEFAULT_FONT_SIZE), localFontSize = _u[0], setLocalFontSize = _u[1];
    var _v = React.useState((0, tslib_1.__assign)({ font: buildFont(localFontSize, bold, italic) }, style.label)), localLabel = _v[0], setLocalLabel = _v[1];
    var _w = React.useState(style.label != null), hasLabel = _w[0], setHasLabel = _w[1];
    var onToggleLinePlacement = React.useCallback(function () {
        if (localLabel.placement == "line") {
            var placement = localLabel.placement, rest = (0, tslib_1.__rest)(localLabel, ["placement"]);
            setLocalLabel(rest);
        }
        else {
            setLocalLabel((0, tslib_1.__assign)((0, tslib_1.__assign)({}, localLabel), { placement: "line" }));
        }
    }, [localLabel]);
    React.useEffect(function () {
        if (hasLabel) {
            onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { label: localLabel }));
        }
        else {
            var label = style.label, rest = (0, tslib_1.__rest)(style, ["label"]);
            onChange(rest);
        }
    }, [localLabel, hasLabel]);
    React.useEffect(function () {
        setLocalLabel((0, tslib_1.__assign)((0, tslib_1.__assign)({}, localLabel), { font: buildFont(localFontSize, bold, italic) }));
    }, [localFontSize, bold, italic]);
    React.useEffect(function () {
        setLocalLabel((0, tslib_1.__assign)((0, tslib_1.__assign)({}, localLabel), { fill: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, localLabel.fill), { color: localBgColor, alpha: localBgColorAlpha }), stroke: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, localLabel.stroke), { color: localStrokeColor, width: localStrokeWidth }) }));
    }, [localStrokeColor, localStrokeWidth, localBgColorAlpha, localBgColor]);
    return React.createElement(React.Fragment, null,
        React.createElement(core_1.Switch, { checked: hasLabel, onChange: function (e) { return setHasLabel(e.target.checked); }, label: (0, i18n_1.tr)("ENABLE_LABELS", locale) }),
        hasLabel && React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("LABEL_TEXT", locale) },
            React.createElement(common_1.StringExprEditor, { locale: locale, value: localLabel.text, onChange: function (t) { return setLocalLabel((0, tslib_1.__assign)((0, tslib_1.__assign)({}, localLabel), { text: t })); } })),
        hasLabel && React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("LABEL_SIZE", locale) },
            React.createElement(common_1.NumberExprEditor, { locale: locale, value: localFontSize, onChange: function (t) { return setLocalFontSize(coalesceExpr(t, DEFAULT_FONT_SIZE)); } })),
        hasLabel && React.createElement(core_1.ButtonGroup, null,
            React.createElement(core_1.Button, { intent: core_1.Intent.PRIMARY, active: bold, onClick: function (e) { return setBold(!bold); } }, (0, i18n_1.tr)("LABEL_BOLD", locale)),
            React.createElement(core_1.Button, { intent: core_1.Intent.PRIMARY, active: italic, onClick: function (e) { return setItalic(!italic); } }, (0, i18n_1.tr)("LABEL_ITALIC", locale)),
            isLine && React.createElement(core_1.Button, { intent: core_1.Intent.PRIMARY, active: localLabel.placement == "line", onClick: function (e) { return onToggleLinePlacement(); } }, (0, i18n_1.tr)("LABEL_LINE_PLACEMENT", locale))),
        hasLabel && React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("LABEL_COLOR", locale) },
            React.createElement(common_1.ColorExprEditor, { locale: locale, value: localBgColor, onChange: function (c) { return setLocalBgColor(c); } })),
        hasLabel && React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("LABEL_OUTLINE_COLOR", locale) },
            React.createElement(common_1.ColorExprEditor, { locale: locale, value: localStrokeColor, onChange: function (c) { return setLocalStrokeColor(c); } })),
        hasLabel && React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("LABEL_OUTLINE_THICKNESS", locale) },
            React.createElement(common_1.NumberExprEditor, { locale: locale, value: localStrokeWidth, onChange: function (t) { return setLocalStrokeWidth(t); } })));
};
var PointIconStyleEditor = function (_a) {
    var style = _a.style, onChange = _a.onChange, locale = _a.locale;
    var _b = React.useState(style.src), localSrc = _b[0], setLocalSrc = _b[1];
    React.useEffect(function () {
        setLocalSrc(style.src);
    }, [style.src]);
    var onSrcChange = function (e) {
        onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { src: localSrc }));
    };
    return React.createElement("div", null,
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_PT_ICON_SRC", locale) },
            React.createElement(common_1.StringExprEditor, { value: localSrc, onChange: function (e) { return setLocalSrc(e); }, locale: locale }),
            !(0, ol_style_contracts_1.isEvaluatable)(style.src) && React.createElement("img", { src: style.src })),
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_PT_ICON_ANCHOR", locale) },
            (0, i18n_1.tr)("VSED_PT_ICON_ANCHOR_H", locale),
            " ",
            React.createElement(core_1.NumericInput, { value: style.anchor[0], min: 0, onValueChange: function (e) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { anchor: [e, style.anchor[1]] })); } }),
            (0, i18n_1.tr)("VSED_PT_ICON_ANCHOR_V", locale),
            " ",
            React.createElement(core_1.NumericInput, { value: style.anchor[1], min: 0, onValueChange: function (e) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { anchor: [style.anchor[0], e] })); } })),
        React.createElement(DynamicSwitch, { label: (0, i18n_1.tr)("VSED_PT_ICON_ROTATE_WITH_VIEW", locale), expr: style.rotateWithView, onExprChanged: function (e) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { rotateWithView: e })); } }),
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_PT_ICON_ROTATION", locale) },
            React.createElement(common_1.SliderExprEditor, { locale: locale, min: 0, max: 360, labelStepSize: 360, value: style.rotation, onChange: function (n) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { rotation: n })); } })),
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_PT_ICON_SCALE", locale) },
            React.createElement(common_1.NumberExprEditor, { value: style.scale, onChange: function (n) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { scale: n })); }, locale: locale })));
};
var PointCircleStyleEditor = function (_a) {
    var style = _a.style, onChange = _a.onChange, locale = _a.locale;
    return React.createElement("div", null,
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_PT_FILL_COLOR", locale) },
            React.createElement(common_1.ColorExprEditor, { locale: locale, value: style.fill.color, onChange: function (c) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { fill: { color: c, alpha: style.fill.alpha } })); } })),
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_PT_FILL_COLOR_ALPHA", locale) },
            React.createElement(common_1.SliderExprEditor, { locale: locale, min: 0, max: 255, labelStepSize: 255, value: style.fill.alpha, onChange: function (n) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { fill: { color: style.fill.color, alpha: n } })); } })),
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_PT_RADIUS", locale) },
            React.createElement(common_1.NumberExprEditor, { locale: locale, value: style.radius, min: 1, onChange: function (n) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { radius: n })); } })),
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_PT_OUTLINE_COLOR", locale) },
            React.createElement(common_1.ColorExprEditor, { locale: locale, value: style.stroke.color, onChange: function (c) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { stroke: { color: c, width: style.stroke.width, alpha: style.stroke.alpha } })); } })),
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_PT_OUTLINE_COLOR_ALPHA", locale) },
            React.createElement(common_1.SliderExprEditor, { locale: locale, min: 0, max: 255, labelStepSize: 255, value: style.stroke.alpha, onChange: function (n) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { stroke: { color: style.stroke.color, width: style.stroke.width, alpha: n } })); } })),
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_PT_OUTLINE_WIDTH", locale) },
            React.createElement(common_1.NumberExprEditor, { locale: locale, value: style.stroke.width, min: 1, onChange: function (n) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { stroke: { color: style.stroke.color, width: n, alpha: style.stroke.alpha } })); } })));
};
var PointStyleEditor = function (_a) {
    var style = _a.style, onChange = _a.onChange, locale = _a.locale;
    var _b = React.useState(undefined), iconStyle = _b[0], setIconStyle = _b[1];
    var _c = React.useState(undefined), circleStyle = _c[0], setCircleStyle = _c[1];
    var _d = React.useState(style), currentStyle = _d[0], setCurrentStyle = _d[1];
    var applyCurrentStyle = function (s) {
        setCurrentStyle(s);
        switch (s.type) {
            case "Circle":
                setCircleStyle(s);
                break;
            case "Icon":
                setIconStyle(s);
                break;
        }
    };
    var onStyleTypeChange = function (type) {
        switch (type) {
            case "Circle":
                if (circleStyle) {
                    setCurrentStyle(circleStyle);
                    onChange(circleStyle);
                }
                else {
                    var s = (0, tslib_1.__assign)({}, ol_style_contracts_1.DEFAULT_POINT_CIRCLE_STYLE);
                    setCircleStyle(s);
                    setCurrentStyle(s);
                    onChange(s);
                }
                break;
            case "Icon":
                if (iconStyle) {
                    setCurrentStyle(iconStyle);
                    onChange(iconStyle);
                }
                else {
                    var s = (0, tslib_1.__assign)({}, ol_style_contracts_1.DEFAULT_POINT_ICON_STYLE);
                    setIconStyle(s);
                    setCurrentStyle(s);
                    onChange(s);
                }
                break;
        }
    };
    React.useEffect(function () {
        applyCurrentStyle(style);
    }, [style]);
    return React.createElement("div", null,
        React.createElement(core_1.RadioGroup, { inline: true, label: (0, i18n_1.tr)("VSED_PT_TYPE", locale), onChange: function (e) { return onStyleTypeChange(e.target.value); }, selectedValue: currentStyle.type },
            React.createElement(core_1.Radio, { label: (0, i18n_1.tr)("VSED_PT_TYPE_CIRCLE", locale), value: "Circle" }),
            React.createElement(core_1.Radio, { label: (0, i18n_1.tr)("VSED_PT_TYPE_ICON", locale), value: "Icon" })),
        currentStyle.type == "Icon" && React.createElement(PointIconStyleEditor, { style: currentStyle, onChange: onChange, locale: locale }),
        currentStyle.type == "Circle" && React.createElement(PointCircleStyleEditor, { style: currentStyle, onChange: onChange, locale: locale }),
        React.createElement(LabelStyleEditor, { style: currentStyle, locale: locale, onChange: onChange }));
};
var LineStyleEditor = function (_a) {
    var style = _a.style, onChange = _a.onChange, locale = _a.locale;
    return React.createElement("div", null,
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_LN_OUTLINE_COLOR", locale) },
            React.createElement(common_1.ColorExprEditor, { locale: locale, value: style.color, onChange: function (c) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { color: c, width: style.width, alpha: style.alpha })); } })),
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_LN_OUTLINE_COLOR_ALPHA", locale) },
            React.createElement(common_1.SliderExprEditor, { locale: locale, min: 0, max: 255, labelStepSize: 255, value: style.alpha, onChange: function (n) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { color: style.color, width: style.width, alpha: n })); } })),
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_LN_OUTLINE_THICKNESS", locale) },
            React.createElement(common_1.NumberExprEditor, { locale: locale, min: 1, value: style.width, onChange: function (n) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { color: style.color, width: n, alpha: style.alpha })); } })),
        React.createElement(LabelStyleEditor, { style: style, locale: locale, onChange: onChange, isLine: true }));
};
var PolygonStyleEditor = function (_a) {
    var style = _a.style, onChange = _a.onChange, locale = _a.locale;
    return React.createElement("div", null,
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_PL_FILL_COLOR", locale) },
            React.createElement(common_1.ColorExprEditor, { locale: locale, value: style.fill.color, onChange: function (c) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { fill: { color: c, alpha: style.fill.alpha } })); } })),
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_PL_FILL_COLOR_ALPHA", locale) },
            React.createElement(common_1.SliderExprEditor, { locale: locale, min: 0, max: 255, labelStepSize: 255, value: style.fill.alpha, onChange: function (n) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { fill: { color: style.fill.color, alpha: n } })); } })),
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_PL_OUTLINE_COLOR", locale) },
            React.createElement(common_1.ColorExprEditor, { locale: locale, value: style.stroke.color, onChange: function (c) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { stroke: { color: c, width: style.stroke.width, alpha: style.stroke.alpha } })); } })),
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_PL_OUTLINE_COLOR_ALPHA", locale) },
            React.createElement(common_1.SliderExprEditor, { locale: locale, min: 0, max: 255, labelStepSize: 255, value: style.stroke.alpha, onChange: function (n) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { stroke: { color: style.stroke.color, width: style.stroke.width, alpha: n } })); } })),
        React.createElement(core_1.FormGroup, { label: (0, i18n_1.tr)("VSED_PL_OUTLINE_THICKNESS", locale) },
            React.createElement(common_1.NumberExprEditor, { locale: locale, value: style.stroke.width, min: 1, onChange: function (n) { return onChange((0, tslib_1.__assign)((0, tslib_1.__assign)({}, style), { stroke: { color: style.stroke.color, width: n, alpha: style.stroke.alpha } })); } })),
        React.createElement(LabelStyleEditor, { style: style, locale: locale, onChange: onChange }));
};
/**
 * A vector style editor component
 *
 * @since 0.13
 */
var VectorStyleEditor = function (props) {
    var _a, _b, _c;
    var locale = props.locale, style = props.style, onChange = props.onChange, enableLine = props.enableLine, enablePoint = props.enablePoint, enablePolygon = props.enablePolygon;
    var _d = React.useState(undefined), selectedTab = _d[0], setSelectedTab = _d[1];
    var _e = React.useState((_a = style === null || style === void 0 ? void 0 : style.point) !== null && _a !== void 0 ? _a : ol_style_contracts_1.DEFAULT_POINT_CIRCLE_STYLE), pointStyle = _e[0], setPointStyle = _e[1];
    var _f = React.useState((_b = style === null || style === void 0 ? void 0 : style.line) !== null && _b !== void 0 ? _b : ol_style_contracts_1.DEFAULT_LINE_STYLE), lineStyle = _f[0], setLineStyle = _f[1];
    var _g = React.useState((_c = style === null || style === void 0 ? void 0 : style.polygon) !== null && _c !== void 0 ? _c : ol_style_contracts_1.DEFAULT_POLY_STYLE), polyStyle = _g[0], setPolyStyle = _g[1];
    React.useEffect(function () {
        var _a, _b, _c;
        setPointStyle((_a = style === null || style === void 0 ? void 0 : style.point) !== null && _a !== void 0 ? _a : ol_style_contracts_1.DEFAULT_POINT_CIRCLE_STYLE);
        setLineStyle((_b = style === null || style === void 0 ? void 0 : style.line) !== null && _b !== void 0 ? _b : ol_style_contracts_1.DEFAULT_LINE_STYLE);
        setPolyStyle((_c = style === null || style === void 0 ? void 0 : style.polygon) !== null && _c !== void 0 ? _c : ol_style_contracts_1.DEFAULT_POLY_STYLE);
    }, [style]);
    var onStyleChanged = function (point, line, poly) {
        var newStyle = {
            label: style === null || style === void 0 ? void 0 : style.label
        };
        if (enablePoint) {
            newStyle.point = point;
        }
        if (enableLine) {
            newStyle.line = line;
        }
        if (enablePolygon) {
            newStyle.polygon = poly;
        }
        onChange === null || onChange === void 0 ? void 0 : onChange(newStyle);
        if (newStyle.point) {
            setPointStyle(newStyle.point);
        }
        if (newStyle.line) {
            setLineStyle(newStyle.line);
        }
        if (newStyle.polygon) {
            setPolyStyle(newStyle.polygon);
        }
    };
    if (!enableLine && !enablePoint && !enablePolygon) {
        return React.createElement(core_1.NonIdealState, { icon: "warning-sign", title: (0, i18n_1.tr)("VSED_NO_STYLES_TITLE", locale), description: (0, i18n_1.tr)("VSED_NO_STYLES_DESC", locale) });
    }
    else {
        var onPointStyleChanged = function (st) {
            onStyleChanged(st, lineStyle, polyStyle);
        };
        var onLineStyleChanged = function (st) {
            onStyleChanged(pointStyle, st, polyStyle);
        };
        var onPolygonStyleChanged = function (st) {
            onStyleChanged(pointStyle, lineStyle, st);
        };
        return React.createElement(core_1.Tabs, { onChange: function (t) { return setSelectedTab(t); }, selectedTabId: selectedTab },
            enablePoint && React.createElement(core_1.Tab, { id: "pointStyle", title: (0, i18n_1.tr)("VSED_TAB_POINT", locale), panel: React.createElement(PointStyleEditor, { style: pointStyle, locale: locale, onChange: onPointStyleChanged }) }),
            enableLine && React.createElement(core_1.Tab, { id: "lineStyle", title: (0, i18n_1.tr)("VSED_TAB_LINE", locale), panel: React.createElement(LineStyleEditor, { style: lineStyle, locale: locale, onChange: onLineStyleChanged }) }),
            enablePolygon && React.createElement(core_1.Tab, { id: "polyStyle", title: (0, i18n_1.tr)("VSED_TAB_POLY", locale), panel: React.createElement(PolygonStyleEditor, { style: polyStyle, locale: locale, onChange: onPolygonStyleChanged }) }));
    }
};
exports.VectorStyleEditor = VectorStyleEditor;
var parser = new expr_eval_1.Parser();
var FilterItem = function (props) {
    var filter = props.filter, isDefault = props.isDefault, isStyleEditorOpen = props.isStyleEditorOpen, featureStyle = props.featureStyle, onChange = props.onChange;
    var _a = React.useState(filter !== null && filter !== void 0 ? filter : ""), localFilter = _a[0], setLocalFilter = _a[1];
    var _b = React.useState(true), isLocalFilterValid = _b[0], setIsLocalFilterValid = _b[1];
    var _c = React.useState(undefined), pointStyleUrl = _c[0], setPointStyleUrl = _c[1];
    var _d = React.useState(undefined), lineStyleUrl = _d[0], setLineStyleUrl = _d[1];
    var _e = React.useState(undefined), polyStyleUrl = _e[0], setPolyStyleUrl = _e[1];
    React.useEffect(function () {
        setLocalFilter(localFilter);
    }, [filter]);
    React.useEffect(function () {
        try {
            var expr = parser.parse(localFilter);
            var bHaveVar = false;
            var bHaveOperator = false;
            for (var _i = 0, _a = expr.tokens; _i < _a.length; _i++) {
                var t = _a[_i];
                switch (t.type) {
                    case "IVAR":
                        bHaveVar = true;
                        break;
                    case "IOP2":
                        bHaveOperator = true;
                        break;
                }
            }
            setIsLocalFilterValid(bHaveVar && bHaveOperator && expr.tokens.length == 3);
        }
        catch (e) {
            setIsLocalFilterValid(false);
        }
    }, [localFilter]);
    React.useEffect(function () {
        var _a, _b;
        var fs = featureStyle;
        // A default clustered style will have a dynamic expression for the radius, the legend preview isn't
        // smart enough to know what this should be since we don't (and can't) pass an "example" feature to
        // know what this value should be. So in the event we find a clustered point style, we'll replace
        // the dynamic radius expression with a constant value
        if (((_a = featureStyle === null || featureStyle === void 0 ? void 0 : featureStyle.point) === null || _a === void 0 ? void 0 : _a.type) == "Circle" && (0, ol_style_contracts_1.isEvaluatable)(featureStyle.point.radius)) {
            fs = JSON.parse(JSON.stringify(featureStyle));
            if (((_b = fs.point) === null || _b === void 0 ? void 0 : _b.type) == "Circle") {
                fs.point.radius = 5;
            }
        }
        var olstyle = (0, ol_style_map_set_1.vectorStyleToStyleMap)(fs);
        var pos;
        var ls;
        var pls;
        if (typeof (olstyle) == 'function') {
            pos = function (feat) { return olstyle(feat, undefined)["Point"]; };
            ls = function (feat) { return olstyle(feat, undefined)["LineString"]; };
            pls = function (feat) { return olstyle(feat, undefined)["Polygon"]; };
        }
        else {
            pos = olstyle.Point;
            ls = olstyle.LineString;
            pls = olstyle.Polygon;
        }
        var cPoint = (0, legend_1.getLegendImage)({
            typeGeom: "Point",
            style: pos
        });
        var cLineString = (0, legend_1.getLegendImage)({
            typeGeom: "LineString",
            style: ls
        });
        var cPolygon = (0, legend_1.getLegendImage)({
            typeGeom: "Polygon",
            style: pls
        });
        setPointStyleUrl(cPoint.toDataURL());
        setLineStyleUrl(cLineString.toDataURL());
        setPolyStyleUrl(cPolygon.toDataURL());
    }, [featureStyle]);
    var onToggle = function () {
        props.onToggleStyleEditor(!isStyleEditorOpen);
    };
    var onInnerStyleChanged = function (style) {
        onChange === null || onChange === void 0 ? void 0 : onChange(isDefault ? ol_style_helpers_1.DEFAULT_STYLE_KEY : localFilter, style);
    };
    var outerModifier;
    if (!isLocalFilterValid) {
        outerModifier = core_1.Intent.DANGER;
    }
    var colSpan = 5;
    if (!props.enableLine)
        colSpan--;
    if (!props.enablePoint)
        colSpan--;
    if (!props.enablePolygon)
        colSpan--;
    var filterExprEd = React.createElement("span", null, featureStyle.label); //<InputGroup intent={outerModifier} fill leftIcon={(isLocalFilterValid ? "tick" : "warning-sign")} title={localFilter} value={localFilter} onChange={e => setLocalFilter(e.target.value)} />;
    return React.createElement(React.Fragment, null,
        React.createElement("tr", null,
            props.enablePoint && React.createElement("td", null, pointStyleUrl && React.createElement("img", { src: pointStyleUrl })),
            props.enableLine && React.createElement("td", null, lineStyleUrl && React.createElement("img", { src: lineStyleUrl })),
            props.enablePolygon && React.createElement("td", null, polyStyleUrl && React.createElement("img", { src: polyStyleUrl })),
            React.createElement("td", null, isDefault ? React.createElement("strong", null, "Default Style") : filterExprEd),
            React.createElement("td", null,
                React.createElement(core_1.Button, { intent: isStyleEditorOpen ? core_1.Intent.DANGER : core_1.Intent.PRIMARY, onClick: onToggle, icon: isStyleEditorOpen ? "cross" : "edit" }))),
        isStyleEditorOpen && React.createElement("tr", null,
            React.createElement("td", { colSpan: colSpan },
                React.createElement(exports.VectorStyleEditor, { style: featureStyle, onChange: onInnerStyleChanged, enableLine: props.enableLine, enablePoint: props.enablePoint, enablePolygon: props.enablePolygon, locale: props.locale }))));
};
var VectorLayerStyleEditor = function (props) {
    var filters = Object.keys(props.style).filter(function (k) { return k != ol_style_helpers_1.DEFAULT_STYLE_KEY; });
    var _a = React.useState({}), openStyleEditors = _a[0], setOpenStyleEditors = _a[1];
    var onFeatureStyleChanged = function (filter, style) {
        var _a;
        var updatedStyle = (0, tslib_1.__assign)({}, props.style);
        updatedStyle[filter] = style;
        (_a = props.onChange) === null || _a === void 0 ? void 0 : _a.call(props, updatedStyle);
    };
    var onToggleStyleEditor = function (index, visible) {
        var opEds = (0, tslib_1.__assign)({}, openStyleEditors);
        if (!visible) {
            delete opEds[index];
        }
        else {
            opEds[index] = true;
        }
        setOpenStyleEditors(opEds);
    };
    return React.createElement("table", { style: { width: "100%" } },
        React.createElement("colgroup", null,
            props.enablePoint && React.createElement("col", { span: 1, style: { width: 24 } }),
            props.enableLine && React.createElement("col", { span: 1, style: { width: 24 } }),
            props.enablePolygon && React.createElement("col", { span: 1, style: { width: 24 } }),
            React.createElement("col", { span: 1 }),
            React.createElement("col", { span: 1, style: { width: 32 } })),
        React.createElement("tbody", null,
            filters.map(function (f, i) { return React.createElement(FilterItem, { key: "filter-" + i, filter: f, isDefault: false, onChange: function (f, s) { return onFeatureStyleChanged(f, s); }, featureStyle: props.style[filters[i]], isStyleEditorOpen: openStyleEditors[f] === true, onToggleStyleEditor: function (isVisible) { return onToggleStyleEditor(f, isVisible); }, locale: props.locale, enableLine: props.enableLine, enablePoint: props.enablePoint, enablePolygon: props.enablePolygon }); }),
            React.createElement(FilterItem, { isDefault: true, onChange: function (f, s) { return onFeatureStyleChanged(ol_style_helpers_1.DEFAULT_STYLE_KEY, s); }, featureStyle: props.style.default, isStyleEditorOpen: openStyleEditors[ol_style_helpers_1.DEFAULT_STYLE_KEY] === true, onToggleStyleEditor: function (isVisible) { return onToggleStyleEditor(ol_style_helpers_1.DEFAULT_STYLE_KEY, isVisible); }, locale: props.locale, enableLine: props.enableLine, enablePoint: props.enablePoint, enablePolygon: props.enablePolygon })));
};
exports.VectorLayerStyleEditor = VectorLayerStyleEditor;


/***/ }),

/***/ "./src/components/view-size.tsx":
/*!**************************************!*\
  !*** ./src/components/view-size.tsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViewSize = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var units_1 = __webpack_require__(/*! ../utils/units */ "./src/utils/units.tsx");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var ViewSizeContent = function (_a) {
    var gw = _a.gw, gh = _a.gh, unit = _a.unit;
    var str = (0, i18n_1.fmt)("{gw} x {gh} ({unit})", { gw: gw, gh: gh, unit: unit });
    return React.createElement("span", { dangerouslySetInnerHTML: { __html: str } });
};
var ViewSize = function (props) {
    var width = props.width, height = props.height, view = props.view, metersPerUnit = props.metersPerUnit, units = props.units, precision = props.precision, locale = props.locale;
    var uom = (0, units_1.getUnitOfMeasure)(units);
    var _a = (0, units_1.getMapSize)([width, height], metersPerUnit, units, view.resolution, precision), gw = _a[0], gh = _a[1];
    //TODO: Support format string extension parameter from fusion widget
    return React.createElement("div", { className: "status-bar-component component-view-size" },
        React.createElement(ViewSizeContent, { gw: gw, gh: gh, unit: uom.abbreviation(locale) }));
};
exports.ViewSize = ViewSize;


/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BLANK_GIF_DATA_URI = exports.LAYER_ID_MG_SEL_OVERLAY = exports.LAYER_ID_MG_BASE = exports.LAYER_ID_BASE = exports.FUSION_REDLINE_NAME = exports.FUSION_MAP_NAME = exports.FUSION_TASKPANE_NAME = exports.WEBLAYOUT_CONTEXTMENU = exports.WEBLAYOUT_TASKMENU = exports.WEBLAYOUT_TOOLBAR = exports.MDF_INFINITY = exports.EMPTY_OBJECT = exports.DEG = exports.NBSP = void 0;
/**
 * Non-breaking space
 */
exports.NBSP = String.fromCharCode(160);
exports.DEG = String.fromCharCode(176);
exports.EMPTY_OBJECT = {};
exports.MDF_INFINITY = 1000000000000.0;
exports.WEBLAYOUT_TOOLBAR = "Toolbar";
exports.WEBLAYOUT_TASKMENU = "TaskMenu";
exports.WEBLAYOUT_CONTEXTMENU = "MapContextMenu";
exports.FUSION_TASKPANE_NAME = "TaskPane";
exports.FUSION_MAP_NAME = "Map";
exports.FUSION_REDLINE_NAME = "Redline";
exports.LAYER_ID_BASE = "LAYER_ID_BASE";
exports.LAYER_ID_MG_BASE = "LAYER_ID_MG_BASE";
exports.LAYER_ID_MG_SEL_OVERLAY = "LAYER_ID_MG_SEL_OVERLAY";
exports.BLANK_GIF_DATA_URI = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";


/***/ }),

/***/ "./src/constants/actions.ts":
/*!**********************************!*\
  !*** ./src/constants/actions.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActionType = void 0;
/**
 * All valid action types
 *
 * @since 0.12
 */
var ActionType;
(function (ActionType) {
    ActionType["SET_LOCALE"] = "MapGuide/SET_LOCALE";
    ActionType["INIT_APP"] = "MapGuide/INIT_APP";
    ActionType["INIT_ERROR"] = "MapGuide/INIT_ERROR";
    ActionType["INIT_ACKNOWLEDGE_WARNINGS"] = "MapGuide/INIT_ACKNOWLEDGE_WARNINGS";
    ActionType["LEGEND_SET_GROUP_VISIBILITY"] = "Legend/SET_GROUP_VISIBILITY";
    ActionType["LEGEND_SET_LAYER_VISIBILITY"] = "Legend/SET_LAYER_VISIBILITY";
    ActionType["LEGEND_SET_LAYER_SELECTABLE"] = "Legend/SET_LAYER_SELECTABLE";
    ActionType["LEGEND_SET_GROUP_EXPANDABLE"] = "Legend/SET_GROUP_EXPANDABLE";
    ActionType["MAP_SET_ACTIVE_MAP"] = "Map/SET_ACTIVE_MAP";
    ActionType["MAP_REFRESH"] = "Map/REFRESH";
    ActionType["MAP_SET_VIEW"] = "Map/SET_VIEW";
    ActionType["MAP_SET_SCALE"] = "Map/SET_SCALE";
    ActionType["MAP_SET_ACTIVE_TOOL"] = "Map/SET_ACTIVE_TOOL";
    ActionType["MAP_SET_MAPTIP"] = "Map/SET_MAPTIP";
    /**
     * @since 0.14.2
     */
    ActionType["MAP_ENABLE_SELECT_DRAGPAN"] = "Map/ENABLE_SELECT_DRAGPAN";
    ActionType["MAP_SET_MANUAL_MAPTIP"] = "Map/MAP_SET_MANUAL_MAPTIP";
    ActionType["MAP_SET_SELECTION"] = "Map/SET_SELECTION";
    /**
     * @since 0.14
     */
    ActionType["MAP_ADD_CLIENT_SELECTED_FEATURE"] = "Map/ADD_CLIENT_SELECTED_FEATURE";
    /**
     * @since 0.14
     */
    ActionType["MAP_CLEAR_CLIENT_SELECTION"] = "Map/CLEAR_CLIENT_SELECTION";
    ActionType["MAP_SET_BUSY_COUNT"] = "Map/SET_BUSY_COUNT";
    ActionType["MAP_SET_BASE_LAYER"] = "Map/SET_BASE_LAYER";
    ActionType["MAP_ZOOM_IN"] = "Map/ZOOM_IN";
    ActionType["MAP_ZOOM_OUT"] = "Map/ZOOM_OUT";
    ActionType["MAP_PREVIOUS_VIEW"] = "Map/PREVIOUS_VIEW";
    ActionType["MAP_NEXT_VIEW"] = "Map/NEXT_VIEW";
    ActionType["MAP_SET_LAYER_TRANSPARENCY"] = "Map/SET_LAYER_TRANSPARENCY";
    ActionType["MAP_SET_VIEW_SIZE_UNITS"] = "Map/SET_VIEW_SIZE_UNITS";
    ActionType["MAP_SET_VIEW_ROTATION"] = "Map/SET_VIEW_ROTATION";
    ActionType["MAP_SET_VIEW_ROTATION_ENABLED"] = "Map/SET_VIEW_ROTATION_ENABLED";
    ActionType["MAP_RESIZED"] = "Map/RESIZED";
    ActionType["MAP_SHOW_SELECTED_FEATURE"] = "Map/SHOW_SELECTED_FEATURE";
    ActionType["TASK_INVOKE_URL"] = "TaskPane/INVOKE_URL";
    ActionType["TASK_PANE_HOME"] = "TaskPane/HOME";
    ActionType["TASK_PANE_FORWARD"] = "TaskPane/FORWARD";
    ActionType["TASK_PANE_BACK"] = "TaskPane/BACK";
    ActionType["TASK_PANE_PUSH_URL"] = "TaskPane/PUSH_URL";
    ActionType["FUSION_SET_ELEMENT_STATE"] = "Fusion/SET_ELEMENT_STATE";
    ActionType["FUSION_SET_TASK_PANE_VISIBILITY"] = "Fusion/SET_TASK_PANE_VISIBILITY";
    ActionType["FUSION_SET_LEGEND_VISIBILITY"] = "Fusion/SET_LEGEND_VISIBILITY";
    ActionType["FUSION_SET_SELECTION_PANEL_VISIBILITY"] = "Fusion/SET_SELECTION_PANEL_VISIBILITY";
    //FUSION_SET_OVERVIEW_MAP_VISIBILITY = 'Fusion/SET_OVERVIEW_MAP_VISIBILITY',
    ActionType["FLYOUT_OPEN"] = "Flyout/OPEN";
    ActionType["FLYOUT_CLOSE"] = "Flyout/CLOSE";
    ActionType["CONTEXT_MENU_OPEN"] = "ContextMenu/OPEN";
    ActionType["CONTEXT_MENU_CLOSE"] = "ContextMenu/CLOSE";
    ActionType["COMPONENT_OPEN"] = "Flyout/COMPONENT_OPEN";
    ActionType["COMPONENT_CLOSE"] = "Flyout/COMPONENT_CLOSE";
    ActionType["UPDATE_MOUSE_COORDINATES"] = "Status/UPDATE_MOUSE_COORDINATES";
    ActionType["MODAL_SHOW_COMPONENT"] = "Modal/SHOW_COMPONENT";
    ActionType["MODAL_SHOW_URL"] = "Modal/SHOW_URL";
    ActionType["MODAL_CLOSE"] = "Modal/CLOSE";
    /**
     * @since 0.13
     */
    ActionType["LAYER_ADDED"] = "Map/LAYER_ADDED";
    /**
     * @since 0.14
     */
    ActionType["EXTERNAL_LAYERS_READY"] = "Map/EXTERNAL_LAYERS_READY";
    /**
     * @since 0.13
     */
    ActionType["REMOVE_LAYER"] = "Map/REMOVE_LAYER";
    /**
     * @since 0.13
     */
    ActionType["SET_LAYER_INDEX"] = "Map/SET_LAYER_INDEX";
    /**
     * @since 0.13
     */
    ActionType["SET_LAYER_OPACITY"] = "Map/SET_LAYER_OPACITY";
    /**
     * @since 0.13
     */
    ActionType["SET_LAYER_VISIBILITY"] = "Map/SET_LAYER_VISIBILITY";
    /**
     * @since 0.13
     */
    ActionType["SET_LAYER_VECTOR_STYLE"] = "Map/SET_LAYER_VECTOR_STYLE";
    /**
     * @since 0.13
     */
    ActionType["ADD_LAYER_BUSY_WORKER"] = "Map/ADD_LAYER_BUSY_WORKER";
    /**
     * @since 0.13
     */
    ActionType["REMOVE_LAYER_BUSY_WORKER"] = "Map/REMOVE_LAYER_BUSY_WORKER";
    /**
     * @since 0.14
     */
    ActionType["SET_HEATMAP_LAYER_BLUR"] = "Map/SET_HEATMAP_LAYER_BLUR";
    /**
     * @since 0.14
     */
    ActionType["SET_HEATMAP_LAYER_RADIUS"] = "Map/SET_HEATMAP_LAYER_RADIUS";
})(ActionType = exports.ActionType || (exports.ActionType = {}));


/***/ }),

/***/ "./src/constants/assets.ts":
/*!*********************************!*\
  !*** ./src/constants/assets.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ICON_INVOKE_URL = exports.ICON_INVOKE_SCRIPT = exports.ICON_INITIAL_CENTER = exports.ICON_INFO = exports.ICON_NAVIGATOR = exports.ICON_ZOOMSELECT = exports.ICON_SELECT = exports.ICON_REFRESHMAP = exports.ICON_MENUARROWUP = exports.ICON_MENUARROWUP_DISABLED = exports.ICON_MENUARROW = exports.ICON_MENUARROW_DISABLED = exports.ICON_HOME = exports.ICON_HELP = exports.ICON_GEOLOCATION = exports.ICON_FORWARD = exports.ICON_FOLDER_HORIZONTAL = exports.ICON_FOLDER_HORIZONTAL_OPEN = exports.ICON_FILE_SAVE = exports.ICON_FILE_PRINT = exports.ICON_FEATURE_INFO = exports.ICON_ERROR = exports.ICON_EDIT_XML = exports.ICON_EDIT_PASTE = exports.ICON_EDIT_DUPLICATE = exports.ICON_EDIT_CUT = exports.ICON_EDIT_COPY = exports.ICON_COORDINATE_TRACKER = exports.ICON_CONTROL = exports.ICON_CONTROL_STOP = exports.ICON_CONTROL_STOP_180 = exports.ICON_CONTROL_180 = exports.ICON_BUFFER = exports.ICON_BACK = exports.ICON_APPLICATION_BROWSER = exports.ICON_ABOUT = exports.IMG_PBMG = exports.IMG_SLIDER = exports.GIF_SPINNER = exports.IMG_SLIDER_SCALE = exports.CURSOR_ZOOM_IN = exports.CURSOR_GRAB = exports.CURSOR_GRABBING = exports.CURSOR_DIGITIZE_CIRCLE = exports.CURSOR_DIGITIZE_POLYGON = exports.CURSOR_DIGITIZE_RECT = exports.CURSOR_DIGITIZE_LINESTRING = exports.CURSOR_DIGITIZE_LINE = exports.CURSOR_DIGITIZE_POINT = exports.STD_CSS_SPRITE_RELPATH = void 0;
exports.SPRITE_ICON_ZOOMSELECT = exports.SPRITE_CONTROL = exports.SPRITE_CONTROL_180 = exports.SPRITE_COORDINATE_TRACKER = exports.SPRITE_LAYER_ADD = exports.SPRITE_GLOBE_ADD = exports.ICON_GLOBE_SHARE = exports.ICON_GLOBE_ADD = exports.ICON_LAYER_ADD = exports.ICON_ZOOM_OUT_FIXED = exports.ICON_ZOOM_IN = exports.ICON_ZOOM_IN_FIXED = exports.ICON_ZOOM_FULL = exports.ICON_ZOOM_DYNAMIC = exports.ICON_WARNING = exports.ICON_VIEW_REFRESH = exports.ICON_VIEW_FORWARD = exports.ICON_VIEW_BACK = exports.ICON_UI_MENU = exports.ICON_TOGGLE = exports.ICON_TOGGLE_EXPAND = exports.ICON_THEME = exports.ICON_SELECT_ZOOM = exports.ICON_SELECT_RADIUS = exports.ICON_SELECT_POLYGON = exports.ICON_SELECT_FEATURES = exports.ICON_SELECT_CLEAR = exports.ICON_SELECT_CENTRE = exports.ICON_SEARCH = exports.ICON_REDLINE = exports.ICON_QUERY = exports.ICON_PROPERTY = exports.ICON_PRINT = exports.ICON_PREVIEW = exports.ICON_PAN = exports.ICON_PAN_WEST = exports.ICON_PAN_SOUTH = exports.ICON_PAN_NORTH = exports.ICON_PAN_EAST = exports.ICON_OVERVIEW_MAP = exports.ICON_OUT_OF_RANGE = exports.ICON_OPTIONS = exports.ICON_MEASURE = exports.ICON_MAPTIP = exports.ICON_LEGEND_THEME = exports.ICON_LEGEND_RASTER = exports.ICON_LEGEND_MAP = exports.ICON_LEGEND_LAYER = exports.ICON_LEGEND_DWF = exports.ICON_UNSELECT = void 0;
exports.MAP_MARKER_ICON = exports.SPRITE_GLOBE_SHARE = exports.SPRITE_SELECT_CENTRE = exports.SPRITE_INVOKE_URL = exports.SPRITE_INVOKE_SCRIPT = exports.SPRITE_THEME = exports.SPRITE_QUERY = exports.SPRITE_FEATURE_INFO = exports.SPRITE_REDLINE = exports.SPRITE_SELECT_FEATURES = exports.SPRITE_BUFFER = exports.SPRITE_GEOLOCATION = exports.SPRITE_VIEW_FORWARD = exports.SPRITE_VIEW_BACK = exports.SPRITE_ICON_REFRESHMAP = exports.SPRITE_SELECT_CLEAR = exports.SPRITE_INITIAL_CENTER = exports.SPRITE_SELECT_POLYGON = exports.SPRITE_SELECT_RADIUS = exports.SPRITE_OPTIONS = exports.SPRITE_PRINT = exports.SPRITE_MEASURE = exports.SPRITE_HELP = exports.SPRITE_ABOUT = exports.SPRITE_PAN_SOUTH = exports.SPRITE_PAN_NORTH = exports.SPRITE_PAN_EAST = exports.SPRITE_PAN_WEST = exports.SPRITE_MAPTIP = exports.SPRITE_ZOOM_FULL = exports.SPRITE_ZOOM_OUT_FIXED = exports.SPRITE_ZOOM_IN_FIXED = exports.SPRITE_ZOOM_IN = exports.SPRITE_PAN = exports.SPRITE_SELECT = exports.SPRITE_ICON_MENUARROW = exports.SPRITE_ICON_MENUARROWUP = exports.SPRITE_FORWARD = exports.SPRITE_BACK = exports.SPRITE_ICON_HOME = exports.SPRITE_ICON_ERROR = exports.SPRITE_FOLDER_HORIZONTAL = exports.SPRITE_LEGEND_TOGGLE_EXPAND = exports.SPRITE_LEGEND_TOGGLE = exports.SPRITE_LEGEND_RASTER = exports.SPRITE_LEGEND_THEME = exports.SPRITE_LC_UNSELECT = exports.SPRITE_ICON_SELECT = exports.SPRITE_LEGEND_LAYER = void 0;
exports.STD_CSS_SPRITE_RELPATH = "images/icons.png";
var digitizePoint_cur_1 = __webpack_require__(/*! ../../stdassets/cursors/digitizePoint.cur */ "./stdassets/cursors/digitizePoint.cur");
Object.defineProperty(exports, "CURSOR_DIGITIZE_POINT", ({ enumerable: true, get: function () { return __importDefault(digitizePoint_cur_1).default; } }));
var digitizeLine_cur_1 = __webpack_require__(/*! ../../stdassets/cursors/digitizeLine.cur */ "./stdassets/cursors/digitizeLine.cur");
Object.defineProperty(exports, "CURSOR_DIGITIZE_LINE", ({ enumerable: true, get: function () { return __importDefault(digitizeLine_cur_1).default; } }));
var digitizeLineString_cur_1 = __webpack_require__(/*! ../../stdassets/cursors/digitizeLineString.cur */ "./stdassets/cursors/digitizeLineString.cur");
Object.defineProperty(exports, "CURSOR_DIGITIZE_LINESTRING", ({ enumerable: true, get: function () { return __importDefault(digitizeLineString_cur_1).default; } }));
var digitizeRectangle_cur_1 = __webpack_require__(/*! ../../stdassets/cursors/digitizeRectangle.cur */ "./stdassets/cursors/digitizeRectangle.cur");
Object.defineProperty(exports, "CURSOR_DIGITIZE_RECT", ({ enumerable: true, get: function () { return __importDefault(digitizeRectangle_cur_1).default; } }));
var digitizePolygon_cur_1 = __webpack_require__(/*! ../../stdassets/cursors/digitizePolygon.cur */ "./stdassets/cursors/digitizePolygon.cur");
Object.defineProperty(exports, "CURSOR_DIGITIZE_POLYGON", ({ enumerable: true, get: function () { return __importDefault(digitizePolygon_cur_1).default; } }));
var digitizeCircle_cur_1 = __webpack_require__(/*! ../../stdassets/cursors/digitizeCircle.cur */ "./stdassets/cursors/digitizeCircle.cur");
Object.defineProperty(exports, "CURSOR_DIGITIZE_CIRCLE", ({ enumerable: true, get: function () { return __importDefault(digitizeCircle_cur_1).default; } }));
var grabbing_cur_1 = __webpack_require__(/*! ../../stdassets/cursors/grabbing.cur */ "./stdassets/cursors/grabbing.cur");
Object.defineProperty(exports, "CURSOR_GRABBING", ({ enumerable: true, get: function () { return __importDefault(grabbing_cur_1).default; } }));
var grab_cur_1 = __webpack_require__(/*! ../../stdassets/cursors/grab.cur */ "./stdassets/cursors/grab.cur");
Object.defineProperty(exports, "CURSOR_GRAB", ({ enumerable: true, get: function () { return __importDefault(grab_cur_1).default; } }));
var zoomin_cur_1 = __webpack_require__(/*! ../../stdassets/cursors/zoomin.cur */ "./stdassets/cursors/zoomin.cur");
Object.defineProperty(exports, "CURSOR_ZOOM_IN", ({ enumerable: true, get: function () { return __importDefault(zoomin_cur_1).default; } }));
var sliderscale_png_1 = __webpack_require__(/*! ../../stdassets/images/res/sliderscale.png */ "./stdassets/images/res/sliderscale.png");
Object.defineProperty(exports, "IMG_SLIDER_SCALE", ({ enumerable: true, get: function () { return __importDefault(sliderscale_png_1).default; } }));
var spinner_gif_1 = __webpack_require__(/*! ../../stdassets/images/res/spinner.gif */ "./stdassets/images/res/spinner.gif");
Object.defineProperty(exports, "GIF_SPINNER", ({ enumerable: true, get: function () { return __importDefault(spinner_gif_1).default; } }));
var slider_png_1 = __webpack_require__(/*! ../../stdassets/images/res/slider.png */ "./stdassets/images/res/slider.png");
Object.defineProperty(exports, "IMG_SLIDER", ({ enumerable: true, get: function () { return __importDefault(slider_png_1).default; } }));
var PoweredBy_en_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/PoweredBy_en.png */ "./stdassets/images/icons/PoweredBy_en.png");
Object.defineProperty(exports, "IMG_PBMG", ({ enumerable: true, get: function () { return __importDefault(PoweredBy_en_png_1).default; } }));
var about_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/about.png */ "./stdassets/images/icons/about.png");
Object.defineProperty(exports, "ICON_ABOUT", ({ enumerable: true, get: function () { return __importDefault(about_png_1).default; } }));
var application_browser_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/application-browser.png */ "./stdassets/images/icons/application-browser.png");
Object.defineProperty(exports, "ICON_APPLICATION_BROWSER", ({ enumerable: true, get: function () { return __importDefault(application_browser_png_1).default; } }));
var back_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/back.png */ "./stdassets/images/icons/back.png");
Object.defineProperty(exports, "ICON_BACK", ({ enumerable: true, get: function () { return __importDefault(back_png_1).default; } }));
var buffer_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/buffer.png */ "./stdassets/images/icons/buffer.png");
Object.defineProperty(exports, "ICON_BUFFER", ({ enumerable: true, get: function () { return __importDefault(buffer_png_1).default; } }));
var control_180_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/control-180.png */ "./stdassets/images/icons/control-180.png");
Object.defineProperty(exports, "ICON_CONTROL_180", ({ enumerable: true, get: function () { return __importDefault(control_180_png_1).default; } }));
var control_stop_180_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/control-stop-180.png */ "./stdassets/images/icons/control-stop-180.png");
Object.defineProperty(exports, "ICON_CONTROL_STOP_180", ({ enumerable: true, get: function () { return __importDefault(control_stop_180_png_1).default; } }));
var control_stop_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/control-stop.png */ "./stdassets/images/icons/control-stop.png");
Object.defineProperty(exports, "ICON_CONTROL_STOP", ({ enumerable: true, get: function () { return __importDefault(control_stop_png_1).default; } }));
var control_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/control.png */ "./stdassets/images/icons/control.png");
Object.defineProperty(exports, "ICON_CONTROL", ({ enumerable: true, get: function () { return __importDefault(control_png_1).default; } }));
var coordinate_tracker_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/coordinate-tracker.png */ "./stdassets/images/icons/coordinate-tracker.png");
Object.defineProperty(exports, "ICON_COORDINATE_TRACKER", ({ enumerable: true, get: function () { return __importDefault(coordinate_tracker_png_1).default; } }));
var edit_copy_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/edit-copy.png */ "./stdassets/images/icons/edit-copy.png");
Object.defineProperty(exports, "ICON_EDIT_COPY", ({ enumerable: true, get: function () { return __importDefault(edit_copy_png_1).default; } }));
var edit_cut_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/edit-cut.png */ "./stdassets/images/icons/edit-cut.png");
Object.defineProperty(exports, "ICON_EDIT_CUT", ({ enumerable: true, get: function () { return __importDefault(edit_cut_png_1).default; } }));
var edit_duplicate_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/edit-duplicate.png */ "./stdassets/images/icons/edit-duplicate.png");
Object.defineProperty(exports, "ICON_EDIT_DUPLICATE", ({ enumerable: true, get: function () { return __importDefault(edit_duplicate_png_1).default; } }));
var edit_paste_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/edit-paste.png */ "./stdassets/images/icons/edit-paste.png");
Object.defineProperty(exports, "ICON_EDIT_PASTE", ({ enumerable: true, get: function () { return __importDefault(edit_paste_png_1).default; } }));
var edit_xml_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/edit-xml.png */ "./stdassets/images/icons/edit-xml.png");
Object.defineProperty(exports, "ICON_EDIT_XML", ({ enumerable: true, get: function () { return __importDefault(edit_xml_png_1).default; } }));
exports.ICON_ERROR = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAA31JREFUeNpc01tMUwcAxvH/ubWnFEohtBSYKJciCHJTsojOZS4mi9HswcwlZmaMBUMW2QOZMwvJnvewLSNLMDHGLXtmLpvRZS44QDYWqgWDrSBjsIGWcm1LaU8v55w9uRi/5y//t5/wXkcHAKZpYhgGCAL5LnddWUnp0dpqb6PVoggT/vuBX3+7Mzo2NDTNCxOeBTLpNPnu4r3NNbWfVSYTJ3OWl2R9fR3dMLC4XJh7KoyAINzu//abTx5O+qeeBaSW5may2SylFZVvvF5Rfav6z99bJL9PzITDZLa3ycRiJJ4ssT01Kbg2N6pPd77/zroszc0Gg0EAqbGhAUeRy3usouq2+5dbBVooRMaWg6ZpZESBtGGQSmfQrVaiKyts3btneau7+03/0tLPT5eXQ6IpCDRWeb8sGL6Tv7O2hvvMGZouDyCXl5OIRknEYrBrF7aeHoS2NqKRCNNf9Vs/On/+a0lRJNFR5Kot29w4oS39Q9I0yWlsRNq9m/KLF8HlxvR4sJ49S8LhYLuoiKSmsRwMoM7PH2o6cPBlqfXAwdP7NzZOpcIh0obB07Ex8HgwPB4yL5Wh19SwrSisDg0RGxiASAR9ZwdZ10nt2/evWFtZWa+thtGyOmkgvr6Gr7OThRs3iMoKMUVh6+5dEv39qKkUsixjlSSyK2EK7bleURRFMaPrpHQdbWeH+MwsptVKQlWJx+MkNQ2cTuweD7JuYJVlVEXBKokYuiFKRZ6SyqZc+4nIX3MkFhaQvV6cfX0knU5iIyMY4TC2lhYKjhxBWVxE2tzEAhTU7MWnqjdFn//+sFhZZcbn/yadyZBz7hzJwkK2RkdJXrkCV69in5uj+vhx9vT2ogIOw8BW34A/GByW5x4FAwuqddjm8by2FgoRunYNsb0dbXCQXFFENk0yA5eJWixErl/HKYrkl5Yy6XY/mp1+MCoANLS2Nn/xbsf4xKWP1aSmYQFURcFmsWCTJOyCgJpOkyfLOO12Uhc+pOv7wZMzk/6bEsBqKLQSzc2df/tCz6nNqSk5HouhmCZWSUIVRXJME4dpUlRWRrr7Az4dH+/1jQ5/ByA8L6vt8OH2S11dn+c8fnxo449xzPAKdlGisNiNpb6BQHHJw/4ff+gL+CZ++l/jizyRJKH9laOv7q+rO+bKy6s2dF16srm1ODUTHHng890hm9Wev/83AKQ+gKOX5raoAAAAAElFTkSuQmCC"; //require("../../stdassets/images/icons/icon_error.png");
var feature_info_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/feature-info.png */ "./stdassets/images/icons/feature-info.png");
Object.defineProperty(exports, "ICON_FEATURE_INFO", ({ enumerable: true, get: function () { return __importDefault(feature_info_png_1).default; } }));
var file_print_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/file-print.png */ "./stdassets/images/icons/file-print.png");
Object.defineProperty(exports, "ICON_FILE_PRINT", ({ enumerable: true, get: function () { return __importDefault(file_print_png_1).default; } }));
var file_save_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/file-save.png */ "./stdassets/images/icons/file-save.png");
Object.defineProperty(exports, "ICON_FILE_SAVE", ({ enumerable: true, get: function () { return __importDefault(file_save_png_1).default; } }));
var folder_horizontal_open_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/folder-horizontal-open.png */ "./stdassets/images/icons/folder-horizontal-open.png");
Object.defineProperty(exports, "ICON_FOLDER_HORIZONTAL_OPEN", ({ enumerable: true, get: function () { return __importDefault(folder_horizontal_open_png_1).default; } }));
var folder_horizontal_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/folder-horizontal.png */ "./stdassets/images/icons/folder-horizontal.png");
Object.defineProperty(exports, "ICON_FOLDER_HORIZONTAL", ({ enumerable: true, get: function () { return __importDefault(folder_horizontal_png_1).default; } }));
var forward_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/forward.png */ "./stdassets/images/icons/forward.png");
Object.defineProperty(exports, "ICON_FORWARD", ({ enumerable: true, get: function () { return __importDefault(forward_png_1).default; } }));
var geolocation_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/geolocation.png */ "./stdassets/images/icons/geolocation.png");
Object.defineProperty(exports, "ICON_GEOLOCATION", ({ enumerable: true, get: function () { return __importDefault(geolocation_png_1).default; } }));
var help_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/help.png */ "./stdassets/images/icons/help.png");
Object.defineProperty(exports, "ICON_HELP", ({ enumerable: true, get: function () { return __importDefault(help_png_1).default; } }));
var icon_home_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/icon_home.png */ "./stdassets/images/icons/icon_home.png");
Object.defineProperty(exports, "ICON_HOME", ({ enumerable: true, get: function () { return __importDefault(icon_home_png_1).default; } }));
var icon_menuarrow_disabled_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/icon_menuarrow_disabled.png */ "./stdassets/images/icons/icon_menuarrow_disabled.png");
Object.defineProperty(exports, "ICON_MENUARROW_DISABLED", ({ enumerable: true, get: function () { return __importDefault(icon_menuarrow_disabled_png_1).default; } }));
var icon_menuarrow_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/icon_menuarrow.png */ "./stdassets/images/icons/icon_menuarrow.png");
Object.defineProperty(exports, "ICON_MENUARROW", ({ enumerable: true, get: function () { return __importDefault(icon_menuarrow_png_1).default; } }));
var icon_menuarrowup_disabled_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/icon_menuarrowup_disabled.png */ "./stdassets/images/icons/icon_menuarrowup_disabled.png");
Object.defineProperty(exports, "ICON_MENUARROWUP_DISABLED", ({ enumerable: true, get: function () { return __importDefault(icon_menuarrowup_disabled_png_1).default; } }));
var icon_menuarrowup_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/icon_menuarrowup.png */ "./stdassets/images/icons/icon_menuarrowup.png");
Object.defineProperty(exports, "ICON_MENUARROWUP", ({ enumerable: true, get: function () { return __importDefault(icon_menuarrowup_png_1).default; } }));
var icon_refreshmap_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/icon_refreshmap.png */ "./stdassets/images/icons/icon_refreshmap.png");
Object.defineProperty(exports, "ICON_REFRESHMAP", ({ enumerable: true, get: function () { return __importDefault(icon_refreshmap_png_1).default; } }));
var select_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/select.png */ "./stdassets/images/icons/select.png");
Object.defineProperty(exports, "ICON_SELECT", ({ enumerable: true, get: function () { return __importDefault(select_png_1).default; } }));
var icon_zoomselect_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/icon_zoomselect.png */ "./stdassets/images/icons/icon_zoomselect.png");
Object.defineProperty(exports, "ICON_ZOOMSELECT", ({ enumerable: true, get: function () { return __importDefault(icon_zoomselect_png_1).default; } }));
var iconNavigator_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/iconNavigator.png */ "./stdassets/images/icons/iconNavigator.png");
Object.defineProperty(exports, "ICON_NAVIGATOR", ({ enumerable: true, get: function () { return __importDefault(iconNavigator_png_1).default; } }));
var info_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/info.png */ "./stdassets/images/icons/info.png");
Object.defineProperty(exports, "ICON_INFO", ({ enumerable: true, get: function () { return __importDefault(info_png_1).default; } }));
var initial_center_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/initial-center.png */ "./stdassets/images/icons/initial-center.png");
Object.defineProperty(exports, "ICON_INITIAL_CENTER", ({ enumerable: true, get: function () { return __importDefault(initial_center_png_1).default; } }));
var invoke_script_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/invoke-script.png */ "./stdassets/images/icons/invoke-script.png");
Object.defineProperty(exports, "ICON_INVOKE_SCRIPT", ({ enumerable: true, get: function () { return __importDefault(invoke_script_png_1).default; } }));
var invoke_url_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/invoke-url.png */ "./stdassets/images/icons/invoke-url.png");
Object.defineProperty(exports, "ICON_INVOKE_URL", ({ enumerable: true, get: function () { return __importDefault(invoke_url_png_1).default; } }));
var lc_unselect_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/lc_unselect.png */ "./stdassets/images/icons/lc_unselect.png");
Object.defineProperty(exports, "ICON_UNSELECT", ({ enumerable: true, get: function () { return __importDefault(lc_unselect_png_1).default; } }));
var legend_DWF_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/legend-DWF.png */ "./stdassets/images/icons/legend-DWF.png");
Object.defineProperty(exports, "ICON_LEGEND_DWF", ({ enumerable: true, get: function () { return __importDefault(legend_DWF_png_1).default; } }));
var legend_layer_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/legend-layer.png */ "./stdassets/images/icons/legend-layer.png");
Object.defineProperty(exports, "ICON_LEGEND_LAYER", ({ enumerable: true, get: function () { return __importDefault(legend_layer_png_1).default; } }));
var legend_map_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/legend-map.png */ "./stdassets/images/icons/legend-map.png");
Object.defineProperty(exports, "ICON_LEGEND_MAP", ({ enumerable: true, get: function () { return __importDefault(legend_map_png_1).default; } }));
var legend_raster_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/legend-raster.png */ "./stdassets/images/icons/legend-raster.png");
Object.defineProperty(exports, "ICON_LEGEND_RASTER", ({ enumerable: true, get: function () { return __importDefault(legend_raster_png_1).default; } }));
var legend_theme_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/legend-theme.png */ "./stdassets/images/icons/legend-theme.png");
Object.defineProperty(exports, "ICON_LEGEND_THEME", ({ enumerable: true, get: function () { return __importDefault(legend_theme_png_1).default; } }));
var maptip_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/maptip.png */ "./stdassets/images/icons/maptip.png");
Object.defineProperty(exports, "ICON_MAPTIP", ({ enumerable: true, get: function () { return __importDefault(maptip_png_1).default; } }));
var measure_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/measure.png */ "./stdassets/images/icons/measure.png");
Object.defineProperty(exports, "ICON_MEASURE", ({ enumerable: true, get: function () { return __importDefault(measure_png_1).default; } }));
var options_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/options.png */ "./stdassets/images/icons/options.png");
Object.defineProperty(exports, "ICON_OPTIONS", ({ enumerable: true, get: function () { return __importDefault(options_png_1).default; } }));
var out_of_range_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/out-of-range.png */ "./stdassets/images/icons/out-of-range.png");
Object.defineProperty(exports, "ICON_OUT_OF_RANGE", ({ enumerable: true, get: function () { return __importDefault(out_of_range_png_1).default; } }));
var overview_map_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/overview-map.png */ "./stdassets/images/icons/overview-map.png");
Object.defineProperty(exports, "ICON_OVERVIEW_MAP", ({ enumerable: true, get: function () { return __importDefault(overview_map_png_1).default; } }));
var pan_east_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/pan-east.png */ "./stdassets/images/icons/pan-east.png");
Object.defineProperty(exports, "ICON_PAN_EAST", ({ enumerable: true, get: function () { return __importDefault(pan_east_png_1).default; } }));
var pan_north_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/pan-north.png */ "./stdassets/images/icons/pan-north.png");
Object.defineProperty(exports, "ICON_PAN_NORTH", ({ enumerable: true, get: function () { return __importDefault(pan_north_png_1).default; } }));
var pan_south_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/pan-south.png */ "./stdassets/images/icons/pan-south.png");
Object.defineProperty(exports, "ICON_PAN_SOUTH", ({ enumerable: true, get: function () { return __importDefault(pan_south_png_1).default; } }));
var pan_west_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/pan-west.png */ "./stdassets/images/icons/pan-west.png");
Object.defineProperty(exports, "ICON_PAN_WEST", ({ enumerable: true, get: function () { return __importDefault(pan_west_png_1).default; } }));
var pan_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/pan.png */ "./stdassets/images/icons/pan.png");
Object.defineProperty(exports, "ICON_PAN", ({ enumerable: true, get: function () { return __importDefault(pan_png_1).default; } }));
var preview_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/preview.png */ "./stdassets/images/icons/preview.png");
Object.defineProperty(exports, "ICON_PREVIEW", ({ enumerable: true, get: function () { return __importDefault(preview_png_1).default; } }));
var print_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/print.png */ "./stdassets/images/icons/print.png");
Object.defineProperty(exports, "ICON_PRINT", ({ enumerable: true, get: function () { return __importDefault(print_png_1).default; } }));
var property_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/property.png */ "./stdassets/images/icons/property.png");
Object.defineProperty(exports, "ICON_PROPERTY", ({ enumerable: true, get: function () { return __importDefault(property_png_1).default; } }));
var query_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/query.png */ "./stdassets/images/icons/query.png");
Object.defineProperty(exports, "ICON_QUERY", ({ enumerable: true, get: function () { return __importDefault(query_png_1).default; } }));
var redline_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/redline.png */ "./stdassets/images/icons/redline.png");
Object.defineProperty(exports, "ICON_REDLINE", ({ enumerable: true, get: function () { return __importDefault(redline_png_1).default; } }));
var search_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/search.png */ "./stdassets/images/icons/search.png");
Object.defineProperty(exports, "ICON_SEARCH", ({ enumerable: true, get: function () { return __importDefault(search_png_1).default; } }));
var select_centre_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/select-centre.png */ "./stdassets/images/icons/select-centre.png");
Object.defineProperty(exports, "ICON_SELECT_CENTRE", ({ enumerable: true, get: function () { return __importDefault(select_centre_png_1).default; } }));
var select_clear_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/select-clear.png */ "./stdassets/images/icons/select-clear.png");
Object.defineProperty(exports, "ICON_SELECT_CLEAR", ({ enumerable: true, get: function () { return __importDefault(select_clear_png_1).default; } }));
var select_features_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/select-features.png */ "./stdassets/images/icons/select-features.png");
Object.defineProperty(exports, "ICON_SELECT_FEATURES", ({ enumerable: true, get: function () { return __importDefault(select_features_png_1).default; } }));
var select_polygon_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/select-polygon.png */ "./stdassets/images/icons/select-polygon.png");
Object.defineProperty(exports, "ICON_SELECT_POLYGON", ({ enumerable: true, get: function () { return __importDefault(select_polygon_png_1).default; } }));
var select_radius_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/select-radius.png */ "./stdassets/images/icons/select-radius.png");
Object.defineProperty(exports, "ICON_SELECT_RADIUS", ({ enumerable: true, get: function () { return __importDefault(select_radius_png_1).default; } }));
var select_zoom_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/select-zoom.png */ "./stdassets/images/icons/select-zoom.png");
Object.defineProperty(exports, "ICON_SELECT_ZOOM", ({ enumerable: true, get: function () { return __importDefault(select_zoom_png_1).default; } }));
var theme_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/theme.png */ "./stdassets/images/icons/theme.png");
Object.defineProperty(exports, "ICON_THEME", ({ enumerable: true, get: function () { return __importDefault(theme_png_1).default; } }));
var toggle_expand_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/toggle-expand.png */ "./stdassets/images/icons/toggle-expand.png");
Object.defineProperty(exports, "ICON_TOGGLE_EXPAND", ({ enumerable: true, get: function () { return __importDefault(toggle_expand_png_1).default; } }));
var toggle_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/toggle.png */ "./stdassets/images/icons/toggle.png");
Object.defineProperty(exports, "ICON_TOGGLE", ({ enumerable: true, get: function () { return __importDefault(toggle_png_1).default; } }));
var ui_menu_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/ui-menu.png */ "./stdassets/images/icons/ui-menu.png");
Object.defineProperty(exports, "ICON_UI_MENU", ({ enumerable: true, get: function () { return __importDefault(ui_menu_png_1).default; } }));
var view_back_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/view-back.png */ "./stdassets/images/icons/view-back.png");
Object.defineProperty(exports, "ICON_VIEW_BACK", ({ enumerable: true, get: function () { return __importDefault(view_back_png_1).default; } }));
var view_forward_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/view-forward.png */ "./stdassets/images/icons/view-forward.png");
Object.defineProperty(exports, "ICON_VIEW_FORWARD", ({ enumerable: true, get: function () { return __importDefault(view_forward_png_1).default; } }));
var view_refresh_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/view-refresh.png */ "./stdassets/images/icons/view-refresh.png");
Object.defineProperty(exports, "ICON_VIEW_REFRESH", ({ enumerable: true, get: function () { return __importDefault(view_refresh_png_1).default; } }));
var icon_warning_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/icon_warning.png */ "./stdassets/images/icons/icon_warning.png");
Object.defineProperty(exports, "ICON_WARNING", ({ enumerable: true, get: function () { return __importDefault(icon_warning_png_1).default; } }));
var zoom_dynamic_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/zoom-dynamic.png */ "./stdassets/images/icons/zoom-dynamic.png");
Object.defineProperty(exports, "ICON_ZOOM_DYNAMIC", ({ enumerable: true, get: function () { return __importDefault(zoom_dynamic_png_1).default; } }));
var zoom_full_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/zoom-full.png */ "./stdassets/images/icons/zoom-full.png");
Object.defineProperty(exports, "ICON_ZOOM_FULL", ({ enumerable: true, get: function () { return __importDefault(zoom_full_png_1).default; } }));
var zoom_in_fixed_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/zoom-in-fixed.png */ "./stdassets/images/icons/zoom-in-fixed.png");
Object.defineProperty(exports, "ICON_ZOOM_IN_FIXED", ({ enumerable: true, get: function () { return __importDefault(zoom_in_fixed_png_1).default; } }));
var zoom_in_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/zoom-in.png */ "./stdassets/images/icons/zoom-in.png");
Object.defineProperty(exports, "ICON_ZOOM_IN", ({ enumerable: true, get: function () { return __importDefault(zoom_in_png_1).default; } }));
var zoom_out_fixed_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/zoom-out-fixed.png */ "./stdassets/images/icons/zoom-out-fixed.png");
Object.defineProperty(exports, "ICON_ZOOM_OUT_FIXED", ({ enumerable: true, get: function () { return __importDefault(zoom_out_fixed_png_1).default; } }));
var layer_add_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/layer_add.png */ "./stdassets/images/icons/layer_add.png");
Object.defineProperty(exports, "ICON_LAYER_ADD", ({ enumerable: true, get: function () { return __importDefault(layer_add_png_1).default; } }));
var globe_add_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/globe_add.png */ "./stdassets/images/icons/globe_add.png");
Object.defineProperty(exports, "ICON_GLOBE_ADD", ({ enumerable: true, get: function () { return __importDefault(globe_add_png_1).default; } }));
/**
 * @since 0.11
 */
var globe_share_png_1 = __webpack_require__(/*! ../../stdassets/images/icons/globe-share.png */ "./stdassets/images/icons/globe-share.png");
Object.defineProperty(exports, "ICON_GLOBE_SHARE", ({ enumerable: true, get: function () { return __importDefault(globe_share_png_1).default; } }));
exports.SPRITE_GLOBE_ADD = "globe_add";
exports.SPRITE_LAYER_ADD = "layer_add";
exports.SPRITE_COORDINATE_TRACKER = "coordinate-tracker";
exports.SPRITE_CONTROL_180 = "control-180";
exports.SPRITE_CONTROL = "control";
exports.SPRITE_ICON_ZOOMSELECT = "icon_zoomselect";
exports.SPRITE_LEGEND_LAYER = "legend-layer";
exports.SPRITE_ICON_SELECT = "icon_select";
exports.SPRITE_LC_UNSELECT = "lc_unselect";
exports.SPRITE_LEGEND_THEME = "legend-theme";
exports.SPRITE_LEGEND_RASTER = "legend-raster";
exports.SPRITE_LEGEND_TOGGLE = "toggle";
exports.SPRITE_LEGEND_TOGGLE_EXPAND = "toggle-expand";
exports.SPRITE_FOLDER_HORIZONTAL = "folder-horizontal";
exports.SPRITE_ICON_ERROR = "icon_error";
exports.SPRITE_ICON_HOME = "icon_home";
exports.SPRITE_BACK = "back";
exports.SPRITE_FORWARD = "forward";
exports.SPRITE_ICON_MENUARROWUP = "icon_menuarrowup";
exports.SPRITE_ICON_MENUARROW = "icon_menuarrow";
exports.SPRITE_SELECT = "select";
exports.SPRITE_PAN = "pan";
exports.SPRITE_ZOOM_IN = "zoom-in";
exports.SPRITE_ZOOM_IN_FIXED = "zoom-in-fixed";
exports.SPRITE_ZOOM_OUT_FIXED = "zoom-out-fixed";
exports.SPRITE_ZOOM_FULL = "zoom-full";
exports.SPRITE_MAPTIP = "maptip";
exports.SPRITE_PAN_WEST = "pan-west";
exports.SPRITE_PAN_EAST = "pan-east";
exports.SPRITE_PAN_NORTH = "pan-north";
exports.SPRITE_PAN_SOUTH = "pan-south";
exports.SPRITE_ABOUT = "about";
exports.SPRITE_HELP = "help";
exports.SPRITE_MEASURE = "measure";
exports.SPRITE_PRINT = "print";
exports.SPRITE_OPTIONS = "options";
exports.SPRITE_SELECT_RADIUS = "select-radius";
exports.SPRITE_SELECT_POLYGON = "select-polygon";
exports.SPRITE_INITIAL_CENTER = "initial-center";
exports.SPRITE_SELECT_CLEAR = "select-clear";
exports.SPRITE_ICON_REFRESHMAP = "icon_refreshmap";
exports.SPRITE_VIEW_BACK = "view-back";
exports.SPRITE_VIEW_FORWARD = "view-forward";
exports.SPRITE_GEOLOCATION = "geolocation";
exports.SPRITE_BUFFER = "buffer";
exports.SPRITE_SELECT_FEATURES = "select-features";
exports.SPRITE_REDLINE = "redline";
exports.SPRITE_FEATURE_INFO = "feature-info";
exports.SPRITE_QUERY = "query";
exports.SPRITE_THEME = "theme";
exports.SPRITE_INVOKE_SCRIPT = "invoke-script";
exports.SPRITE_INVOKE_URL = "invoke-url";
exports.SPRITE_SELECT_CENTRE = "select-centre";
/**
 * @since 0.11
 */
exports.SPRITE_GLOBE_SHARE = "globe-share";
/**
 * Default map marker icon
 *
 * source: https://www.iconfinder.com/paomedia
 * used under CC-BY 3.0
 * @since 0.13
 */
exports.MAP_MARKER_ICON = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAEZUlEQVRYR8WWXUxbZRjHn/ecnlLaHqBkyIeAwIaTUuIH4GiB9Yxo5sZIZiLGJSYu8YY74wW7cIksLplxIXq5mF1o9Ga6GNTAFqKGImsLMrwYBYeOBWSUUeWjPf047fl4zWEhnrK2p6ebsbfP+///f+d53/fpi+B//iGt+XO9Vr0lUtyFELYDQpUgAUII/EDAJCvQP9Rfvx7X4pk1AG5upu5XGN4BjM8AECVpQjYxwCfxsG6w1uXisgHJCuCvo53lAgnfAYFbszGVAGaRJPVUXPMsq61XBfD3MPsQTrgBiKfVzJR1jOEeReJDJd+7/Zl0qgBrJ9pHANBxLeH/rsUTZcNuJwLA6fQZAda6O7sB4eFUYlHCEBOFHWuDjgQdQaTMQBidKhuZuJITwOorHW5CB46k1gKG9UgMQlwcMEjrEhASCVBeYMiDUlM+IEj+JhGwr3LY3aQZINDLmPkoHyQQSvo0PxsBlk98ThLE+c4bs3dl47G2Z2oQQQ6YKer0k7T5oSxESaVlQ55AKoi0W3C/h2nDWPAqRVFegJUQO8B45z5IZTbmsJ2rok0DJopKKou8dKJy1DOiCeD3l1/so/P0l5Siv8PRVZvr16p0hwoDELNHnr9XYjKVK3URXnz/wKj3vCaA+Zda+i0Gw0WlaDPCfdU4dvONTDdirqvl62KjoVe5ZpuLDzb8ON2vCWCGeeHNCrPxS6UozMe/qR+dfi0TwOLRQ0NGijqpXBMIx/qfdc0MagIYb7M11BQXzOsV14sX8UZVgCtHMzN8KrM/jh3Ly8fba6SOtOzWRYzhztaGg/HcTjpPu/W0h1DeTx/THNpnzjcpwxDA5dKWG33oHEjJ1xPQWnfHZYTg7aRt46JCQNikj7iWUv43ZBxEP9utl2otRX0PDRlJGscEXKAI5OUxJ5LI0C4J+CwQhFMZLmEMy1uhbx2e2Vc1zwFZMNFuraYp/Z1Sszn5XmU6BIpaIMbhjXC8tWtqdiYnAFnksjd9XFtEv6snU4/adMaCJMHidvAK45k7lYlX9c/IY28spkjdn5VFdNJZUGuCn40kwlH+gHPat/JIADtdaGs8U11Ef5Sv06nl7tTjgghLweCHjHf+PTWBagdkgzGmxmCUCperC+gn1Azl+grLbiUE7qkO9wKrtj4rgB2INuvpykL6M/OeOb83IMLzsBpi+5ze+U/VwuV61gDyXPA4bLfrLEX16VTyq2M5GFpcKTt48PWrV8XHCiCbjbc3HC8z0iMFefqU3kEuAesxttvp/u1aNuGaOrBr6Om0emoKLfa9Dw956CxtsxPt7luHsw3PCcDlaGwtMeb/UmwwJOUEojEcjMSfOzzlu/WfAuxMSIdtqM5SeJJAD46QIGG4uxX8wun1vaUlPKcOyKKfHLb9hTpioZymSYwB/OFwPCFydR3uhYxP8FRwWd+CvWKX3XoRAD14ZGB0lpn0XdD69Tl3YDfI5WiyS5IodU3OT+US/sgAuYYqdTlvweMIlz3+AXmLlDDLPM0mAAAAAElFTkSuQmCC";


/***/ }),

/***/ "./src/containers/add-manage-layers.tsx":
/*!**********************************************!*\
  !*** ./src/containers/add-manage-layers.tsx ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddManageLayersContainer = exports.zoomToLayerExtents = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var manage_layers_1 = __webpack_require__(/*! ../components/layer-manager/manage-layers */ "./src/components/layer-manager/manage-layers.tsx");
var add_layer_1 = __webpack_require__(/*! ../components/layer-manager/add-layer */ "./src/components/layer-manager/add-layer.tsx");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var Vector_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Vector */ "./node_modules/ol/layer/Vector.js"));
var Cluster_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/Cluster */ "./node_modules/ol/source/Cluster.js"));
var proj_1 = __webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var runtime_1 = __webpack_require__(/*! ../api/runtime */ "./src/api/runtime.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
function zoomToLayerExtents(layerName, viewer) {
    var layer = viewer.getLayerManager().getLayer(layerName);
    // If the layer has a WGS84 bbox, we'll use that
    var ll_bbox = layer === null || layer === void 0 ? void 0 : layer.get(common_1.LayerProperty.WGS84_BBOX);
    if (ll_bbox) {
        var zoomBounds = (0, proj_1.transformExtent)(ll_bbox, "EPSG:4326", viewer.getProjection());
        viewer.zoomToExtent(zoomBounds);
    }
    else if (layer instanceof Vector_1.default) {
        var source = layer.getSource();
        var bounds = void 0;
        if (source instanceof Cluster_1.default) {
            bounds = source.getSource().getExtent();
        }
        else {
            bounds = source.getExtent();
        }
        var sp = source.getProjection();
        var dp = viewer.getProjection();
        if (sp && dp) {
            bounds = (0, proj_1.transformExtent)(bounds, sp, dp);
        }
        if (Number.isFinite(bounds[0]) &&
            Number.isFinite(bounds[1]) &&
            Number.isFinite(bounds[2]) &&
            Number.isFinite(bounds[3])) {
            viewer.zoomToExtent(bounds);
        }
        else {
            console.warn("Attempted to zoom to invalid bounds for layer: " + layerName);
        }
    }
}
exports.zoomToLayerExtents = zoomToLayerExtents;
var AddManageLayersContainer = function () {
    var dispatch = (0, context_1.useReduxDispatch)();
    var locale = (0, hooks_1.useViewerLocale)();
    var activeMapName = (0, hooks_1.useActiveMapName)();
    var layers = (0, hooks_1.useActiveMapLayers)();
    var view = (0, hooks_1.useActiveMapView)();
    var getLayerIndex = function (layerName) {
        if (layers) {
            for (var i = 0; i < layers.length; i++) {
                if (layers[i].name == layerName) {
                    return i;
                }
            }
        }
        return -1;
    };
    var onLayerAdded = function (layer) {
        if (activeMapName) {
            dispatch((0, map_1.mapLayerAdded)(activeMapName, layer));
        }
    };
    var onAddLayerBusyWorker = function (name) {
        if (activeMapName) {
            dispatch((0, map_1.addMapLayerBusyWorker)(activeMapName, name));
        }
    };
    var onRemoveLayerBusyWorker = function (name) {
        if (activeMapName) {
            dispatch((0, map_1.removeMapLayerBusyWorker)(activeMapName, name));
        }
    };
    var removeHandler = function (layerName) {
        if (activeMapName) {
            dispatch((0, map_1.removeMapLayer)(activeMapName, layerName));
        }
    };
    var upHandler = function (layerName) {
        var newIndex = getLayerIndex(layerName);
        if (activeMapName && newIndex >= 0) {
            dispatch((0, map_1.setMapLayerIndex)(activeMapName, layerName, newIndex - 1));
        }
    };
    var downHandler = function (layerName) {
        var newIndex = getLayerIndex(layerName);
        if (layers && activeMapName && newIndex < layers.length - 1) {
            dispatch((0, map_1.setMapLayerIndex)(activeMapName, layerName, newIndex + 1));
        }
    };
    var zoomToBounds = function (layerName) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            zoomToLayerExtents(layerName, viewer);
        }
    };
    var setVisibility = function (layerName, visible) {
        if (activeMapName) {
            dispatch((0, map_1.setMapLayerVisibility)(activeMapName, layerName, visible));
        }
    };
    var setOpacity = function (layerName, value) {
        if (activeMapName) {
            dispatch((0, map_1.setMapLayerOpacity)(activeMapName, layerName, value));
        }
    };
    var setHeatmapBlur = function (layerName, value) {
        if (activeMapName) {
            dispatch((0, map_1.setHeatmapLayerBlur)(activeMapName, layerName, value));
        }
    };
    var setHeatmapRadius = function (layerName, value) {
        if (activeMapName) {
            dispatch((0, map_1.setHeatmapLayerRadius)(activeMapName, layerName, value));
        }
    };
    var updateVectorStyle = function (layerName, value, which) {
        if (activeMapName) {
            dispatch((0, map_1.setMapLayerVectorStyle)(activeMapName, layerName, value, which));
        }
    };
    if (layers) {
        return React.createElement("div", { style: { padding: 8 } },
            React.createElement(core_1.Tabs, { id: "tabs", renderActiveTabPanelOnly: true },
                React.createElement(core_1.Tab, { id: "add_layer", title: React.createElement("span", null,
                        React.createElement(core_1.Icon, { icon: "new-layer", iconSize: core_1.Icon.SIZE_STANDARD }),
                        " ",
                        (0, i18n_1.tr)("ADD_LAYER", locale)), panel: React.createElement(add_layer_1.AddLayer, { onLayerAdded: onLayerAdded, onAddLayerBusyWorker: onAddLayerBusyWorker, onRemoveLayerBusyWorker: onRemoveLayerBusyWorker, locale: locale }) }),
                React.createElement(core_1.Tab, { id: "manage_layers", title: React.createElement("span", null,
                        React.createElement(core_1.Icon, { icon: "layers", iconSize: core_1.Icon.SIZE_STANDARD }),
                        " ",
                        (0, i18n_1.tr)("MANAGE_LAYERS", locale)), panel: React.createElement(manage_layers_1.ManageLayers, { layers: layers, locale: locale, currentResolution: view === null || view === void 0 ? void 0 : view.resolution, onSetOpacity: setOpacity, onSetHeatmapBlur: setHeatmapBlur, onSetHeatmapRadius: setHeatmapRadius, onSetVisibility: setVisibility, onZoomToBounds: zoomToBounds, onMoveLayerDown: downHandler, onMoveLayerUp: upHandler, onRemoveLayer: removeHandler, onVectorStyleChanged: updateVectorStyle }) })));
    }
    else {
        return React.createElement(React.Fragment, null);
    }
};
exports.AddManageLayersContainer = AddManageLayersContainer;


/***/ }),

/***/ "./src/containers/app.tsx":
/*!********************************!*\
  !*** ./src/containers/app.tsx ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.App = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var layout_1 = __webpack_require__(/*! ../api/registry/layout */ "./src/api/registry/layout.ts");
var init_1 = __webpack_require__(/*! ../actions/init */ "./src/actions/init.ts");
var error_1 = __webpack_require__(/*! ../components/error */ "./src/components/error.tsx");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var asset_1 = __webpack_require__(/*! ../utils/asset */ "./src/utils/asset.ts");
var runtime_1 = __webpack_require__(/*! ../api/runtime */ "./src/api/runtime.ts");
var context_1 = __webpack_require__(/*! ../components/context */ "./src/components/context.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var url_state_1 = __webpack_require__(/*! ./url-state */ "./src/containers/url-state.ts");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
var template_1 = __webpack_require__(/*! ../actions/template */ "./src/actions/template.ts");
var context_2 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var AppInner = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(AppInner, _super);
    function AppInner(props) {
        var _this = _super.call(this, props) || this;
        _this.initErrorRenderer = function (err) {
            var _a = _this.props, configuredLocale = _a.configuredLocale, initOptions = _a.initOptions;
            var locale = configuredLocale;
            if (initOptions && initOptions.locale) {
                locale = initOptions.locale;
            }
            //Not showing stack as the error cases are well-defined here and we know where they
            //originate from
            return React.createElement(core_1.Callout, { intent: core_1.Intent.DANGER, title: (0, i18n_1.tr)("INIT_ERROR_TITLE", locale), icon: "error" }, _this.renderErrorMessage(err, locale, initOptions || {}));
        };
        _this.state = {
            isLoading: true
        };
        return _this;
    }
    AppInner.prototype.allowHtmlValuesInSelection = function () {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.props.mapguide) === null || _a === void 0 ? void 0 : _a.selectionSettings) === null || _b === void 0 ? void 0 : _b.allowHtmlValues) !== null && _c !== void 0 ? _c : false;
    };
    AppInner.prototype.getHtmlCleaner = function () {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.props.mapguide) === null || _a === void 0 ? void 0 : _a.selectionSettings) === null || _b === void 0 ? void 0 : _b.cleanHtml) !== null && _c !== void 0 ? _c : (function (v) { return v; });
    };
    AppInner.prototype.componentDidMount = function () {
        var _a;
        var _b = this.props, onInit = _b.onInit, setElementVisibility = _b.setElementVisibility, mapguide = _b.mapguide, initLayout = _b.initLayout, locale = _b.locale, resourceId = _b.resourceId, externalBaseLayers = _b.externalBaseLayers, initCommand = _b.initCommand;
        var _c = (0, url_state_1.getStateFromUrl)(this.props.urlPropsIgnore), urlLocale = _c.locale, urlResource = _c.resource, urlSession = _c.session, urlX = _c.x, urlY = _c.y, urlFeatureTooltip = _c.ft, urlScale = _c.scale, urlMap = _c.map, urlShowLayers = _c.sl, urlHideLayers = _c.hl, urlShowGroups = _c.sg, urlHideGroups = _c.hg;
        if (setElementVisibility && (mapguide === null || mapguide === void 0 ? void 0 : mapguide.initialElementVisibility)) {
            var _d = mapguide.initialElementVisibility, taskpane = _d.taskpane, legend = _d.legend, selection = _d.selection;
            var states = {
                taskPaneVisible: typeof (taskpane) != 'undefined' ? taskpane : true,
                legendVisible: typeof (legend) != 'undefined' ? legend : true,
                selectionPanelVisible: typeof (selection) != 'undefined' ? selection : true
            };
            setElementVisibility(states);
        }
        (0, logger_1.debug)("Asset root is: " + (0, asset_1.getAssetRoot)());
        if (mapguide === null || mapguide === void 0 ? void 0 : mapguide.fusionRoot) {
            (0, runtime_1.setFusionRoot)(mapguide.fusionRoot);
        }
        if (initLayout) {
            var ftArgs = void 0;
            if (typeof (urlFeatureTooltip) != 'undefined') {
                ftArgs = {
                    featureTooltipsEnabled: urlFeatureTooltip
                };
            }
            var amArgs = void 0;
            if (urlMap) {
                amArgs = {
                    initialActiveMap: urlMap
                };
            }
            var ivArgs = void 0;
            if (urlX && urlY && urlScale) {
                ivArgs = {
                    initialView: {
                        x: urlX,
                        y: urlY,
                        scale: urlScale
                    }
                };
            }
            var slArgs = void 0;
            if (urlShowLayers) {
                slArgs = {
                    initialShowLayers: (0, tslib_1.__spreadArray)([], urlShowLayers, true)
                };
            }
            var hlArgs = void 0;
            if (urlHideLayers) {
                hlArgs = {
                    initialHideLayers: (0, tslib_1.__spreadArray)([], urlHideLayers, true)
                };
            }
            var sgArgs = void 0;
            if (urlShowGroups) {
                sgArgs = {
                    initialShowGroups: (0, tslib_1.__spreadArray)([], urlShowGroups, true)
                };
            }
            var hgArgs = void 0;
            if (urlHideGroups) {
                hgArgs = {
                    initialHideGroups: (0, tslib_1.__spreadArray)([], urlHideGroups, true)
                };
            }
            var args = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({
                resourceId: urlResource !== null && urlResource !== void 0 ? urlResource : resourceId,
                locale: (_a = urlLocale !== null && urlLocale !== void 0 ? urlLocale : locale) !== null && _a !== void 0 ? _a : i18n_1.DEFAULT_LOCALE,
                externalBaseLayers: externalBaseLayers,
                session: urlSession !== null && urlSession !== void 0 ? urlSession : mapguide === null || mapguide === void 0 ? void 0 : mapguide.session,
                onInit: onInit,
                layout: typeof (this.props.layout) == 'string' ? this.props.layout : undefined
            }, (ftArgs !== null && ftArgs !== void 0 ? ftArgs : {})), (amArgs !== null && amArgs !== void 0 ? amArgs : {})), (ivArgs !== null && ivArgs !== void 0 ? ivArgs : {})), (slArgs !== null && slArgs !== void 0 ? slArgs : {})), (hlArgs !== null && hlArgs !== void 0 ? hlArgs : {})), (sgArgs !== null && sgArgs !== void 0 ? sgArgs : {})), (hgArgs !== null && hgArgs !== void 0 ? hgArgs : {}));
            initLayout(initCommand, args);
        }
    };
    AppInner.prototype.componentDidUpdate = function (prevProps) {
        var _a, _b, _c, _d;
        var nextProps = this.props;
        var curUrlState = (0, url_state_1.getStateFromUrl)();
        //Preserve locale/resources/session if already present in url
        var nextUrlState = {
            locale: (_a = curUrlState.locale) !== null && _a !== void 0 ? _a : this.props.locale,
            session: (_b = curUrlState.session) !== null && _b !== void 0 ? _b : (_c = this.props.mapguide) === null || _c === void 0 ? void 0 : _c.session
        };
        if (typeof (this.props.resourceId) == 'string') {
            nextUrlState.resource = (_d = curUrlState.resource) !== null && _d !== void 0 ? _d : this.props.resourceId;
        }
        if (nextProps.featureTooltipsEnabled != prevProps.featureTooltipsEnabled) {
            nextUrlState.ft = nextProps.featureTooltipsEnabled;
        }
        if (nextProps.map != null && prevProps.map != nextProps.map) {
            this.setState({ isLoading: false });
        }
        if (nextProps.activeMapName) {
            var am = nextProps.activeMapName;
            nextUrlState.map = am;
        }
        if (nextProps.map) {
            if (nextProps.map.currentView) {
                var _e = nextProps.map.currentView, x = _e.x, y = _e.y, scale = _e.scale;
                nextUrlState.x = x;
                nextUrlState.y = y;
                nextUrlState.scale = scale;
            }
            var mgs = nextProps.map.mapguide;
            if (mgs) {
                var rtm = mgs.runtimeMap;
                var showGroups = mgs.showGroups, showLayers = mgs.showLayers, hideGroups = mgs.hideGroups, hideLayers = mgs.hideLayers;
                var sg = [];
                var hg = [];
                var sl = [];
                var hl = [];
                if (rtm === null || rtm === void 0 ? void 0 : rtm.Group) {
                    for (var _i = 0, _f = rtm.Group; _i < _f.length; _i++) {
                        var g = _f[_i];
                        if (showGroups.indexOf(g.ObjectId) >= 0) {
                            sg.push(g.Name);
                        }
                        else if (hideGroups.indexOf(g.ObjectId) >= 0) {
                            hg.push(g.Name);
                        }
                    }
                }
                if (rtm === null || rtm === void 0 ? void 0 : rtm.Layer) {
                    for (var _g = 0, _h = rtm.Layer; _g < _h.length; _g++) {
                        var l = _h[_g];
                        if (showLayers.indexOf(l.ObjectId) >= 0) {
                            sl.push(l.Name);
                        }
                        else if (hideLayers.indexOf(l.ObjectId) >= 0) {
                            hl.push(l.Name);
                        }
                    }
                }
                if (sg.length > 0)
                    nextUrlState.sg = sg;
                if (hg.length > 0)
                    nextUrlState.hg = hg;
                if (sl.length > 0)
                    nextUrlState.sl = sl;
                if (hl.length > 0)
                    nextUrlState.hl = hl;
                if (rtm) {
                    var SessionId = rtm.SessionId;
                    nextUrlState.session = SessionId;
                }
            }
        }
        (0, url_state_1.updateUrl)(nextUrlState);
    };
    AppInner.prototype.renderErrorMessage = function (err, locale, args) {
        var _this = this;
        var msg = err.message;
        switch (msg) {
            case "MgConnectionFailedException":
                {
                    var arg = { __html: (0, i18n_1.tr)("INIT_ERROR_NO_CONNECTION", locale) };
                    return React.createElement("div", { dangerouslySetInnerHTML: arg });
                }
            case "MgResourceNotFoundException":
                {
                    var arg = { __html: (0, i18n_1.tr)("INIT_ERROR_RESOURCE_NOT_FOUND", locale, { resourceId: args.resourceId }) };
                    return React.createElement("div", { dangerouslySetInnerHTML: arg });
                }
            case "MgSessionExpiredException":
                {
                    var arg = { __html: (0, i18n_1.tr)("INIT_ERROR_EXPIRED_SESSION", locale, { sessionId: args.session }) };
                    return React.createElement("div", { dangerouslySetInnerHTML: arg });
                }
            default:
                {
                    var arg = { __html: msg };
                    var stack_1 = (0, error_1.normalizeStack)(err);
                    return React.createElement("div", null,
                        React.createElement("div", { dangerouslySetInnerHTML: arg }),
                        (function () {
                            if (_this.props.includeStack === true && stack_1.length > 0) {
                                return React.createElement("div", null,
                                    React.createElement("p", null, "Stack Trace"),
                                    React.createElement("ul", null, stack_1.map(function (ln, i) { return React.createElement("li", { key: "stack-line-" + i }, ln); })));
                            }
                        })());
                }
        }
    };
    AppInner.prototype.render = function () {
        var _this = this;
        var _a = this.props, layout = _a.layout, configuredLocale = _a.configuredLocale, error = _a.error;
        var isLoading = this.state.isLoading;
        if (error) {
            return React.createElement(error_1.Error, { error: error, errorRenderer: this.initErrorRenderer });
        }
        else {
            //NOTE: Locale may not have been set at this point, so use default
            var locale = configuredLocale;
            if (isLoading) {
                return React.createElement(core_1.NonIdealState, { icon: React.createElement(core_1.Spinner, { intent: core_1.Intent.NONE, size: core_1.Spinner.SIZE_LARGE }), title: (0, i18n_1.tr)("INIT", locale), description: (0, i18n_1.tr)("INIT_DESC", locale) });
            }
            else {
                var layoutEl = typeof (layout) == 'string' ? (0, layout_1.getLayout)(layout) : layout.factory;
                if (layoutEl) {
                    var providerImpl = {
                        allowHtmlValuesInSelection: function () { return _this.allowHtmlValuesInSelection(); },
                        getHTMLCleaner: function () { return _this.getHtmlCleaner(); }
                    };
                    return React.createElement(context_1.AppContext.Provider, { value: providerImpl }, layoutEl());
                }
                else {
                    return React.createElement(error_1.Error, { error: (0, i18n_1.tr)("ERR_UNREGISTERED_LAYOUT", locale, { layout: layout }) });
                }
            }
        }
    };
    return AppInner;
}(React.Component));
var App = function (props) {
    var error = (0, hooks_1.useInitError)();
    var includeStack = (0, hooks_1.useInitErrorStack)();
    var initOptions = (0, hooks_1.useInitErrorOptions)();
    var configuredLocale = (0, hooks_1.useViewerLocale)();
    var map = (0, hooks_1.useActiveMapBranch)();
    var activeMapName = (0, hooks_1.useActiveMapName)();
    var ftEnabled = (0, hooks_1.useViewerFeatureTooltipsEnabled)();
    var dispatch = (0, context_2.useReduxDispatch)();
    var initLayoutAction = function (cmd, args) { return dispatch((0, init_1.initLayout)(cmd, args)); };
    var setElementVisibility = function (state) { return dispatch((0, template_1.setElementStates)(state)); };
    return React.createElement(AppInner, (0, tslib_1.__assign)({ error: error, includeStack: includeStack, initOptions: initOptions, featureTooltipsEnabled: ftEnabled, configuredLocale: configuredLocale, map: map, activeMapName: activeMapName, initLayout: initLayoutAction, setElementVisibility: setElementVisibility }, props));
};
exports.App = App;


/***/ }),

/***/ "./src/containers/base-layer-switcher.tsx":
/*!************************************************!*\
  !*** ./src/containers/base-layer-switcher.tsx ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseLayerSwitcherContainer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var base_layer_switcher_1 = __webpack_require__(/*! ../components/base-layer-switcher */ "./src/components/base-layer-switcher.tsx");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var BaseLayerSwitcherContainer = function () {
    var mapName = (0, hooks_1.useActiveMapName)();
    var locale = (0, hooks_1.useViewerLocale)();
    var externalBaseLayers = (0, hooks_1.useActiveMapExternalBaseLayers)(false);
    var dispatch = (0, context_1.useReduxDispatch)();
    var setBaseLayerAction = function (mapName, layerName) { return dispatch((0, map_1.setBaseLayer)(mapName, layerName)); };
    var onBaseLayerChanged = function (layerName) {
        if (mapName) {
            setBaseLayerAction === null || setBaseLayerAction === void 0 ? void 0 : setBaseLayerAction(mapName, layerName);
        }
    };
    if (locale && externalBaseLayers) {
        return React.createElement(base_layer_switcher_1.BaseLayerSwitcher, { onBaseLayerChanged: onBaseLayerChanged, externalBaseLayers: externalBaseLayers, locale: locale });
    }
    else {
        return React.createElement("noscript", null);
    }
};
exports.BaseLayerSwitcherContainer = BaseLayerSwitcherContainer;


/***/ }),

/***/ "./src/containers/coordinate-tracker.tsx":
/*!***********************************************!*\
  !*** ./src/containers/coordinate-tracker.tsx ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CoordinateTrackerContainer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var olProj = (0, tslib_1.__importStar)(__webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js"));
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var hooks_mapguide_1 = __webpack_require__(/*! ./hooks-mapguide */ "./src/containers/hooks-mapguide.ts");
var CoordinateTrackerContainer = function (props) {
    var projections = props.projections;
    var locale = (0, hooks_1.useViewerLocale)();
    var mouse = (0, hooks_1.useCurrentMouseCoordinates)();
    var proj = (0, hooks_mapguide_1.useActiveMapProjection)();
    if (projections && projections.length) {
        return React.createElement("div", { style: { margin: 8 } },
            React.createElement("h4", { className: "bp3-heading" }, (0, i18n_1.tr)("COORDTRACKER", locale)),
            projections.map(function (p) {
                var _a;
                var x = NaN;
                var y = NaN;
                if (mouse && proj) {
                    try {
                        _a = olProj.transform(mouse, proj, p), x = _a[0], y = _a[1];
                    }
                    catch (e) {
                    }
                }
                return React.createElement(core_1.Card, { key: p, style: { marginBottom: 10 } },
                    React.createElement("h5", { className: "bp3-heading" },
                        React.createElement("a", { href: "#" }, p)),
                    React.createElement("p", null,
                        React.createElement("strong", null, "X:"),
                        " ",
                        x),
                    React.createElement("p", null,
                        React.createElement("strong", null, "Y:"),
                        " ",
                        y));
            }));
    }
    else {
        return React.createElement(core_1.Callout, { intent: core_1.Intent.DANGER, title: (0, i18n_1.tr)("ERROR", locale), icon: "error" }, (0, i18n_1.tr)("COORDTRACKER_NO_PROJECTIONS", locale));
    }
};
exports.CoordinateTrackerContainer = CoordinateTrackerContainer;


/***/ }),

/***/ "./src/containers/flyout-region.tsx":
/*!******************************************!*\
  !*** ./src/containers/flyout-region.tsx ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlyoutRegionContainer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var flyout_region_1 = __webpack_require__(/*! ../components/flyout-region */ "./src/components/flyout-region.tsx");
var command_1 = __webpack_require__(/*! ../api/registry/command */ "./src/api/registry/command.ts");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var flyout_1 = __webpack_require__(/*! ../actions/flyout */ "./src/actions/flyout.ts");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var FlyoutRegionContainer = function () {
    var dispatch = (0, context_1.useReduxDispatch)();
    var closeFlyoutAction = function (id) { return dispatch((0, flyout_1.closeFlyout)(id)); };
    var invokeCommandAction = function (cmd, parameters) { return dispatch((0, map_1.invokeCommand)(cmd, parameters)); };
    var onCloseFlyout = function (id) { return closeFlyoutAction(id); };
    var flyouts = (0, hooks_1.useViewerFlyouts)();
    var locale = (0, hooks_1.useViewerLocale)();
    var tbState = (0, hooks_1.useReducedToolbarAppState)();
    var prepared = {};
    if (invokeCommandAction) {
        for (var flyoutId in flyouts) {
            var tb = flyouts[flyoutId];
            if (typeof (tb.componentName) == 'undefined') {
                prepared[flyoutId] = (0, command_1.mapToolbarReference)(tb, tbState, invokeCommandAction);
                prepared[flyoutId].open = !!flyouts[flyoutId].open;
                prepared[flyoutId].metrics = flyouts[flyoutId].metrics;
            }
            else {
                prepared[flyoutId] = flyouts[flyoutId];
            }
        }
    }
    return React.createElement(flyout_region_1.FlyoutRegion, { flyoutConf: prepared, onCloseFlyout: onCloseFlyout, locale: locale });
};
exports.FlyoutRegionContainer = FlyoutRegionContainer;


/***/ }),

/***/ "./src/containers/hooks-generic.ts":
/*!*****************************************!*\
  !*** ./src/containers/hooks-generic.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useActiveMapSubjectLayer = void 0;
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
function useActiveMapSubjectLayer() {
    return (0, context_1.useAppState)(function (state) {
        var _a;
        if (state.config.activeMapName) {
            return (_a = state.mapState[state.config.activeMapName].generic) === null || _a === void 0 ? void 0 : _a.subject;
        }
        return undefined;
    });
}
exports.useActiveMapSubjectLayer = useActiveMapSubjectLayer;


/***/ }),

/***/ "./src/containers/hooks-mapguide.ts":
/*!******************************************!*\
  !*** ./src/containers/hooks-mapguide.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useActiveMapState = exports.useActiveMapFiniteScales = exports.useActiveMapSessionId = exports.useActiveMapSelectableLayerNames = exports.useActiveMapActiveSelectedFeature = exports.useActiveMapLayerTransparency = exports.useActiveMapHideLayers = exports.useActiveMapHideGroups = exports.useActiveMapShowLayers = exports.useActiveMapShowGroups = exports.useActiveMapSelectableLayers = exports.useActiveMapExpandedGroups = exports.useActiveMapProjectionUnits = exports.useActiveMapProjection = exports.useActiveMapMetersPerUnit = exports.useActiveMapIsArbitraryCoordSys = void 0;
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var units_1 = __webpack_require__(/*! ../utils/units */ "./src/utils/units.tsx");
/**
 * @since 0.14.3
 */
function useActiveMapIsArbitraryCoordSys() {
    return (0, context_1.useAppState)(function (state) {
        var _a, _b, _c;
        var arbCs = false;
        if (state.config.activeMapName) {
            var ms = state.mapState[state.config.activeMapName];
            if ((_a = ms.mapguide) === null || _a === void 0 ? void 0 : _a.runtimeMap) {
                arbCs = (0, units_1.tryParseArbitraryCs)(ms.mapguide.runtimeMap.CoordinateSystem.MentorCode) != null;
            }
            else if ((_b = ms.generic) === null || _b === void 0 ? void 0 : _b.subject) {
                arbCs = (0, units_1.tryParseArbitraryCs)((_c = ms.generic.subject.meta) === null || _c === void 0 ? void 0 : _c.projection) != null;
            }
        }
        return arbCs;
    });
}
exports.useActiveMapIsArbitraryCoordSys = useActiveMapIsArbitraryCoordSys;
function useActiveMapMetersPerUnit() {
    return (0, context_1.useAppState)(function (state) {
        var _a;
        var mpu = 1.0;
        if (state.config.activeMapName) {
            var ms = state.mapState[state.config.activeMapName];
            if ((_a = ms.mapguide) === null || _a === void 0 ? void 0 : _a.runtimeMap) {
                mpu = ms.mapguide.runtimeMap.CoordinateSystem.MetersPerUnit;
            }
        }
        return mpu;
    });
}
exports.useActiveMapMetersPerUnit = useActiveMapMetersPerUnit;
function useActiveMapProjection() {
    return (0, context_1.useAppState)(function (state) {
        var _a, _b, _c;
        var proj;
        if (state.config.activeMapName) {
            var map = (_a = state.mapState[state.config.activeMapName].mapguide) === null || _a === void 0 ? void 0 : _a.runtimeMap;
            var subject = (_b = state.mapState[state.config.activeMapName].generic) === null || _b === void 0 ? void 0 : _b.subject;
            if (map) {
                proj = "EPSG:" + map.CoordinateSystem.EpsgCode;
            }
            else if (subject) {
                proj = (_c = subject.meta) === null || _c === void 0 ? void 0 : _c.projection;
            }
        }
        return proj;
    });
}
exports.useActiveMapProjection = useActiveMapProjection;
/**
 * @since 0.14.3
 */
function useActiveMapProjectionUnits() {
    return (0, context_1.useAppState)(function (state) {
        var _a, _b, _c, _d, _e;
        var arbUnits;
        if (state.config.activeMapName) {
            var map = (_a = state.mapState[state.config.activeMapName].mapguide) === null || _a === void 0 ? void 0 : _a.runtimeMap;
            var subject = (_b = state.mapState[state.config.activeMapName].generic) === null || _b === void 0 ? void 0 : _b.subject;
            if (map) {
                arbUnits = (_c = (0, units_1.tryParseArbitraryCs)(map.CoordinateSystem.MentorCode)) === null || _c === void 0 ? void 0 : _c.units;
            }
            else if (subject) {
                arbUnits = (_e = (0, units_1.tryParseArbitraryCs)((_d = subject.meta) === null || _d === void 0 ? void 0 : _d.projection)) === null || _e === void 0 ? void 0 : _e.units;
            }
        }
        return arbUnits;
    });
}
exports.useActiveMapProjectionUnits = useActiveMapProjectionUnits;
function useActiveMapExpandedGroups() {
    return (0, context_1.useAppState)(function (state) { var _a, _b; return (_b = (_a = (0, hooks_1.getActiveMapBranch)(state)) === null || _a === void 0 ? void 0 : _a.mapguide) === null || _b === void 0 ? void 0 : _b.expandedGroups; });
}
exports.useActiveMapExpandedGroups = useActiveMapExpandedGroups;
function useActiveMapSelectableLayers() {
    return (0, context_1.useAppState)(function (state) { var _a, _b; return (_b = (_a = (0, hooks_1.getActiveMapBranch)(state)) === null || _a === void 0 ? void 0 : _a.mapguide) === null || _b === void 0 ? void 0 : _b.selectableLayers; });
}
exports.useActiveMapSelectableLayers = useActiveMapSelectableLayers;
function useActiveMapShowGroups() {
    return (0, context_1.useAppState)(function (state) { var _a, _b; return (_b = (_a = (0, hooks_1.getActiveMapBranch)(state)) === null || _a === void 0 ? void 0 : _a.mapguide) === null || _b === void 0 ? void 0 : _b.showGroups; });
}
exports.useActiveMapShowGroups = useActiveMapShowGroups;
function useActiveMapShowLayers() {
    return (0, context_1.useAppState)(function (state) { var _a, _b; return (_b = (_a = (0, hooks_1.getActiveMapBranch)(state)) === null || _a === void 0 ? void 0 : _a.mapguide) === null || _b === void 0 ? void 0 : _b.showLayers; });
}
exports.useActiveMapShowLayers = useActiveMapShowLayers;
function useActiveMapHideGroups() {
    return (0, context_1.useAppState)(function (state) { var _a, _b; return (_b = (_a = (0, hooks_1.getActiveMapBranch)(state)) === null || _a === void 0 ? void 0 : _a.mapguide) === null || _b === void 0 ? void 0 : _b.hideGroups; });
}
exports.useActiveMapHideGroups = useActiveMapHideGroups;
function useActiveMapHideLayers() {
    return (0, context_1.useAppState)(function (state) { var _a, _b; return (_b = (_a = (0, hooks_1.getActiveMapBranch)(state)) === null || _a === void 0 ? void 0 : _a.mapguide) === null || _b === void 0 ? void 0 : _b.hideLayers; });
}
exports.useActiveMapHideLayers = useActiveMapHideLayers;
function useActiveMapLayerTransparency() {
    return (0, context_1.useAppState)(function (state) { var _a, _b; return (_b = (_a = (0, hooks_1.getActiveMapBranch)(state)) === null || _a === void 0 ? void 0 : _a.mapguide) === null || _b === void 0 ? void 0 : _b.layerTransparency; });
}
exports.useActiveMapLayerTransparency = useActiveMapLayerTransparency;
function useActiveMapActiveSelectedFeature() {
    return (0, context_1.useAppState)(function (state) { var _a, _b; return (_b = (_a = (0, hooks_1.getActiveMapBranch)(state)) === null || _a === void 0 ? void 0 : _a.mapguide) === null || _b === void 0 ? void 0 : _b.activeSelectedFeature; });
}
exports.useActiveMapActiveSelectedFeature = useActiveMapActiveSelectedFeature;
function useActiveMapSelectableLayerNames() {
    var _a;
    var map = useActiveMapState();
    var selectableLayers = useActiveMapSelectableLayers();
    if (map) {
        var selectableLayerNames = ((_a = map.Layer) !== null && _a !== void 0 ? _a : [])
            .filter(function (layer) { return layer.Selectable && selectableLayers[layer.ObjectId] !== false; })
            .map(function (layer) { return layer.Name; });
        return selectableLayerNames;
    }
    return [];
}
exports.useActiveMapSelectableLayerNames = useActiveMapSelectableLayerNames;
function useActiveMapSessionId() {
    return (0, context_1.useAppState)(function (state) { var _a; return (_a = (0, common_1.getRuntimeMap)(state)) === null || _a === void 0 ? void 0 : _a.SessionId; });
}
exports.useActiveMapSessionId = useActiveMapSessionId;
function useActiveMapFiniteScales() {
    return (0, context_1.useAppState)(function (state) {
        var map = (0, common_1.getRuntimeMap)(state);
        return map != null ? map.FiniteDisplayScale : undefined;
    });
}
exports.useActiveMapFiniteScales = useActiveMapFiniteScales;
function useActiveMapState() {
    return (0, context_1.useAppState)(function (state) { return (0, common_1.getRuntimeMap)(state); });
}
exports.useActiveMapState = useActiveMapState;


/***/ }),

/***/ "./src/containers/hooks.ts":
/*!*********************************!*\
  !*** ./src/containers/hooks.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useTemplateSelectionVisible = exports.useTemplateTaskPaneVisible = exports.useTemplateLegendVisible = exports.useConfiguredCapabilities = exports.useConfiguredUndoLastPointKey = exports.useConfiguredCancelDigitizationKey = exports.useConfiguredLoadIndicatorColor = exports.useConfiguredLoadIndicatorPositioning = exports.useConfiguredManualFeatureTooltips = exports.useViewerSelectCanDragPan = exports.useViewerFeatureTooltipsEnabled = exports.useViewerPointSelectionBuffer = exports.useViewerActiveFeatureSelectionColor = exports.useViewerSelectionColor = exports.useViewerSelectionImageFormat = exports.useViewerImageFormat = exports.useViewerIsStateless = exports.useIsContextMenuOpen = exports.useConfiguredAgentKind = exports.useConfiguredAgentUri = exports.useConfiguredCoordinateFormat = exports.useConfiguredCoordinateDecimals = exports.useConfiguredCoordinateProjection = exports.useViewerViewRotationEnabled = exports.useViewerActiveTool = exports.useViewerViewRotation = exports.useViewerBusyCount = exports.useAvailableMaps = exports.useActiveMapInitialView = exports.useActiveMapClientSelectionSet = exports.useCustomAppSettings = exports.useActiveMapSelectionSet = exports.useActiveMapBranch = exports.getActiveMapBranch = exports.useInitErrorOptions = exports.useInitErrorStack = exports.useInitError = exports.useInitWarnings = exports.useViewerFlyouts = exports.useCurrentMouseCoordinates = exports.useActiveMapExternalBaseLayers = exports.useViewerSizeUnits = exports.useActiveMapHeight = exports.useActiveMapWidth = exports.useActiveMapView = exports.useViewerLocale = exports.useActiveMapLayers = exports.useActiveMapInitialExternalLayers = exports.useActiveMapName = exports.usePrevious = void 0;
exports.useReducedToolbarAppState = exports.useLastDispatchedAction = exports.useTaskPaneNavigationStack = exports.useTaskPaneLastUrlPushed = exports.useTaskPaneNavigationIndex = exports.useTaskPaneInitialUrl = exports.useTemplateInitialTaskPaneWidth = exports.useTemplateInitialInfoPaneWidth = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
var react_1 = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var array_1 = __webpack_require__(/*! ../utils/array */ "./src/utils/array.ts");
var command_1 = __webpack_require__(/*! ../api/registry/command */ "./src/api/registry/command.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
// From: https://usehooks.com/usePrevious/
function usePrevious(value) {
    // The ref object is a generic container whose current property is mutable ...
    // ... and can hold any value, similar to an instance property on a class
    var ref = (0, react_1.useRef)();
    // Store current value in ref
    (0, react_1.useEffect)(function () {
        ref.current = value;
    }, [value]); // Only re-run if value changes
    // Return previous value (happens before update in useEffect above)
    return ref.current;
}
exports.usePrevious = usePrevious;
function useActiveMapName() {
    return (0, context_1.useAppState)(function (state) { return state.config.activeMapName; });
}
exports.useActiveMapName = useActiveMapName;
function useActiveMapInitialExternalLayers() {
    return (0, context_1.useAppState)(function (state) {
        if (state.config.activeMapName) {
            return state.mapState[state.config.activeMapName].initialExternalLayers;
        }
        return [];
    });
}
exports.useActiveMapInitialExternalLayers = useActiveMapInitialExternalLayers;
function sameHeatmapSettings(left, right) {
    if (left && right) {
        return left.blur == right.blur
            && left.radius == right.radius;
    }
    return false;
}
function useActiveMapLayers() {
    return (0, context_1.useAppState)(function (state) {
        if (state.config.activeMapName) {
            return state.mapState[state.config.activeMapName].layers;
        }
        return undefined;
    }, function (left, right) { return !(0, array_1.areArraysDifferent)(left, right, function (l, r) {
        return l.name == r.name
            && l.opacity == r.opacity
            && l.visible == r.visible
            && l.vectorStyle == r.vectorStyle
            && l.cluster == r.cluster
            && sameHeatmapSettings(l.heatmap, r.heatmap);
    }); });
}
exports.useActiveMapLayers = useActiveMapLayers;
function useViewerLocale() {
    return (0, context_1.useAppState)(function (state) { return state.config.locale; });
}
exports.useViewerLocale = useViewerLocale;
function useActiveMapView() {
    return (0, context_1.useAppState)(function (state) {
        return (0, common_1.getCurrentView)(state);
    });
}
exports.useActiveMapView = useActiveMapView;
function useActiveMapWidth() {
    return (0, context_1.useAppState)(function (state) { var _a, _b; return (_b = (_a = state.viewer) === null || _a === void 0 ? void 0 : _a.size) === null || _b === void 0 ? void 0 : _b[0]; });
}
exports.useActiveMapWidth = useActiveMapWidth;
function useActiveMapHeight() {
    return (0, context_1.useAppState)(function (state) { var _a, _b; return (_b = (_a = state.viewer) === null || _a === void 0 ? void 0 : _a.size) === null || _b === void 0 ? void 0 : _b[1]; });
}
exports.useActiveMapHeight = useActiveMapHeight;
function useViewerSizeUnits() {
    return (0, context_1.useAppState)(function (state) { return state.config.viewSizeUnits; });
}
exports.useViewerSizeUnits = useViewerSizeUnits;
/**
 * Gets the current set of available external base layers
 *
 * @param includeNonVisual Include "non-visual" base layers like UTFGrid tile sets
 * @returns The current set of available external base layers
 * @since 0.14 New required includeNonVisual parameter
 */
function useActiveMapExternalBaseLayers(includeNonVisual) {
    return (0, context_1.useAppState)(function (state) { return (0, common_1.getExternalBaseLayers)(state, includeNonVisual); });
}
exports.useActiveMapExternalBaseLayers = useActiveMapExternalBaseLayers;
function useCurrentMouseCoordinates() {
    return (0, context_1.useAppState)(function (state) { return state.mouse.coords; });
}
exports.useCurrentMouseCoordinates = useCurrentMouseCoordinates;
function useViewerFlyouts() {
    return (0, context_1.useAppState)(function (state) { return state.toolbar.flyouts; });
}
exports.useViewerFlyouts = useViewerFlyouts;
function useInitWarnings() {
    return (0, context_1.useAppState)(function (state) { return state.initError.warnings; });
}
exports.useInitWarnings = useInitWarnings;
function useInitError() {
    return (0, context_1.useAppState)(function (state) { return state.initError.error; });
}
exports.useInitError = useInitError;
function useInitErrorStack() {
    return (0, context_1.useAppState)(function (state) { return state.initError.includeStack; });
}
exports.useInitErrorStack = useInitErrorStack;
function useInitErrorOptions() {
    return (0, context_1.useAppState)(function (state) { return state.initError.options; });
}
exports.useInitErrorOptions = useInitErrorOptions;
function getActiveMapBranch(state) {
    if (state.config.activeMapName) {
        return state.mapState[state.config.activeMapName];
    }
    return undefined;
}
exports.getActiveMapBranch = getActiveMapBranch;
function useActiveMapBranch() {
    return (0, context_1.useAppState)(function (state) { return getActiveMapBranch(state); });
}
exports.useActiveMapBranch = useActiveMapBranch;
function useActiveMapSelectionSet() {
    return (0, context_1.useAppState)(function (state) { var _a; return (_a = (0, common_1.getSelectionSet)(state)) !== null && _a !== void 0 ? _a : null; });
}
exports.useActiveMapSelectionSet = useActiveMapSelectionSet;
/**
 * Gets custom app settings
 *
 * @returns
 * @since 0.14
 */
function useCustomAppSettings() {
    return (0, context_1.useAppState)(function (state) { return state.config.appSettings; });
}
exports.useCustomAppSettings = useCustomAppSettings;
/**
 * Gets the client-side selection set
 * @since 0.14
 */
function useActiveMapClientSelectionSet() {
    return (0, context_1.useAppState)(function (state) { var _a; return (_a = getActiveMapBranch(state)) === null || _a === void 0 ? void 0 : _a.clientSelection; });
}
exports.useActiveMapClientSelectionSet = useActiveMapClientSelectionSet;
function useActiveMapInitialView() {
    return (0, context_1.useAppState)(function (state) { var _a; return (_a = getActiveMapBranch(state)) === null || _a === void 0 ? void 0 : _a.initialView; });
}
exports.useActiveMapInitialView = useActiveMapInitialView;
function useAvailableMaps() {
    return (0, context_1.useAppState)(function (state) { return state.config.availableMaps; });
}
exports.useAvailableMaps = useAvailableMaps;
function useViewerBusyCount() {
    return (0, context_1.useAppState)(function (state) { return state.viewer.busyCount; });
}
exports.useViewerBusyCount = useViewerBusyCount;
function useViewerViewRotation() {
    return (0, context_1.useAppState)(function (state) { return state.config.viewRotation; });
}
exports.useViewerViewRotation = useViewerViewRotation;
function useViewerActiveTool() {
    return (0, context_1.useAppState)(function (state) { return state.viewer.tool; });
}
exports.useViewerActiveTool = useViewerActiveTool;
function useViewerViewRotationEnabled() {
    return (0, context_1.useAppState)(function (state) { return state.config.viewRotationEnabled; });
}
exports.useViewerViewRotationEnabled = useViewerViewRotationEnabled;
function useConfiguredCoordinateProjection() {
    return (0, context_1.useAppState)(function (state) { return state.config.coordinates.projection; });
}
exports.useConfiguredCoordinateProjection = useConfiguredCoordinateProjection;
function useConfiguredCoordinateDecimals() {
    return (0, context_1.useAppState)(function (state) { return state.config.coordinates.decimals; });
}
exports.useConfiguredCoordinateDecimals = useConfiguredCoordinateDecimals;
function useConfiguredCoordinateFormat() {
    return (0, context_1.useAppState)(function (state) { return state.config.coordinates.format; });
}
exports.useConfiguredCoordinateFormat = useConfiguredCoordinateFormat;
function useConfiguredAgentUri() {
    return (0, context_1.useAppState)(function (state) { return state.config.agentUri; });
}
exports.useConfiguredAgentUri = useConfiguredAgentUri;
function useConfiguredAgentKind() {
    return (0, context_1.useAppState)(function (state) { return state.config.agentKind; });
}
exports.useConfiguredAgentKind = useConfiguredAgentKind;
function useIsContextMenuOpen() {
    return (0, context_1.useAppState)(function (state) {
        var _a, _b, _c;
        var isContextMenuOpen = false;
        if (((_c = (_b = (_a = state === null || state === void 0 ? void 0 : state.toolbar) === null || _a === void 0 ? void 0 : _a.flyouts) === null || _b === void 0 ? void 0 : _b[constants_1.WEBLAYOUT_CONTEXTMENU]) === null || _c === void 0 ? void 0 : _c.open) === true) {
            isContextMenuOpen = true;
        }
        return isContextMenuOpen;
    });
}
exports.useIsContextMenuOpen = useIsContextMenuOpen;
/**
 * Gets whether the viewer is in stateless mode
 * @returns true if the viewer is in stateless mode
 * @since 0.14
 */
function useViewerIsStateless() {
    return (0, context_1.useAppState)(function (state) { return state.config.viewer.isStateless; });
}
exports.useViewerIsStateless = useViewerIsStateless;
function useViewerImageFormat() {
    return (0, context_1.useAppState)(function (state) { return state.config.viewer.imageFormat; });
}
exports.useViewerImageFormat = useViewerImageFormat;
function useViewerSelectionImageFormat() {
    return (0, context_1.useAppState)(function (state) { return state.config.viewer.selectionImageFormat; });
}
exports.useViewerSelectionImageFormat = useViewerSelectionImageFormat;
function useViewerSelectionColor() {
    return (0, context_1.useAppState)(function (state) { return state.config.viewer.selectionColor; });
}
exports.useViewerSelectionColor = useViewerSelectionColor;
function useViewerActiveFeatureSelectionColor() {
    return (0, context_1.useAppState)(function (state) { return state.config.viewer.activeSelectedFeatureColor; });
}
exports.useViewerActiveFeatureSelectionColor = useViewerActiveFeatureSelectionColor;
function useViewerPointSelectionBuffer() {
    return (0, context_1.useAppState)(function (state) { return state.config.viewer.pointSelectionBuffer; });
}
exports.useViewerPointSelectionBuffer = useViewerPointSelectionBuffer;
function useViewerFeatureTooltipsEnabled() {
    return (0, context_1.useAppState)(function (state) { return state.viewer.featureTooltipsEnabled; });
}
exports.useViewerFeatureTooltipsEnabled = useViewerFeatureTooltipsEnabled;
/**
 * @since 0.14.2
 */
function useViewerSelectCanDragPan() {
    return (0, context_1.useAppState)(function (state) { return state.config.selectCanDragPan; });
}
exports.useViewerSelectCanDragPan = useViewerSelectCanDragPan;
function useConfiguredManualFeatureTooltips() {
    return (0, context_1.useAppState)(function (state) { return state.config.manualFeatureTooltips; });
}
exports.useConfiguredManualFeatureTooltips = useConfiguredManualFeatureTooltips;
function useConfiguredLoadIndicatorPositioning() {
    return (0, context_1.useAppState)(function (state) { return state.config.viewer.loadIndicatorPositioning; });
}
exports.useConfiguredLoadIndicatorPositioning = useConfiguredLoadIndicatorPositioning;
function useConfiguredLoadIndicatorColor() {
    return (0, context_1.useAppState)(function (state) { return state.config.viewer.loadIndicatorColor; });
}
exports.useConfiguredLoadIndicatorColor = useConfiguredLoadIndicatorColor;
function useConfiguredCancelDigitizationKey() {
    return (0, context_1.useAppState)(function (state) { return state.config.cancelDigitizationKey; });
}
exports.useConfiguredCancelDigitizationKey = useConfiguredCancelDigitizationKey;
function useConfiguredUndoLastPointKey() {
    return (0, context_1.useAppState)(function (state) { return state.config.undoLastPointKey; });
}
exports.useConfiguredUndoLastPointKey = useConfiguredUndoLastPointKey;
function useConfiguredCapabilities() {
    return (0, context_1.useAppState)(function (state) { return state.config.capabilities; });
}
exports.useConfiguredCapabilities = useConfiguredCapabilities;
function useTemplateLegendVisible() {
    return (0, context_1.useAppState)(function (state) { return state.template.legendVisible; });
}
exports.useTemplateLegendVisible = useTemplateLegendVisible;
function useTemplateTaskPaneVisible() {
    return (0, context_1.useAppState)(function (state) { return state.template.taskPaneVisible; });
}
exports.useTemplateTaskPaneVisible = useTemplateTaskPaneVisible;
function useTemplateSelectionVisible() {
    return (0, context_1.useAppState)(function (state) { return state.template.selectionPanelVisible; });
}
exports.useTemplateSelectionVisible = useTemplateSelectionVisible;
function useTemplateInitialInfoPaneWidth() {
    return (0, context_1.useAppState)(function (state) { return state.template.initialInfoPaneWidth; });
}
exports.useTemplateInitialInfoPaneWidth = useTemplateInitialInfoPaneWidth;
function useTemplateInitialTaskPaneWidth() {
    return (0, context_1.useAppState)(function (state) { return state.template.initialTaskPaneWidth; });
}
exports.useTemplateInitialTaskPaneWidth = useTemplateInitialTaskPaneWidth;
function useTaskPaneInitialUrl() {
    return (0, context_1.useAppState)(function (state) { return state.taskpane.initialUrl; });
}
exports.useTaskPaneInitialUrl = useTaskPaneInitialUrl;
function useTaskPaneNavigationIndex() {
    return (0, context_1.useAppState)(function (state) { return state.taskpane.navIndex; });
}
exports.useTaskPaneNavigationIndex = useTaskPaneNavigationIndex;
function useTaskPaneLastUrlPushed() {
    return (0, context_1.useAppState)(function (state) { return state.taskpane.lastUrlPushed; });
}
exports.useTaskPaneLastUrlPushed = useTaskPaneLastUrlPushed;
function useTaskPaneNavigationStack() {
    return (0, context_1.useAppState)(function (state) { return state.taskpane.navigation; });
}
exports.useTaskPaneNavigationStack = useTaskPaneNavigationStack;
function useLastDispatchedAction() {
    return (0, context_1.useAppState)(function (state) { return state.lastaction; });
}
exports.useLastDispatchedAction = useLastDispatchedAction;
function useReducedToolbarAppState() {
    var selection = useActiveMapSelectionSet();
    var clientSelection = useActiveMapClientSelectionSet();
    var tbState = (0, context_1.useAppState)(function (state) { return (0, command_1.reduceAppToToolbarState)(state); }, function (left, right) {
        return (left === null || left === void 0 ? void 0 : left.busyWorkerCount) == (right === null || right === void 0 ? void 0 : right.busyWorkerCount)
            && (left === null || left === void 0 ? void 0 : left.hasNextView) == (right === null || right === void 0 ? void 0 : right.hasNextView)
            && (left === null || left === void 0 ? void 0 : left.hasPreviousView) == (right === null || right === void 0 ? void 0 : right.hasPreviousView)
            && (left === null || left === void 0 ? void 0 : left.featureTooltipsEnabled) == (right === null || right === void 0 ? void 0 : right.featureTooltipsEnabled)
            && (left === null || left === void 0 ? void 0 : left.activeTool) == (right === null || right === void 0 ? void 0 : right.activeTool);
    });
    //Overwrite whatever selection flags from the reduceAppToToolbarState result
    var hasClientSelection = false;
    var hasSelection = false;
    if (selection) {
        if (selection.FeatureSet && selection.FeatureSet.Layer.length > 0) {
            hasSelection = true;
        }
        if (selection.SelectedFeatures && selection.SelectedFeatures.SelectedLayer.length > 0) {
            hasSelection = true;
        }
    }
    if (clientSelection && clientSelection.layers.length > 0) {
        hasClientSelection = true;
    }
    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, tbState), { hasClientSelection: hasClientSelection, hasSelection: hasSelection });
}
exports.useReducedToolbarAppState = useReducedToolbarAppState;


/***/ }),

/***/ "./src/containers/init-warning-display.tsx":
/*!*************************************************!*\
  !*** ./src/containers/init-warning-display.tsx ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InitWarningDisplay = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var init_1 = __webpack_require__(/*! ../actions/init */ "./src/actions/init.ts");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var InitWarningDisplay = function () {
    var dispatch = (0, context_1.useReduxDispatch)();
    var acknowledge = function () { return dispatch((0, init_1.acknowledgeInitWarnings)()); };
    var warnings = (0, hooks_1.useInitWarnings)();
    var locale = (0, hooks_1.useViewerLocale)();
    if (warnings && warnings.length && acknowledge) {
        return React.createElement(core_1.Dialog, { icon: "warning-sign", isOpen: true, usePortal: false, onClose: acknowledge, title: (0, i18n_1.tr)("WARNING", locale) },
            React.createElement("div", { className: "bp3-dialog-body" },
                React.createElement("p", null, (0, i18n_1.tr)("INIT_WARNINGS_FOUND", locale)),
                React.createElement("ul", null, warnings.map(function (w) { return React.createElement("li", { key: w }, w); }))),
            React.createElement("div", { className: "bp3-dialog-footer" },
                React.createElement("div", { className: "bp3-dialog-footer-actions" },
                    React.createElement(core_1.Button, { intent: core_1.Intent.PRIMARY, onClick: acknowledge, text: (0, i18n_1.tr)("OK", locale) }))));
    }
    else {
        return React.createElement("noscript", null);
    }
};
exports.InitWarningDisplay = InitWarningDisplay;


/***/ }),

/***/ "./src/containers/legend.tsx":
/*!***********************************!*\
  !*** ./src/containers/legend.tsx ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LegendContainer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var legend_1 = __webpack_require__(/*! ../components/legend */ "./src/components/legend.tsx");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var legend_2 = __webpack_require__(/*! ../actions/legend */ "./src/actions/legend.ts");
var hooks_mapguide_1 = __webpack_require__(/*! ./hooks-mapguide */ "./src/containers/hooks-mapguide.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var LegendContainer = function (props) {
    var maxHeight = props.maxHeight, inlineBaseLayerSwitcher = props.inlineBaseLayerSwitcher;
    var dispatch = (0, context_1.useReduxDispatch)();
    var activeMapName = (0, hooks_1.useActiveMapName)();
    var locale = (0, hooks_1.useViewerLocale)();
    var map = (0, hooks_mapguide_1.useActiveMapState)();
    var view = (0, hooks_1.useActiveMapView)();
    var showGroups = (0, hooks_mapguide_1.useActiveMapShowGroups)();
    var showLayers = (0, hooks_mapguide_1.useActiveMapShowLayers)();
    var hideGroups = (0, hooks_mapguide_1.useActiveMapHideGroups)();
    var hideLayers = (0, hooks_mapguide_1.useActiveMapHideLayers)();
    var expandedGroups = (0, hooks_mapguide_1.useActiveMapExpandedGroups)();
    var selectableLayers = (0, hooks_mapguide_1.useActiveMapSelectableLayers)();
    var externalBaseLayers = (0, hooks_1.useActiveMapExternalBaseLayers)(false);
    var stateless = (0, hooks_1.useViewerIsStateless)();
    var setBaseLayerAction = function (mapName, layerName) { return dispatch((0, map_1.setBaseLayer)(mapName, layerName)); };
    var setGroupVisibilityAction = function (mapName, options) { return dispatch((0, legend_2.setGroupVisibility)(mapName, options)); };
    var setLayerVisibilityAction = function (mapName, options) { return dispatch((0, legend_2.setLayerVisibility)(mapName, options)); };
    var setLayerSelectableAction = function (mapName, options) { return dispatch((0, legend_2.setLayerSelectable)(mapName, options)); };
    var setGroupExpandedAction = function (mapName, options) { return dispatch((0, legend_2.setGroupExpanded)(mapName, options)); };
    var layers = (0, hooks_1.useActiveMapLayers)();
    var onLayerSelectabilityChanged = function (id, selectable) {
        if (activeMapName) {
            setLayerSelectableAction === null || setLayerSelectableAction === void 0 ? void 0 : setLayerSelectableAction(activeMapName, { id: id, value: selectable });
        }
    };
    var onGroupExpansionChanged = function (id, expanded) {
        if (setGroupExpandedAction && activeMapName) {
            setGroupExpandedAction(activeMapName, { id: id, value: expanded });
        }
    };
    var onGroupVisibilityChanged = function (groupId, visible) {
        if (setGroupVisibilityAction && activeMapName) {
            setGroupVisibilityAction(activeMapName, { id: groupId, value: visible });
        }
    };
    var onLayerVisibilityChanged = function (layerId, visible) {
        if (setLayerVisibilityAction && activeMapName) {
            setLayerVisibilityAction(activeMapName, { id: layerId, value: visible });
        }
    };
    var onBaseLayerChanged = function (layerName) {
        if (setBaseLayerAction && activeMapName) {
            setBaseLayerAction(activeMapName, layerName);
        }
    };
    if ((map || layers) && view) {
        var scale = view.scale;
        if (scale || layers) {
            return React.createElement(legend_1.Legend, { map: map, activeMapName: activeMapName, stateless: stateless, maxHeight: maxHeight, currentScale: scale, externalLayers: layers, showLayers: showLayers, showGroups: showGroups, hideLayers: hideLayers, hideGroups: hideGroups, locale: locale, inlineBaseLayerSwitcher: !!inlineBaseLayerSwitcher, externalBaseLayers: externalBaseLayers, onBaseLayerChanged: onBaseLayerChanged, overrideSelectableLayers: selectableLayers, overrideExpandedItems: expandedGroups, onLayerSelectabilityChanged: onLayerSelectabilityChanged, onGroupExpansionChanged: onGroupExpansionChanged, onGroupVisibilityChanged: onGroupVisibilityChanged, onLayerVisibilityChanged: onLayerVisibilityChanged });
        }
        else {
            return React.createElement("div", null, (0, i18n_1.tr)("LOADING_MSG", locale));
        }
    }
    else {
        return React.createElement("div", null, (0, i18n_1.tr)("LOADING_MSG", locale));
    }
};
exports.LegendContainer = LegendContainer;


/***/ }),

/***/ "./src/containers/map-capturer-context.ts":
/*!************************************************!*\
  !*** ./src/containers/map-capturer-context.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapCapturerContext = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var number_1 = __webpack_require__(/*! ../utils/number */ "./src/utils/number.ts");
var olExtent = (0, tslib_1.__importStar)(__webpack_require__(/*! ol/extent */ "./node_modules/ol/extent.js"));
var Feature_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/Feature */ "./node_modules/ol/Feature.js"));
var Collection_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/Collection */ "./node_modules/ol/Collection.js"));
var Polygon_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/Polygon */ "./node_modules/ol/geom/Polygon.js"));
var Vector_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/source/Vector */ "./node_modules/ol/source/Vector.js"));
var Vector_2 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/layer/Vector */ "./node_modules/ol/layer/Vector.js"));
var Translate_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/interaction/Translate */ "./node_modules/ol/interaction/Translate.js"));
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
var MapCapturerContext = /** @class */ (function () {
    function MapCapturerContext(viewer, mapName, rotation) {
        if (rotation === void 0) { rotation = 0; }
        this.viewer = viewer;
        this.mapName = mapName;
        this.rotation = rotation;
        this.features = new Collection_1.default();
        this.mapCapturerSource = new Vector_1.default({
            features: this.features
        });
        this.mapCapturerLayer = new Vector_2.default({
            source: this.mapCapturerSource
        });
        this.intTranslate = new Translate_1.default({
            features: this.features
        });
        this.intTranslate.on("translateend", this.onTranslateEnd.bind(this));
        this.layerName = mapName + "_MapCapturer";
    }
    MapCapturerContext.prototype.getRing = function (origin, paperSize, scaleDenominator) {
        var ring = [];
        var factor = scaleDenominator / (this.viewer.getMetersPerUnit() * 1000 * 2);
        ring.push([origin.x - paperSize.w * factor, origin.y - paperSize.h * factor]);
        ring.push([origin.x + paperSize.w * factor, origin.y - paperSize.h * factor]);
        ring.push([origin.x + paperSize.w * factor, origin.y + paperSize.h * factor]);
        ring.push([origin.x - paperSize.w * factor, origin.y + paperSize.h * factor]);
        return [ring];
    };
    MapCapturerContext.prototype.onTranslateEnd = function () {
        if (this.features.getLength() == 1 && this.activeCallback) {
            var box = this.features.item(0);
            var poly = box.getGeometry();
            var coords = poly.getCoordinates()[0];
            var boxCoords = coords.map(function (c) { return c[0] + "," + c[1]; }).join(",");
            //Process normalized one
            var npoly = poly.clone();
            var ncenter = olExtent.getCenter(npoly.getExtent());
            npoly.rotate((0, number_1.deg2rad)(this.rotation), ncenter);
            var ncoords = npoly.getCoordinates()[0];
            var nBoxCoords = ncoords.map(function (c) { return c[0] + "," + c[1]; }).join(",");
            this.activeCallback.updateBoxCoords(boxCoords, nBoxCoords);
        }
    };
    MapCapturerContext.prototype.updateBox = function (paperSize, scaleDenominator, rotation) {
        if (this.activeCallback) {
            this.rotation = rotation;
            var poly = void 0;
            if (this.features.getLength() == 0) {
                poly = this.createCaptureBox(paperSize, scaleDenominator, this.rotation);
            }
            else {
                var box = this.features.item(0);
                poly = box.getGeometry();
                var center = olExtent.getCenter(poly.getExtent());
                var origin_1 = {
                    x: center[0],
                    y: center[1]
                };
                var ring = this.getRing(origin_1, paperSize, scaleDenominator);
                poly.setCoordinates(ring);
                poly.rotate(-(0, number_1.deg2rad)(this.rotation), center);
            }
            var coords = poly.getCoordinates()[0];
            var boxCoords = coords.map(function (c) { return c[0] + "," + c[1]; }).join(",");
            //Process normalized one
            var npoly = poly.clone();
            var ncenter = olExtent.getCenter(npoly.getExtent());
            npoly.rotate((0, number_1.deg2rad)(this.rotation), ncenter);
            var ncoords = npoly.getCoordinates()[0];
            var nBoxCoords = ncoords.map(function (c) { return c[0] + "," + c[1]; }).join(",");
            this.activeCallback.updateBoxCoords(boxCoords, nBoxCoords);
        }
    };
    MapCapturerContext.prototype.createCaptureBox = function (paperSize, scaleDenominator, rotation) {
        var origin = this.viewer.getCurrentView();
        var ring = this.getRing(origin, paperSize, scaleDenominator);
        var poly = new Polygon_1.default(ring);
        poly.rotate(-(0, number_1.deg2rad)(rotation), [origin.x, origin.y]);
        var box = new Feature_1.default(poly);
        this.features.clear();
        this.features.push(box);
        return poly;
    };
    MapCapturerContext.prototype.getMapName = function () { return this.mapName; };
    MapCapturerContext.prototype.activate = function (callback, paperSize, scaleDenominator, rotation) {
        this.activeCallback = callback;
        (0, logger_1.debug)("Activating map capturer context for " + this.mapName);
        this.viewer.getLayerManager().addLayer(this.layerName, this.mapCapturerLayer, true);
        this.updateBox(paperSize, scaleDenominator, rotation);
        this.viewer.addInteraction(this.intTranslate);
    };
    MapCapturerContext.prototype.deactivate = function () {
        this.activeCallback = undefined;
        (0, logger_1.debug)("De-activating map capturer context for " + this.mapName);
        this.features.clear();
        this.viewer.getLayerManager().removeLayer(this.layerName);
        this.viewer.removeInteraction(this.intTranslate);
    };
    return MapCapturerContext;
}());
exports.MapCapturerContext = MapCapturerContext;


/***/ }),

/***/ "./src/containers/map-menu.tsx":
/*!*************************************!*\
  !*** ./src/containers/map-menu.tsx ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapMenuContainer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var map_menu_1 = __webpack_require__(/*! ../components/map-menu */ "./src/components/map-menu.tsx");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var MapMenuContainer = function () {
    var dispatch = (0, context_1.useReduxDispatch)();
    var locale = (0, hooks_1.useViewerLocale)();
    var activeMapName = (0, hooks_1.useActiveMapName)();
    var availableMaps = (0, hooks_1.useAvailableMaps)();
    var setActiveMapAction = function (mapName) { return dispatch((0, map_1.setActiveMap)(mapName)); };
    var onActiveMapChanged = function (mapName) { return setActiveMapAction(mapName); };
    if (locale && activeMapName && availableMaps) {
        //TODO: Should use MapGroup id has label. For now, use map name for both
        var entries = availableMaps.map(function (m) {
            return { label: m.name, mapName: m.value };
        });
        return React.createElement(map_menu_1.MapMenu, { onActiveMapChanged: onActiveMapChanged, selectedMap: activeMapName, maps: entries, locale: locale });
    }
    else {
        return React.createElement("noscript", null);
    }
};
exports.MapMenuContainer = MapMenuContainer;


/***/ }),

/***/ "./src/containers/measure-context.ts":
/*!*******************************************!*\
  !*** ./src/containers/measure-context.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MeasureContext = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var number_1 = __webpack_require__(/*! ../utils/number */ "./src/utils/number.ts");
var olObservable = (0, tslib_1.__importStar)(__webpack_require__(/*! ol/Observable */ "./node_modules/ol/Observable.js"));
var olSphere = (0, tslib_1.__importStar)(__webpack_require__(/*! ol/sphere */ "./node_modules/ol/sphere.js"));
var LineString_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/LineString */ "./node_modules/ol/geom/LineString.js"));
var Polygon_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/Polygon */ "./node_modules/ol/geom/Polygon.js"));
var OverlayPositioning_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/OverlayPositioning */ "./node_modules/ol/OverlayPositioning.js"));
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
var proj_1 = __webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js");
var LAYER_NAME = "measure-layer";
function isArbitraryProjection(proj) {
    if (proj instanceof proj_1.Projection) {
        return /XY-[A-Z]+/.test(proj.getCode());
    }
    return false;
}
/**
 * @hidden
 */
var MeasureContext = /** @class */ (function () {
    function MeasureContext(viewer, mapName, parent) {
        var _this = this;
        this.onDrawStart = function (evt) {
            // set sketch
            _this.sketch = evt.feature;
            /** @type {ol.Coordinate|undefined} */
            var tooltipCoord = evt.coordinate;
            if (_this.sketch) {
                var g = _this.sketch.getGeometry();
                if (g) {
                    _this.listener = g.on('change', function (e) {
                        var geom = e.target;
                        var output;
                        if (geom instanceof Polygon_1.default) {
                            var _a = _this.formatArea(geom), o = _a[0], total = _a[1], segments = _a[2];
                            output = o;
                            if (_this.callback) {
                                _this.callback.updateSegments("Area", total, segments);
                            }
                            tooltipCoord = geom.getInteriorPoint().getCoordinates();
                        }
                        else if (geom instanceof LineString_1.default) {
                            var _b = _this.formatLength(geom), o = _b[0], total = _b[1], segments = _b[2];
                            output = o;
                            if (_this.callback) {
                                _this.callback.updateSegments("LineString", total, segments);
                            }
                            tooltipCoord = geom.getLastCoordinate();
                        }
                        else {
                            output = "";
                        }
                        if (_this.measureTooltipElement) {
                            _this.measureTooltipElement.innerHTML = output;
                        }
                        _this.measureTooltip.setPosition(tooltipCoord);
                    });
                }
            }
        };
        this.onDrawEnd = function () {
            if (_this.measureTooltipElement) {
                _this.measureTooltipElement.className = 'tooltip tooltip-static';
            }
            _this.measureTooltip.setOffset([0, -7]);
            // unset sketch
            _this.sketch = null;
            // unset tooltip so that a new one can be created
            _this.measureTooltipElement = null;
            _this.createMeasureTooltip();
            olObservable.unByKey(_this.listener);
        };
        this.onMouseMove = function (evt) {
            if (evt.dragging || !_this.parent) {
                return;
            }
            var locale = _this.parent.getLocale();
            /** @type {string} */
            var helpMsg = (0, i18n_1.tr)("MEASUREMENT_START_DRAWING", locale);
            if (_this.sketch) {
                var geom = (_this.sketch.getGeometry());
                if (geom instanceof Polygon_1.default) {
                    helpMsg = (0, i18n_1.tr)("MEASUREMENT_CONTINUE_POLYGON", locale);
                }
                else if (geom instanceof LineString_1.default) {
                    helpMsg = (0, i18n_1.tr)("MEASUREMENT_CONTINUE_LINE", locale);
                }
            }
            _this.helpTooltipElement.innerHTML = helpMsg;
            _this.helpTooltip.setPosition(evt.coordinate);
            _this.helpTooltipElement.classList.remove('hidden');
        };
        this.measureOverlays = [];
        this.viewer = viewer;
        this.mapName = mapName;
        this.parent = parent;
        this.layerName = LAYER_NAME + "-" + mapName;
        this.olFactory = viewer.getOLFactory();
        this.measureLayer = this.olFactory.createVectorLayer({
            source: this.olFactory.createVectorSource()
        });
        this.measureLayer.set(common_1.LayerProperty.IS_MEASURE, true);
        this.measureLayer.setStyle(this.createMeasureStyle());
    }
    /**
     * Establishes the new parent component for this context. Is called by the
     * new parent component when it mounts and is resuming from previously recorded
     * measurements and is not meant to be called directly
     *
     * @param parent The new parent component
     * @since 0.12
     */
    MeasureContext.prototype.setParent = function (parent) {
        this.parent = parent;
    };
    /**
     * Detaches the parent component from this context. Is called by the parent
     * component when it unmounts and is not meant to be called directly.
     *
     * @since 0.12
     */
    MeasureContext.prototype.detachParent = function () {
        this.parent = undefined;
    };
    /**
     * Format length output.
     * @param {LineString} line The line.
     * @return {string} The formatted length.
     */
    MeasureContext.prototype.formatLength = function (line) {
        var length;
        var segments;
        var locale;
        var isArbitrary = false;
        var sourceProj = this.viewer.getProjection();
        if (this.parent) {
            locale = this.parent.getLocale();
            var coordinates = line.getCoordinates();
            segments = [];
            length = 0;
            if (isArbitraryProjection(sourceProj)) {
                isArbitrary = true;
                // Do euclidean distance
                for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                    var c1 = coordinates[i];
                    var c2 = coordinates[i + 1];
                    var a = c1[0] - c2[0];
                    var b = c1[1] - c2[1];
                    var dist = Math.sqrt(a * a + b * b);
                    length += dist;
                    segments.push({ segment: (i + 1), length: dist });
                }
            }
            else {
                for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                    var c1 = this.olFactory.transformCoordinate(coordinates[i], sourceProj, 'EPSG:4326');
                    var c2 = this.olFactory.transformCoordinate(coordinates[i + 1], sourceProj, 'EPSG:4326');
                    var dist = olSphere.getDistance(c1, c2);
                    length += dist;
                    segments.push({ segment: (i + 1), length: dist });
                }
            }
        }
        else {
            length = NaN;
        }
        var output;
        if (isArbitrary && sourceProj instanceof proj_1.Projection) {
            output = (0, number_1.roundTo)(length, 2) + " " + sourceProj.getUnits();
        }
        else {
            if (length > 100) {
                output = (0, i18n_1.tr)("UNIT_FMT_KM", locale, { value: ((0, number_1.roundTo)(length / 1000, 2)) });
            }
            else {
                output = (0, i18n_1.tr)("UNIT_FMT_M", locale, { value: ((0, number_1.roundTo)(length, 2)) });
            }
        }
        return [output, length, segments];
    };
    /**
     * Format area output.
     * @param {Polygon} polygon The polygon.
     * @return {string} Formatted area.
     */
    MeasureContext.prototype.formatArea = function (polygon) {
        var area;
        var segments;
        var locale;
        var isArbitrary = false;
        var sourceProj = this.viewer.getProjection();
        if (this.parent) {
            locale = this.parent.getLocale();
            segments = [];
            var geom = polygon;
            if (isArbitraryProjection(sourceProj)) {
                isArbitrary = true;
                area = geom.getArea();
                // Do euclidean distance
                var ring = geom.getLinearRing(0);
                var coordinates = ring.getCoordinates();
                for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                    var c1 = coordinates[i];
                    var c2 = coordinates[i + 1];
                    var a = c1[0] - c2[0];
                    var b = c1[1] - c2[1];
                    var dist = Math.sqrt(a * a + b * b);
                    segments.push({ segment: (i + 1), length: dist });
                }
            }
            else {
                area = olSphere.getArea(geom, { projection: sourceProj });
                (0, logger_1.debug)("Polygon area: " + area);
                var ring = geom.getLinearRing(0);
                var coordinates = ring.getCoordinates();
                for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
                    // Unlike getArea(), getDistance() requires that our input coordinates are in
                    // EPSG:4326 first
                    var c1 = this.olFactory.transformCoordinate(coordinates[i], sourceProj, 'EPSG:4326');
                    var c2 = this.olFactory.transformCoordinate(coordinates[i + 1], sourceProj, 'EPSG:4326');
                    var dist = olSphere.getDistance(c1, c2);
                    segments.push({ segment: (i + 1), length: dist });
                }
            }
        }
        else {
            area = NaN;
        }
        var output;
        if (isArbitrary && sourceProj instanceof proj_1.Projection) {
            output = (0, number_1.roundTo)(area, 2) + " " + sourceProj.getUnits() + "<sup>2</sup>";
        }
        else {
            //TODO: The dynamic switch in display of measurement unit based on size of value may prove to be
            //jarring, so we should provide a fixed unit value option in the future that will be used to 
            //display regardless of the size of value
            if (area > 10000) {
                output = (0, i18n_1.tr)("UNIT_FMT_SQKM", locale, {
                    value: "" + ((0, number_1.roundTo)(area / 1000000, 2))
                });
            }
            else {
                output = (0, i18n_1.tr)("UNIT_FMT_SQM", locale, {
                    value: "" + ((0, number_1.roundTo)(area, 2))
                });
            }
        }
        return [output, area, segments];
    };
    MeasureContext.prototype.getMapName = function () { return this.mapName; };
    MeasureContext.prototype.createMeasureStyle = function () {
        return this.olFactory.createStyle({
            fill: this.olFactory.createStyleFill({
                color: 'rgba(255, 255, 255, 0.2)'
            }),
            stroke: this.olFactory.createStyleStroke({
                color: '#ffcc33',
                width: 2
            }),
            image: this.olFactory.createStyleCircle({
                radius: 7,
                fill: this.olFactory.createStyleFill({
                    color: '#ffcc33'
                })
            })
        });
    };
    MeasureContext.prototype.createDrawInteraction = function (type) {
        var source = this.measureLayer.getSource();
        return this.olFactory.createInteractionDraw({
            source: source,
            type: /** @type {ol.geom.GeometryType} */ (type),
            style: this.olFactory.createStyle({
                fill: this.olFactory.createStyleFill({
                    color: 'rgba(255, 255, 255, 0.2)'
                }),
                stroke: this.olFactory.createStyleStroke({
                    color: 'rgba(0, 0, 0, 0.5)',
                    lineDash: [10, 10],
                    width: 2
                }),
                image: this.olFactory.createStyleCircle({
                    radius: 5,
                    stroke: this.olFactory.createStyleStroke({
                        color: 'rgba(0, 0, 0, 0.7)'
                    }),
                    fill: this.olFactory.createStyleFill({
                        color: 'rgba(255, 255, 255, 0.2)'
                    })
                })
            })
        });
    };
    MeasureContext.prototype.removeElement = function (el) {
        if (el && el.parentNode) {
            el.parentNode.removeChild(el);
        }
    };
    /**
     * Creates a new help tooltip
     */
    MeasureContext.prototype.createHelpTooltip = function () {
        this.removeElement(this.helpTooltipElement);
        this.helpTooltipElement = document.createElement('div');
        this.helpTooltipElement.className = 'tooltip hidden';
        this.helpTooltip = this.olFactory.createOverlay({
            element: this.helpTooltipElement,
            offset: [15, 0],
            positioning: OverlayPositioning_1.default.CENTER_LEFT
        });
        this.viewer.addOverlay(this.helpTooltip);
    };
    /**
     * Creates a new measure tooltip
     */
    MeasureContext.prototype.createMeasureTooltip = function () {
        this.removeElement(this.measureTooltipElement);
        this.measureTooltipElement = document.createElement('div');
        this.measureTooltipElement.className = 'tooltip tooltip-measure';
        //Stash the old overlay
        if (this.measureTooltip) {
            this.measureOverlays.push(this.measureTooltip);
        }
        this.measureTooltip = this.olFactory.createOverlay({
            element: this.measureTooltipElement,
            offset: [0, -15],
            positioning: OverlayPositioning_1.default.BOTTOM_CENTER
        });
        this.viewer.addOverlay(this.measureTooltip);
    };
    MeasureContext.prototype.setActiveInteraction = function (type) {
        if (this.draw) {
            this.draw.un("drawstart", this.onDrawStart);
            this.draw.un("drawend", this.onDrawEnd);
            this.viewer.removeInteraction(this.draw);
        }
        this.draw = this.createDrawInteraction(type);
        if (this.draw) {
            this.draw.on("drawstart", this.onDrawStart);
            this.draw.on("drawend", this.onDrawEnd);
            this.viewer.addInteraction(this.draw);
        }
    };
    MeasureContext.prototype.startMeasure = function () {
        if (this.parent) {
            var type = this.parent.getCurrentDrawType();
            if (type) {
                this.createMeasureTooltip();
                this.createHelpTooltip();
                this.setActiveInteraction(type);
                this.viewer.addHandler('pointermove', this.onMouseMove);
            }
        }
    };
    MeasureContext.prototype.endMeasure = function () {
        this.viewer.removeHandler('pointermove', this.onMouseMove);
        if (this.draw) {
            this.draw.un("drawstart", this.onDrawStart);
            this.draw.un("drawend", this.onDrawEnd);
            this.viewer.removeInteraction(this.draw);
            //this.draw = null;
        }
        this.removeElement(this.helpTooltipElement);
    };
    MeasureContext.prototype.clearMeasurements = function () {
        this.measureLayer.getSource().clear();
        for (var _i = 0, _a = this.measureOverlays; _i < _a.length; _i++) {
            var ov = _a[_i];
            this.viewer.removeOverlay(ov);
        }
        this.measureOverlays.length = 0; //Clear
        if (this.callback) {
            this.callback.clearSegments();
        }
    };
    MeasureContext.prototype.handleDrawTypeChange = function () {
        if (this.parent) {
            var type = this.parent.getCurrentDrawType();
            if (type) {
                this.setActiveInteraction(type);
            }
        }
    };
    /**
     * Since 0.12, mapName is required to explicitly state which map you are activating the context for
     *
     * @param {string} mapName
     * @param {IMeasureCallback} callback
     * @memberof MeasureContext
     */
    MeasureContext.prototype.activate = function (mapName, callback) {
        this.callback = callback;
        (0, logger_1.debug)("Activating measure context for " + this.mapName);
        for (var _i = 0, _a = this.measureOverlays; _i < _a.length; _i++) {
            var ov = _a[_i];
            this.viewer.addOverlay(ov);
        }
        this.viewer.getLayerManager(mapName).addLayer(this.layerName, this.measureLayer, true);
    };
    /**
     * Since 0.12, mapName is required to explicitly state which map you are deactivating the context for
     *
     * @param {string} mapName
     * @memberof MeasureContext
     */
    MeasureContext.prototype.deactivate = function (mapName) {
        this.callback = undefined;
        (0, logger_1.debug)("De-activating measure context for " + this.mapName);
        this.endMeasure();
        for (var _i = 0, _a = this.measureOverlays; _i < _a.length; _i++) {
            var ov = _a[_i];
            this.viewer.removeOverlay(ov);
        }
        this.viewer.getLayerManager(mapName).removeLayer(this.layerName);
    };
    return MeasureContext;
}());
exports.MeasureContext = MeasureContext;


/***/ }),

/***/ "./src/containers/measure.tsx":
/*!************************************!*\
  !*** ./src/containers/measure.tsx ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MeasureContainer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var runtime_1 = __webpack_require__(/*! ../api/runtime */ "./src/api/runtime.ts");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var measure_context_1 = __webpack_require__(/*! ./measure-context */ "./src/containers/measure-context.ts");
var number_1 = __webpack_require__(/*! ../utils/number */ "./src/utils/number.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var GeometryType_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/GeometryType */ "./node_modules/ol/geom/GeometryType.js"));
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var hooks_mapguide_1 = __webpack_require__(/*! ./hooks-mapguide */ "./src/containers/hooks-mapguide.ts");
var layer_set_1 = __webpack_require__(/*! ../api/layer-set */ "./src/api/layer-set.ts");
var _measurements = [];
var MeasureContainerInner = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(MeasureContainerInner, _super);
    function MeasureContainerInner(props) {
        var _this = _super.call(this, props) || this;
        _this.onTypeChanged = function (e) {
            var newType = e.target.value;
            _this.setState({ drawType: newType }, function () {
                var activeMapName = _this.props.activeMapName;
                if (activeMapName && _this.state.measuring === true) {
                    var activeMeasure = _measurements.filter(function (m) { return m.getMapName() === activeMapName; })[0];
                    if (activeMeasure) {
                        activeMeasure.handleDrawTypeChange();
                    }
                }
            });
        };
        _this.onClearMeasurements = function (e) {
            e.preventDefault();
            var activeMapName = _this.props.activeMapName;
            if (activeMapName) {
                var activeMeasure = _measurements.filter(function (m) { return m.getMapName() === activeMapName; })[0];
                if (activeMeasure) {
                    activeMeasure.clearMeasurements();
                }
            }
            return false;
        };
        _this.onStartMeasure = function () {
            _this.startMeasure();
        };
        _this.onEndMeasure = function () {
            _this.endMeasure();
        };
        _this.state = {
            measuring: false,
            drawType: GeometryType_1.default.LINE_STRING // "LineString"
        };
        return _this;
    }
    MeasureContainerInner.prototype.startMeasure = function () {
        var _a, _b;
        var activeMapName = this.props.activeMapName;
        var _c = this.state, type = _c.drawType, measuring = _c.measuring;
        if (activeMapName && type && !measuring) {
            //Set to none to prevent select tool interference when measuring
            (_b = (_a = this.props).setActiveTool) === null || _b === void 0 ? void 0 : _b.call(_a, common_1.ActiveMapTool.None);
            var activeMeasure = _measurements.filter(function (m) { return m.getMapName() === activeMapName; })[0];
            if (activeMeasure) {
                activeMeasure.startMeasure();
                this.setState({ measuring: true });
            }
        }
    };
    MeasureContainerInner.prototype.endMeasure = function () {
        var activeMapName = this.props.activeMapName;
        var measuring = this.state.measuring;
        if (activeMapName && measuring) {
            var activeMeasure = _measurements.filter(function (m) { return m.getMapName() === activeMapName; })[0];
            if (activeMeasure) {
                activeMeasure.endMeasure();
                this.setState({ measuring: false });
            }
        }
    };
    MeasureContainerInner.prototype.updateSegments = function (kind, total, segments) {
        this.setState({ activeType: kind, segmentTotal: total, segments: segments });
    };
    MeasureContainerInner.prototype.clearSegments = function () {
        this.setState({ segments: undefined });
    };
    MeasureContainerInner.prototype.getCurrentDrawType = function () { return this.state.drawType; };
    MeasureContainerInner.prototype.getLocale = function () {
        return this.props.locale || i18n_1.DEFAULT_LOCALE;
    };
    MeasureContainerInner.prototype.componentDidMount = function () {
        var _this = this;
        var activeMeasure;
        if (_measurements.length == 0) {
            var _a = this.props, mapNames = _a.mapNames, activeMapName = _a.activeMapName;
            var viewer = (0, runtime_1.getViewer)();
            if (viewer && mapNames && mapNames.length) {
                for (var _i = 0, mapNames_1 = mapNames; _i < mapNames_1.length; _i++) {
                    var mapName = mapNames_1[_i];
                    var context = new measure_context_1.MeasureContext(viewer, mapName, this);
                    _measurements.push(context);
                    if (activeMapName == mapName) {
                        activeMeasure = context;
                    }
                }
            }
        }
        else {
            for (var _b = 0, _measurements_1 = _measurements; _b < _measurements_1.length; _b++) {
                var measure = _measurements_1[_b];
                measure.setParent(this);
            }
            activeMeasure = _measurements.filter(function (m) { return m.getMapName() === _this.props.activeMapName; })[0];
        }
        if (activeMeasure && this.props.activeMapName) {
            activeMeasure.activate(this.props.activeMapName, this);
        }
    };
    MeasureContainerInner.prototype.componentWillUnmount = function () {
        var activeMapName = this.props.activeMapName;
        this.setState({ measuring: false });
        for (var _i = 0, _measurements_2 = _measurements; _i < _measurements_2.length; _i++) {
            var measure = _measurements_2[_i];
            measure.detachParent();
        }
        if (activeMapName) {
            for (var _a = 0, _measurements_3 = _measurements; _a < _measurements_3.length; _a++) {
                var measure = _measurements_3[_a];
                measure.deactivate(activeMapName);
            }
        }
    };
    MeasureContainerInner.prototype.componentDidUpdate = function (prevProps) {
        var nextProps = this.props;
        //Active map changed
        if (prevProps.activeMapName != nextProps.activeMapName) {
            var oldMeasure = _measurements.filter(function (m) { return m.getMapName() === prevProps.activeMapName; })[0];
            var newMeasure = _measurements.filter(function (m) { return m.getMapName() === nextProps.activeMapName; })[0];
            if (oldMeasure) {
                oldMeasure.deactivate(prevProps.activeMapName);
            }
            if (newMeasure) {
                newMeasure.activate(nextProps.activeMapName, this);
            }
            //Reset
            this.setState({ measuring: false });
        }
    };
    MeasureContainerInner.prototype.render = function () {
        var _this = this;
        var _a = this.state, measuring = _a.measuring, type = _a.drawType;
        var measureUnits = this.props.measureUnits;
        var locale = this.getLocale();
        return React.createElement("div", { className: "component-measure" },
            React.createElement("form", { className: "form-inline" },
                React.createElement("label", { className: "bp3-label" },
                    (0, i18n_1.tr)("MEASUREMENT_TYPE", locale),
                    React.createElement("div", { className: "bp3-select" },
                        React.createElement(core_1.HTMLSelect, { value: type, onChange: this.onTypeChanged },
                            React.createElement("option", { value: "LineString" }, (0, i18n_1.tr)("MEASUREMENT_TYPE_LENGTH", locale)),
                            React.createElement("option", { value: "Polygon" }, (0, i18n_1.tr)("MEASUREMENT_TYPE_AREA", locale))))),
                React.createElement(core_1.ButtonGroup, null,
                    React.createElement(core_1.Button, { type: "button", icon: "play", disabled: measuring, onClick: this.onStartMeasure }, (0, i18n_1.tr)("MEASUREMENT_START", locale)),
                    React.createElement(core_1.Button, { type: "button", icon: "stop", disabled: !measuring, onClick: this.onEndMeasure }, (0, i18n_1.tr)("MEASUREMENT_END", locale)),
                    React.createElement(core_1.Button, { type: "button", icon: "cross", onClick: this.onClearMeasurements }, (0, i18n_1.tr)("MEASUREMENT_CLEAR", locale))),
                (function () {
                    if (_this.state.measuring === true) {
                        return React.createElement("div", null,
                            React.createElement(core_1.Callout, { intent: core_1.Intent.PRIMARY, title: (0, i18n_1.tr)("MEASURING", locale) }, (0, i18n_1.tr)("MEASURING_MESSAGE", locale)),
                            (function () {
                                if (_this.state.segments) {
                                    return React.createElement("table", { className: "bp3-html-table bp3-html-table-condensed" },
                                        React.createElement("thead", null,
                                            React.createElement("tr", null,
                                                React.createElement("th", null, (0, i18n_1.tr)("MEASURE_SEGMENT", locale)),
                                                React.createElement("th", null, (0, i18n_1.tr)("MEASURE_LENGTH", locale)))),
                                        React.createElement("tbody", null,
                                            _this.state.segments.map(function (s) {
                                                return React.createElement("tr", { key: "segment-" + s.segment },
                                                    React.createElement("td", null, (0, i18n_1.tr)("MEASURE_SEGMENT_PART", locale, { segment: s.segment })),
                                                    measureUnits
                                                        ? React.createElement("td", null, (0, number_1.roundTo)(s.length, 2) + " " + (0, layer_set_1.toProjUnit)(measureUnits))
                                                        : React.createElement("td", null, (0, i18n_1.tr)("UNIT_FMT_M", locale, { value: (0, number_1.roundTo)(s.length, 2) })));
                                            }),
                                            (function () {
                                                if (_this.state.segmentTotal && _this.state.activeType) {
                                                    return React.createElement("tr", null, (function () {
                                                        if (_this.state.activeType == "Area") {
                                                            return React.createElement(React.Fragment, null,
                                                                React.createElement("td", null,
                                                                    React.createElement("strong", null, (0, i18n_1.tr)("MEASURE_TOTAL_AREA", locale))),
                                                                React.createElement("td", null, measureUnits
                                                                    ? React.createElement("div", { dangerouslySetInnerHTML: { __html: (0, number_1.roundTo)(_this.state.segmentTotal, 4) + " " + (0, layer_set_1.toProjUnit)(measureUnits) + " <sup>2</sup>" } })
                                                                    : React.createElement("div", { dangerouslySetInnerHTML: { __html: (0, i18n_1.tr)("UNIT_FMT_SQM", locale, { value: "" + (0, number_1.roundTo)(_this.state.segmentTotal, 4) }) } })));
                                                        }
                                                        else {
                                                            return React.createElement(React.Fragment, null,
                                                                React.createElement("td", null,
                                                                    React.createElement("strong", null, (0, i18n_1.tr)("MEASURE_TOTAL_LENGTH", locale))),
                                                                React.createElement("td", null, measureUnits
                                                                    ? React.createElement("div", { dangerouslySetInnerHTML: { __html: (0, number_1.roundTo)(_this.state.segmentTotal, 4) + " " + (0, layer_set_1.toProjUnit)(measureUnits) } })
                                                                    : React.createElement("div", { dangerouslySetInnerHTML: { __html: (0, i18n_1.tr)("UNIT_FMT_M", locale, { value: "" + (0, number_1.roundTo)(_this.state.segmentTotal, 4) }) } })));
                                                        }
                                                    })());
                                                }
                                            })()));
                                }
                            })());
                    }
                })()));
    };
    return MeasureContainerInner;
}(React.Component));
var MeasureContainer = function (props) {
    var _a;
    var activeMapName = (0, hooks_1.useActiveMapName)();
    var locale = (0, hooks_1.useViewerLocale)();
    var mapNames = (_a = (0, hooks_1.useAvailableMaps)()) === null || _a === void 0 ? void 0 : _a.map(function (m) { return m.value; });
    var dispatch = (0, context_1.useReduxDispatch)();
    var setActiveToolAction = function (tool) { return dispatch((0, map_1.setActiveTool)(tool)); };
    var isArbitrary = (0, hooks_mapguide_1.useActiveMapIsArbitraryCoordSys)();
    var projUnits = (0, hooks_mapguide_1.useActiveMapProjectionUnits)();
    return React.createElement(MeasureContainerInner, (0, tslib_1.__assign)({ activeMapName: activeMapName, locale: locale, mapNames: mapNames, setActiveTool: setActiveToolAction, measureUnits: isArbitrary ? projUnits : undefined }, props));
};
exports.MeasureContainer = MeasureContainer;


/***/ }),

/***/ "./src/containers/modal-launcher.tsx":
/*!*******************************************!*\
  !*** ./src/containers/modal-launcher.tsx ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModalLauncher = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var modal_dialog_1 = __webpack_require__(/*! ../components/modal-dialog */ "./src/components/modal-dialog.tsx");
var component_1 = __webpack_require__(/*! ../api/registry/component */ "./src/api/registry/component.tsx");
var error_1 = __webpack_require__(/*! ../components/error */ "./src/components/error.tsx");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var type_guards_1 = __webpack_require__(/*! ../utils/type-guards */ "./src/utils/type-guards.ts");
var never_1 = __webpack_require__(/*! ../utils/never */ "./src/utils/never.ts");
var url_1 = __webpack_require__(/*! ../utils/url */ "./src/utils/url.ts");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var modal_1 = __webpack_require__(/*! ../actions/modal */ "./src/actions/modal.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
function getComponentId(diag) {
    if ((0, type_guards_1.isModalComponentDisplayOptions)(diag)) {
        return { name: diag.component, props: {} };
    }
    else if ((0, type_guards_1.isModalDisplayOptions)(diag)) {
        return (0, url_1.parseComponentUri)(diag.url);
    }
    else {
        (0, never_1.assertNever)(diag);
    }
}
var ModalLauncher = function (props) {
    var dispatch = (0, context_1.useReduxDispatch)();
    var hideModalAction = function (name) { return dispatch((0, modal_1.hideModal)(name)); };
    var onCloseModal = function (name) { return hideModalAction(name); };
    var modal = (0, context_1.useAppState)(function (state) { return state.modal; });
    var locale = (0, hooks_1.useViewerLocale)();
    var MODAL_INIT_X = 500;
    var MODAL_INIT_Y = 80;
    if (!modal) {
        return React.createElement("noscript", null);
    }
    return React.createElement("div", null,
        Object.keys(modal).map(function (key) {
            var diag = modal[key];
            if ((0, type_guards_1.isModalComponentDisplayOptions)(diag) || ((0, type_guards_1.isModalDisplayOptions)(diag) && (0, url_1.isComponentUri)(diag.url))) {
                var componentId_1 = getComponentId(diag);
                if (componentId_1) {
                    var componentRenderer_1 = (0, component_1.getComponentFactory)(componentId_1.name);
                    return React.createElement(modal_dialog_1.RndModalDialog, { title: diag.modal.title, x: MODAL_INIT_X, y: MODAL_INIT_Y, locale: locale, enableInteractionMask: true, width: diag.modal.size[0], height: diag.modal.size[1], disableYOverflow: !diag.modal.overflowYScroll, isOpen: true, key: key, onClose: function () { return onCloseModal(key); } }, function (_a) {
                        if (componentRenderer_1) {
                            if ((0, type_guards_1.isModalComponentDisplayOptions)(diag))
                                return componentRenderer_1(diag.componentProps);
                            else
                                return componentRenderer_1(componentId_1.props);
                        }
                        else {
                            return React.createElement(error_1.Error, { error: (0, i18n_1.tr)("ERR_UNREGISTERED_COMPONENT", locale, { componentId: componentId_1 }) });
                        }
                    });
                }
                else {
                    return React.createElement(error_1.Error, { error: (0, i18n_1.tr)("ERR_NO_COMPONENT_ID", locale) });
                }
            }
            else if ((0, type_guards_1.isModalDisplayOptions)(diag)) {
                return React.createElement(modal_dialog_1.RndModalDialog, { title: diag.modal.title, isOpen: true, key: key, x: MODAL_INIT_X, y: MODAL_INIT_Y, locale: locale, enableInteractionMask: false, width: diag.modal.size[0], height: diag.modal.size[1], onClose: function () { return onCloseModal(key); } }, function (_a) {
                    var w = _a[0], h = _a[1];
                    return React.createElement("iframe", { frameBorder: 0, src: diag.url, width: w, height: h });
                });
            }
            else {
                (0, never_1.assertNever)(diag);
            }
        }),
        props.children);
};
exports.ModalLauncher = ModalLauncher;


/***/ }),

/***/ "./src/containers/mouse-coordinates.tsx":
/*!**********************************************!*\
  !*** ./src/containers/mouse-coordinates.tsx ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MouseCoordinatesContainer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var mouse_coordinates_1 = __webpack_require__(/*! ../components/mouse-coordinates */ "./src/components/mouse-coordinates.tsx");
var olProj = (0, tslib_1.__importStar)(__webpack_require__(/*! ol/proj */ "./node_modules/ol/proj.js"));
var units_1 = __webpack_require__(/*! ../utils/units */ "./src/utils/units.tsx");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var hooks_mapguide_1 = __webpack_require__(/*! ./hooks-mapguide */ "./src/containers/hooks-mapguide.ts");
var MouseCoordinatesContainer = function (props) {
    var style = props.style;
    var mapProjection = (0, hooks_mapguide_1.useActiveMapProjection)();
    var projection = (0, hooks_1.useConfiguredCoordinateProjection)();
    var decimals = (0, hooks_1.useConfiguredCoordinateDecimals)();
    var format = (0, hooks_1.useConfiguredCoordinateFormat)();
    var mouse = (0, hooks_1.useCurrentMouseCoordinates)();
    var locale = (0, hooks_1.useViewerLocale)();
    if (mouse) {
        var prj = olProj.get(projection !== null && projection !== void 0 ? projection : mapProjection);
        var units = void 0;
        if (prj) {
            units = prj.getUnits();
            switch (units) {
                case "degrees":
                    units = (0, units_1.getUnitOfMeasure)(common_1.UnitOfMeasure.Degrees).abbreviation(locale);
                    break;
                case "pixels":
                case "tile-pixels":
                    units = (0, units_1.getUnitOfMeasure)(common_1.UnitOfMeasure.Pixels).abbreviation(locale);
                    break;
                case "m":
                    units = (0, units_1.getUnitOfMeasure)(common_1.UnitOfMeasure.Meters).abbreviation(locale);
                    break;
                case "ft":
                case "us-ft":
                    units = (0, units_1.getUnitOfMeasure)(common_1.UnitOfMeasure.Feet).abbreviation(locale);
                    break;
            }
        }
        var coords = [mouse[0], mouse[1]];
        if (projection && mapProjection) {
            try {
                coords = olProj.transform(coords, mapProjection, projection);
            }
            catch (e) {
            }
        }
        return React.createElement(mouse_coordinates_1.MouseCoordinates, { units: units, coords: coords, style: style, decimals: decimals, format: format });
    }
    else {
        return React.createElement("div", null);
    }
};
exports.MouseCoordinatesContainer = MouseCoordinatesContainer;


/***/ }),

/***/ "./src/containers/navigator.tsx":
/*!**************************************!*\
  !*** ./src/containers/navigator.tsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NavigatorContainer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var navigator_1 = __webpack_require__(/*! ../components/navigator */ "./src/components/navigator.tsx");
var command_1 = __webpack_require__(/*! ../api/registry/command */ "./src/api/registry/command.ts");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var hooks_mapguide_1 = __webpack_require__(/*! ./hooks-mapguide */ "./src/containers/hooks-mapguide.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var NavigatorContainer = function (props) {
    var style = props.style;
    var dispatch = (0, context_1.useReduxDispatch)();
    var locale = (0, hooks_1.useViewerLocale)();
    var finiteScales = (0, hooks_mapguide_1.useActiveMapFiniteScales)();
    var view = (0, hooks_1.useActiveMapView)();
    var busyCount = (0, hooks_1.useViewerBusyCount)();
    var activeMapName = (0, hooks_1.useActiveMapName)();
    var setScaleAction = function (mapName, scale) { return dispatch((0, map_1.setScale)(mapName, scale)); };
    var invokeCommandAction = function (cmd, parameters) { return dispatch((0, map_1.invokeCommand)(cmd, parameters)); };
    var onZoom = function (direction) {
        var cmd;
        switch (direction) {
            case navigator_1.ZoomDirection.In:
                cmd = (0, command_1.getCommand)(command_1.DefaultCommands.ZoomIn);
                break;
            case navigator_1.ZoomDirection.Out:
                cmd = (0, command_1.getCommand)(command_1.DefaultCommands.ZoomOut);
                break;
        }
        if (cmd) {
            invokeCommandAction(cmd);
        }
    };
    var onPan = function (direction) {
        var cmd;
        switch (direction) {
            case navigator_1.PanDirection.East:
                cmd = (0, command_1.getCommand)(command_1.DefaultCommands.PanRight);
                break;
            case navigator_1.PanDirection.West:
                cmd = (0, command_1.getCommand)(command_1.DefaultCommands.PanLeft);
                break;
            case navigator_1.PanDirection.North:
                cmd = (0, command_1.getCommand)(command_1.DefaultCommands.PanUp);
                break;
            case navigator_1.PanDirection.South:
                cmd = (0, command_1.getCommand)(command_1.DefaultCommands.PanDown);
                break;
        }
        if (cmd) {
            invokeCommandAction(cmd);
        }
    };
    var onRequestZoomToScale = function (scale) {
        if (activeMapName) {
            setScaleAction(activeMapName, scale);
        }
    };
    if (view) {
        return React.createElement(navigator_1.Navigator, { style: style, scale: view.scale, finiteScaleList: finiteScales, locale: locale, busy: busyCount > 0, onRequestZoomToScale: onRequestZoomToScale, onPan: onPan, onZoom: onZoom });
    }
    else {
        return React.createElement("div", null);
    }
};
exports.NavigatorContainer = NavigatorContainer;


/***/ }),

/***/ "./src/containers/neo-map-viewer.tsx":
/*!*******************************************!*\
  !*** ./src/containers/neo-map-viewer.tsx ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MapViewer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var ReactDOM = (0, tslib_1.__importStar)(__webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"));
var base_1 = __webpack_require__(/*! ../components/map-providers/base */ "./src/components/map-providers/base.ts");
var assets_1 = __webpack_require__(/*! ../constants/assets */ "./src/constants/assets.ts");
var map_load_indicator_1 = __webpack_require__(/*! ../components/map-load-indicator */ "./src/components/map-load-indicator.tsx");
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var mapguide_1 = __webpack_require__(/*! ../components/map-providers/mapguide */ "./src/components/map-providers/mapguide.ts");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
__webpack_require__(/*! ol/ol.css */ "./node_modules/ol/ol.css");
var subscriber_1 = __webpack_require__(/*! ./subscriber */ "./src/containers/subscriber.tsx");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var flyout_1 = __webpack_require__(/*! ../actions/flyout */ "./src/actions/flyout.ts");
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
var CoreMapViewer = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(CoreMapViewer, _super);
    function CoreMapViewer(props) {
        var _this = _super.call(this, props) || this;
        //#region IViewerComponent
        _this.selectCanDragPan = function () { return _this.props.selectCanDragPan; };
        _this.isContextMenuOpen = function () { return _this.props.isContextMenuOpen; };
        _this.setDigitizingType = function (digitizingType) { return _this.setState({ digitizingType: digitizingType }); };
        _this.onBeginDigitization = function (callback) { };
        _this.onHideContextMenu = function () { var _a, _b; return (_b = (_a = _this.props).onHideContextMenu) === null || _b === void 0 ? void 0 : _b.call(_a); };
        _this.onOpenTooltipLink = function (url) { };
        _this.onDispatch = function (action) { return _this.props.onDispatch(action); };
        _this.addSubscribers = function (props) {
            var subscribers = (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], _this.state.subscribers, true), props, true);
            _this.setState({ subscribers: subscribers });
            return props.map(function (p) { return p.name; });
        };
        _this.removeSubscribers = function (names) {
            var subscribers = _this.state.subscribers;
            var ol = subscribers.length;
            var ns = subscribers.filter(function (s) { return names.indexOf(s.name) < 0; });
            _this.setState({ subscribers: subscribers });
            return ns.length < ol;
        };
        //#endregion
        _this.onContextMenu = function (e) {
            var _a, _b;
            if (!_this.mounted)
                return;
            if (_this.props.context.isMouseOverTooltip()) {
                return;
            }
            e.preventDefault();
            //console.log(`Open context menu at (${e.clientX}, ${e.clientY})`);
            (_b = (_a = _this.props).onContextMenu) === null || _b === void 0 ? void 0 : _b.call(_a, [e.clientX, e.clientY]);
        };
        _this.onKeyDown = function (e) {
            if (!_this.mounted)
                return;
            _this.props.context.onKeyDown(e);
            _this.setState({ shiftKey: e.shiftKey });
        };
        _this.onKeyUp = function (e) {
            if (!_this.mounted)
                return;
            _this.setState({ shiftKey: e.shiftKey });
        };
        _this.onMouseDown = function (e) {
            if (!_this.mounted)
                return;
            if (!_this.state.isMouseDown) {
                _this.setState({
                    isMouseDown: true
                });
            }
        };
        _this.onMouseUp = function (e) {
            if (!_this.mounted)
                return;
            if (_this.state.isMouseDown) {
                _this.setState({
                    isMouseDown: false
                });
            }
        };
        _this.mounted = false;
        _this.state = {
            shiftKey: false,
            isMouseDown: false,
            digitizingType: undefined,
            loaded: 0,
            loading: 0,
            subscribers: []
        };
        return _this;
    }
    CoreMapViewer.prototype.addImageLoading = function () {
        var loading = this.state.loading;
        var newLoading = (loading || 0) + 1;
        this.setState({ loading: newLoading });
        this.props.context.incrementBusyWorker();
    };
    CoreMapViewer.prototype.getSubscribers = function () {
        return this.state.subscribers.map(function (s) { return s.name; });
    };
    CoreMapViewer.prototype.addImageLoaded = function () {
        var _a = this.state, loaded = _a.loaded, loading = _a.loading;
        var newLoadedCount = (loaded || 0) + 1;
        if (loading === newLoadedCount) {
            this.setState({ loaded: 0, loading: 0 });
        }
        else {
            this.setState({ loaded: newLoadedCount });
        }
        this.props.context.decrementBusyWorker();
    };
    CoreMapViewer.prototype.componentDidMount = function () {
        document.addEventListener("keydown", this.onKeyDown);
        document.addEventListener("keyup", this.onKeyUp);
        var mapNode = ReactDOM.findDOMNode(this);
        this.props.context.attachToComponent(mapNode, this);
        this.mounted = true;
    };
    CoreMapViewer.prototype.componentWillUnmount = function () {
        this.props.context.detachFromComponent();
        this.mounted = false;
    };
    CoreMapViewer.prototype.render = function () {
        var _a = this.props, context = _a.context, backgroundColor = _a.backgroundColor;
        var isMouseDown = this.state.isMouseDown;
        var tool = context.getActiveTool();
        var style = {
            width: "100%",
            height: "100%"
        };
        if (context.isDigitizing()) {
            var dtype = this.state.digitizingType;
            switch (dtype) {
                case "Point":
                    style.cursor = "url(" + assets_1.CURSOR_DIGITIZE_POINT + "), auto";
                    //console.log(`cursor: ${style.cursor}`);
                    break;
                case "Line":
                    style.cursor = "url(" + assets_1.CURSOR_DIGITIZE_LINE + "), auto";
                    //console.log(`cursor: ${style.cursor}`);
                    break;
                case "LineString":
                    style.cursor = "url(" + assets_1.CURSOR_DIGITIZE_LINESTRING + "), auto";
                    //console.log(`cursor: ${style.cursor}`);
                    break;
                case "Rectangle":
                    style.cursor = "url(" + assets_1.CURSOR_DIGITIZE_RECT + "), auto";
                    //console.log(`cursor: ${style.cursor}`);
                    break;
                case "Polygon":
                    style.cursor = "url(" + assets_1.CURSOR_DIGITIZE_POLYGON + "), auto";
                    //console.log(`cursor: ${style.cursor}`);
                    break;
                case "Circle":
                    style.cursor = "url(" + assets_1.CURSOR_DIGITIZE_CIRCLE + "), auto";
                    //console.log(`cursor: ${style.cursor}`);
                    break;
            }
        }
        else {
            switch (tool) {
                case common_1.ActiveMapTool.Pan:
                    if (isMouseDown) {
                        style.cursor = "url(" + assets_1.CURSOR_GRABBING + "), auto";
                        //console.log(`cursor: ${style.cursor}`);
                    }
                    else {
                        style.cursor = "url(" + assets_1.CURSOR_GRAB + "), auto";
                        //console.log(`cursor: ${style.cursor}`);
                    }
                    break;
                case common_1.ActiveMapTool.Zoom:
                    style.cursor = "url(" + assets_1.CURSOR_ZOOM_IN + "), auto";
                    //console.log(`cursor: ${style.cursor}`);
                    break;
            }
        }
        if (backgroundColor) {
            style.backgroundColor = backgroundColor;
            //style.backgroundColor = `#${map.BackgroundColor.substring(2)}`;
        }
        var _b = this.state, loading = _b.loading, loaded = _b.loaded, subscribers = _b.subscribers;
        return React.createElement("div", { className: "map-viewer-component", style: style, onContextMenu: this.onContextMenu, onMouseDown: this.onMouseDown, onMouseUp: this.onMouseUp },
            React.createElement(map_load_indicator_1.MapLoadIndicator, { loaded: loaded || 0, loading: loading || 0, position: this.props.loadIndicatorPosition, color: this.props.loadIndicatorColor }),
            subscribers.map(function (s, i) { return React.createElement(subscriber_1.Subscriber, (0, tslib_1.__assign)({ key: "subscriber-" + i + "-" + s.name }, s)); }),
            this.props.children);
    };
    return CoreMapViewer;
}(React.Component));
var MapViewer = function (_a) {
    var _b;
    var children = _a.children;
    var context = (0, context_1.useMapProviderContext)();
    var toasterRef = React.useRef(null);
    var loadIndicatorPositioning = (0, hooks_1.useConfiguredLoadIndicatorPositioning)();
    var loadIndicatorColor = (0, hooks_1.useConfiguredLoadIndicatorColor)();
    var dispatch = (0, context_1.useReduxDispatch)();
    var hookFunc = context.getHookFunction();
    var clientSelection = (0, hooks_1.useActiveMapClientSelectionSet)();
    var appSettings = (0, hooks_1.useCustomAppSettings)();
    var nextState = hookFunc();
    var mapName = nextState.mapName, layers = nextState.layers, initialExternalLayers = nextState.initialExternalLayers, bgColor = nextState.bgColor, locale = nextState.locale;
    var flyouts = (0, hooks_1.useViewerFlyouts)();
    React.useEffect(function () {
        var _a;
        if (!clientSelection) {
            (_a = context.getSelectedFeatures()) === null || _a === void 0 ? void 0 : _a.clear();
        }
    }, [clientSelection]);
    var bContextMenuOpen = (((_b = flyouts[constants_1.WEBLAYOUT_CONTEXTMENU]) === null || _b === void 0 ? void 0 : _b.open) == true);
    var bSelectCanDragPan = (0, hooks_1.useViewerSelectCanDragPan)();
    var showContextMenuAction = function (pos) { return dispatch((0, flyout_1.openContextMenu)({ x: pos[0], y: pos[1] })); };
    var hideContextMenuAction = function () { return dispatch((0, flyout_1.closeContextMenu)()); };
    var onContextMenu = function (pos) { return showContextMenuAction === null || showContextMenuAction === void 0 ? void 0 : showContextMenuAction(pos); };
    //HACK: Still have some MG-specific state we're needing to check for here. Minor abstraction leakage.
    var agentUri;
    var agentKind;
    var selection = null;
    if ((0, mapguide_1.isMapGuideProviderState)(nextState)) {
        agentUri = nextState.agentUri;
        agentKind = nextState.agentKind;
        selection = nextState.selection;
    }
    context.setToasterRef(toasterRef);
    context.setProviderState(nextState);
    (0, base_1.useViewerSideEffects)(context, appSettings !== null && appSettings !== void 0 ? appSettings : {}, nextState.isReady, mapName, layers, initialExternalLayers, agentUri, agentKind, selection);
    if (nextState.isReady) {
        return React.createElement(React.Fragment, null,
            React.createElement(core_1.Toaster, { usePortal: false, position: core_1.Position.TOP, ref: toasterRef }),
            React.createElement(CoreMapViewer, { context: context, onDispatch: dispatch, backgroundColor: bgColor, onContextMenu: onContextMenu, onHideContextMenu: hideContextMenuAction, isContextMenuOpen: bContextMenuOpen, selectCanDragPan: bSelectCanDragPan, loadIndicatorPosition: loadIndicatorPositioning, loadIndicatorColor: loadIndicatorColor }, children));
    }
    else {
        return React.createElement("div", null, (0, i18n_1.tr)("LOADING_MSG", locale));
    }
};
exports.MapViewer = MapViewer;


/***/ }),

/***/ "./src/containers/quick-plot.tsx":
/*!***************************************!*\
  !*** ./src/containers/quick-plot.tsx ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QuickPlotContainer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var runtime_1 = __webpack_require__(/*! ../api/runtime */ "./src/api/runtime.ts");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var map_capturer_context_1 = __webpack_require__(/*! ./map-capturer-context */ "./src/containers/map-capturer-context.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
var hooks_mapguide_1 = __webpack_require__(/*! ./hooks-mapguide */ "./src/containers/hooks-mapguide.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
function getMargin() {
    /*
    var widget = getParent().Fusion.getWidgetsByType("QuickPlot")[0];
    var margin;
    
    if(!!widget.margin){
         margin = widget.margin;
    }else{
        //the default margin
        margin = {top: 25.4, buttom: 12.7, left: 12.7, right: 12.7};
    }
    return margin;
    */
    return { top: 25.4, buttom: 12.7, left: 12.7, right: 12.7 };
}
function getPrintSize(viewer, showAdvanced, paperSize, orientation) {
    var value = paperSize.split(",");
    var size;
    if (orientation === "P") {
        size = { w: parseFloat(value[0]), h: parseFloat(value[1]) };
    }
    else {
        size = { w: parseFloat(value[1]), h: parseFloat(value[0]) };
    }
    if (!showAdvanced) {
        // Calculate the paper size to make sure it has a same ratio with the viweport
        var paperRatio = size.w / size.h;
        var viewSize = viewer.getSize();
        var vs = void 0;
        if (orientation === "P") {
            vs = {
                w: viewSize[1],
                h: viewSize[0]
            };
        }
        else {
            vs = {
                w: viewSize[0],
                h: viewSize[1]
            };
        }
        if (vs) {
            var viewRatio = vs.w / vs.h;
            if (paperRatio > viewRatio) {
                size.w = size.h * viewRatio;
            }
            else {
                size.h = size.w / viewRatio;
            }
        }
    }
    var margins = getMargin();
    size.h = size.h - margins.top - margins.buttom;
    size.w = size.w - margins.left - margins.right;
    return size;
}
var _mapCapturers = [];
function getActiveCapturer(viewer, mapNames, activeMapName) {
    var activeCapturer;
    if (_mapCapturers.length == 0) {
        if (mapNames.length) {
            for (var _i = 0, mapNames_1 = mapNames; _i < mapNames_1.length; _i++) {
                var mapName = mapNames_1[_i];
                var context = new map_capturer_context_1.MapCapturerContext(viewer, mapName);
                _mapCapturers.push(context);
                if (activeMapName == mapName) {
                    activeCapturer = context;
                }
            }
        }
    }
    else {
        activeCapturer = _mapCapturers.filter(function (m) { return m.getMapName() === activeMapName; })[0];
    }
    return activeCapturer;
}
function toggleMapCapturerLayer(locale, mapNames, activeMapName, showAdvanced, paperSize, orientation, scale, rotation, updateBoxCoords, setViewRotationEnabled, setViewRotation) {
    var bVisible = showAdvanced;
    var viewer = (0, runtime_1.getViewer)();
    if (viewer && mapNames) {
        var activeCapturer = getActiveCapturer(viewer, mapNames, activeMapName);
        if (activeCapturer) {
            if (bVisible) {
                var ppSize = getPrintSize(viewer, showAdvanced, paperSize, orientation);
                var cb = {
                    updateBoxCoords: updateBoxCoords
                };
                activeCapturer.activate(cb, ppSize, parseFloat(scale), rotation);
                //For simplicity, reset rotation to 0 and prevent the ability to rotate while the map capture box
                //is active
                setViewRotationEnabled(false);
                setViewRotation(0);
                viewer.toastPrimary("info-sign", (0, i18n_1.tr)("QUICKPLOT_BOX_INFO", locale));
            }
            else {
                activeCapturer.deactivate();
                setViewRotationEnabled(true);
            }
        }
    }
}
var QuickPlotContainer = function () {
    var _a;
    var _b = React.useState(""), title = _b[0], setTitle = _b[1];
    "";
    var _c = React.useState(""), subTitle = _c[0], setSubTitle = _c[1];
    var _d = React.useState(false), showLegend = _d[0], setShowLegend = _d[1];
    var _e = React.useState(false), showNorthBar = _e[0], setShowNorthBar = _e[1];
    var _f = React.useState(false), showCoordinates = _f[0], setShowCoordinates = _f[1];
    var _g = React.useState(false), showScaleBar = _g[0], setShowScaleBar = _g[1];
    var _h = React.useState(false), showDisclaimer = _h[0], setShowDisclaimer = _h[1];
    var _j = React.useState(false), showAdvanced = _j[0], setShowAdvanced = _j[1];
    var _k = React.useState("P"), orientation = _k[0], setOrientation = _k[1];
    var _l = React.useState("210.0,297.0,A4"), paperSize = _l[0], setPaperSize = _l[1];
    var _m = React.useState("5000"), scale = _m[0], setScale = _m[1];
    var _o = React.useState("96"), dpi = _o[0], setDpi = _o[1];
    var _p = React.useState(0), rotation = _p[0], setRotation = _p[1];
    var _q = React.useState(""), box = _q[0], setBox = _q[1];
    var _r = React.useState(""), normalizedBox = _r[0], setNormalizedBox = _r[1];
    var locale = (0, hooks_1.useViewerLocale)();
    var activeMapName = (0, hooks_1.useActiveMapName)();
    var mapNames = (_a = (0, hooks_1.useAvailableMaps)()) === null || _a === void 0 ? void 0 : _a.map(function (m) { return m.value; });
    var map = (0, hooks_mapguide_1.useActiveMapState)();
    var view = (0, hooks_1.useActiveMapView)();
    var externalBaseLayers = (0, hooks_1.useActiveMapExternalBaseLayers)(false);
    var dispatch = (0, context_1.useReduxDispatch)();
    var setViewRotationAction = function (rotation) { return dispatch((0, map_1.setViewRotation)(rotation)); };
    var setViewRotationEnabledAction = function (enabled) { return dispatch((0, map_1.setViewRotationEnabled)(enabled)); };
    var onTitleChanged = function (e) {
        setTitle(e.target.value);
    };
    var onSubTitleChanged = function (e) {
        setSubTitle(e.target.value);
    };
    var onShowLegendChanged = function () {
        setShowLegend(!showLegend);
    };
    var onShowNorthArrowChanged = function () {
        setShowNorthBar(!showNorthBar);
    };
    var onShowCoordinatesChanged = function () {
        setShowCoordinates(!showCoordinates);
    };
    var onShowScaleBarChanged = function () {
        setShowScaleBar(!showScaleBar);
    };
    var onShowDisclaimerChanged = function () {
        setShowDisclaimer(!showDisclaimer);
    };
    var onDpiChanged = function (e) {
        setDpi(e.target.value);
    };
    var onAdvancedOptionsChanged = function () {
        setShowAdvanced(!showAdvanced);
    };
    var onScaleChanged = function (e) {
        setScale(e.target.value);
    };
    var onPaperSizeChanged = function (e) {
        setPaperSize(e.target.value);
    };
    var onOrientationChanged = function (e) {
        setOrientation(e.target.value);
    };
    var onRotationChanged = function (value) {
        setRotation(value);
    };
    var onGeneratePlot = function () { };
    var updateBoxCoords = function (box, normalizedBox) {
        setBox(box);
        setNormalizedBox(normalizedBox);
    };
    //Side-effect that emulates the old componentWillUnmount lifecyle method to tear down
    //the active map capturer
    React.useEffect(function () {
        return function () {
            //Tear down all active capture box layers
            var viewer = (0, runtime_1.getViewer)();
            if (viewer && mapNames) {
                for (var _i = 0, mapNames_2 = mapNames; _i < mapNames_2.length; _i++) {
                    var activeMapName_1 = mapNames_2[_i];
                    var activeCapturer = getActiveCapturer(viewer, mapNames, activeMapName_1);
                    if (activeCapturer) {
                        (0, logger_1.debug)("De-activating map capturer for: " + activeMapName_1);
                        activeCapturer.deactivate();
                    }
                }
            }
        };
    }, []);
    //Although the dep array arg of React.useEffect() has effectively rendered the need to
    //track previous values obsolete, we still need to track the previous advanced flag to
    //verify that the flag is amongst the actual values in the dep array that has changed
    var prevShowAdvanced = (0, hooks_1.usePrevious)(showAdvanced);
    //Side-effect that toggles/updates associated map capturers
    React.useEffect(function () {
        if (activeMapName && mapNames) {
            if (showAdvanced != prevShowAdvanced) {
                toggleMapCapturerLayer(locale, mapNames, activeMapName, showAdvanced, paperSize, orientation, scale, rotation, updateBoxCoords, setViewRotationEnabledAction, setViewRotationAction);
            }
            if (showAdvanced) {
                var v = (0, runtime_1.getViewer)();
                if (v) {
                    var capturer = getActiveCapturer(v, mapNames, activeMapName);
                    if (capturer) {
                        var ppSize_1 = getPrintSize(v, showAdvanced, paperSize, orientation);
                        (0, logger_1.debug)("Updating map capturer for: " + activeMapName);
                        capturer.updateBox(ppSize_1, parseFloat(scale), rotation);
                    }
                }
            }
        }
    }, [mapNames, activeMapName, showAdvanced, scale, paperSize, orientation, rotation, locale]);
    var viewer = (0, runtime_1.getViewer)();
    if (!viewer || !map || !view) {
        return React.createElement("noscript", null);
    }
    var hasExternalBaseLayers = false;
    if (externalBaseLayers) {
        hasExternalBaseLayers = externalBaseLayers.length > 0;
    }
    var normBox = normalizedBox;
    var theBox = box;
    if (!showAdvanced) {
        var extent = viewer.getCurrentExtent();
        theBox = extent[0] + ", " + extent[1] + ", " + extent[2] + ", " + extent[1] + ", " + extent[2] + ", " + extent[3] + ", " + extent[0] + ", " + extent[3] + ", " + extent[0] + ", " + extent[1];
        normBox = theBox;
    }
    var ppSize;
    var prSize;
    var tokens = paperSize.split(",");
    if (orientation === "L") {
        prSize = tokens[1] + "," + tokens[0];
        ppSize = prSize + "," + tokens[2];
    }
    else { // P
        prSize = tokens[0] + "," + tokens[1];
        ppSize = prSize + "," + tokens[2];
    }
    var url = (0, runtime_1.getFusionRoot)() + "/widgets/QuickPlot/PlotAsPDF.php";
    return React.createElement("div", { className: "component-quick-plot" },
        React.createElement("form", { id: "Form1", name: "Form1", target: "_blank", method: "post", action: url },
            React.createElement("input", { type: "hidden", id: "printId", name: "printId", value: "" + Math.random() * 1000 }),
            React.createElement("div", { className: "Title FixWidth" }, (0, i18n_1.tr)("QUICKPLOT_HEADER", locale)),
            React.createElement("label", { className: "bp3-label" },
                (0, i18n_1.tr)("QUICKPLOT_TITLE", locale),
                React.createElement("input", { type: "text", className: "bp3-input bp3-fill", dir: "auto", name: "{field:title}", id: "title", maxLength: 100, value: title, onChange: onTitleChanged })),
            React.createElement("label", { className: "bp3-label" },
                (0, i18n_1.tr)("QUICKPLOT_SUBTITLE", locale),
                React.createElement("input", { type: "text", className: "bp3-input bp3-fill", dir: "auto", name: "{field:sub_title}", id: "subtitle", maxLength: 100, value: subTitle, onChange: onSubTitleChanged })),
            React.createElement("label", { className: "bp3-label" },
                (0, i18n_1.tr)("QUICKPLOT_PAPER_SIZE", locale),
                React.createElement("div", { className: "bp3-select bp3-fill" },
                    React.createElement(core_1.HTMLSelect, { className: "FixWidth", id: "paperSizeSelect", name: "paperSizeSelect", value: paperSize, onChange: onPaperSizeChanged },
                        React.createElement("option", { value: "210.0,297.0,A4" }, "A4 (210x297 mm; 8.27x11.69 In) "),
                        React.createElement("option", { value: "297.0,420.0,A3" }, "A3 (297x420 mm; 11.69x16.54 In) "),
                        React.createElement("option", { value: "148.0,210.0,A5" }, "A5 (148x210 mm; 5.83x8.27 in) "),
                        React.createElement("option", { value: "216.0,279.0,Letter" }, "Letter (216x279 mm; 8.50x11.00 In) "),
                        React.createElement("option", { value: "216.0,356.0,Legal" }, "Legal (216x356 mm; 8.50x14.00 In) ")))),
            React.createElement("label", { className: "bp3-label" },
                (0, i18n_1.tr)("QUICKPLOT_ORIENTATION", locale),
                React.createElement("div", { className: "bp3-select bp3-fill" },
                    React.createElement(core_1.HTMLSelect, { className: "FixWidth", id: "orientation", name: "orientation", value: orientation, onChange: onOrientationChanged },
                        React.createElement("option", { value: "P" }, (0, i18n_1.tr)("QUICKPLOT_ORIENTATION_P", locale)),
                        React.createElement("option", { value: "L" }, (0, i18n_1.tr)("QUICKPLOT_ORIENTATION_L", locale))))),
            React.createElement("input", { type: "hidden", id: "paperSize", name: "paperSize", value: ppSize }),
            React.createElement("input", { type: "hidden", id: "printSize", name: "printSize", value: prSize }),
            React.createElement("fieldset", null,
                React.createElement("legend", null, (0, i18n_1.tr)("QUICKPLOT_SHOWELEMENTS", locale)),
                React.createElement("label", { className: "bp3-control bp3-checkbox" },
                    React.createElement("input", { type: "checkbox", id: "ShowLegendCheckBox", name: "ShowLegend", checked: showLegend, onChange: onShowLegendChanged }),
                    React.createElement("span", { className: "bp3-control-indicator" }),
                    (0, i18n_1.tr)("QUICKPLOT_SHOWLEGEND", locale)),
                React.createElement("label", { className: "bp3-control bp3-checkbox" },
                    React.createElement("input", { type: "checkbox", id: "ShowNorthArrowCheckBox", name: "ShowNorthArrow", checked: showNorthBar, onChange: onShowNorthArrowChanged }),
                    React.createElement("span", { className: "bp3-control-indicator" }),
                    (0, i18n_1.tr)("QUICKPLOT_SHOWNORTHARROW", locale)),
                React.createElement("label", { className: "bp3-control bp3-checkbox" },
                    React.createElement("input", { type: "checkbox", id: "ShowCoordinatesCheckBox", name: "ShowCoordinates", checked: showCoordinates, onChange: onShowCoordinatesChanged }),
                    React.createElement("span", { className: "bp3-control-indicator" }),
                    (0, i18n_1.tr)("QUICKPLOT_SHOWCOORDINTES", locale)),
                React.createElement("label", { className: "bp3-control bp3-checkbox" },
                    React.createElement("input", { type: "checkbox", id: "ShowScaleBarCheckBox", name: "ShowScaleBar", checked: showScaleBar, onChange: onShowScaleBarChanged }),
                    React.createElement("span", { className: "bp3-control-indicator" }),
                    (0, i18n_1.tr)("QUICKPLOT_SHOWSCALEBAR", locale)),
                React.createElement("label", { className: "bp3-control bp3-checkbox" },
                    React.createElement("input", { type: "checkbox", id: "ShowDisclaimerCheckBox", name: "ShowDisclaimer", checked: showDisclaimer, onChange: onShowDisclaimerChanged }),
                    React.createElement("span", { className: "bp3-control-indicator" }),
                    (0, i18n_1.tr)("QUICKPLOT_SHOWDISCLAIMER", locale))),
            React.createElement("div", { className: "HPlaceholder5px" }),
            React.createElement("div", null,
                React.createElement("label", { className: "bp3-control bp3-checkbox" },
                    React.createElement("input", { type: "checkbox", id: "AdvancedOptionsCheckBox", onChange: onAdvancedOptionsChanged }),
                    React.createElement("span", { className: "bp3-control-indicator" }),
                    (0, i18n_1.tr)("QUICKPLOT_ADVANCED_OPTIONS", locale))),
            (function () {
                if (showAdvanced) {
                    return React.createElement("div", null,
                        React.createElement("label", { className: "bp3-label" },
                            (0, i18n_1.tr)("QUICKPLOT_SCALING", locale),
                            React.createElement("div", { className: "bp3-select bp3-fill" },
                                React.createElement(core_1.HTMLSelect, { className: "FixWidth", id: "scaleDenominator", name: "scaleDenominator", value: scale, onChange: onScaleChanged },
                                    React.createElement("option", { value: "500" }, "1: 500"),
                                    React.createElement("option", { value: "1000" }, "1: 1000"),
                                    React.createElement("option", { value: "2500" }, "1: 2500"),
                                    React.createElement("option", { value: "5000" }, "1: 5000")))),
                        React.createElement("label", { className: "bp3-label" },
                            (0, i18n_1.tr)("QUICKPLOT_DPI", locale),
                            React.createElement("div", { className: "bp3-select bp3-fill" },
                                React.createElement(core_1.HTMLSelect, { className: "FixWidth", id: "dpi", name: "dpi", value: dpi, onChange: onDpiChanged },
                                    React.createElement("option", { value: "96" }, "96"),
                                    React.createElement("option", { value: "150" }, "150"),
                                    React.createElement("option", { value: "300" }, "300"),
                                    React.createElement("option", { value: "600" }, "600")))),
                        React.createElement("label", { className: "bp3-label noselect" },
                            (0, i18n_1.tr)("QUICKPLOT_BOX_ROTATION", locale),
                            React.createElement("div", { style: { paddingLeft: 16, paddingRight: 16 } },
                                React.createElement(core_1.Slider, { min: 0, max: 360, labelStepSize: 90, stepSize: 1, value: rotation, onChange: onRotationChanged }))));
                }
                else {
                    return React.createElement("div", null,
                        React.createElement("input", { type: "hidden", id: "scaleDenominator", name: "scaleDenominator", value: "" + view.scale }),
                        React.createElement("input", { type: "hidden", id: "dpi", name: "dpi", value: dpi }));
                }
            })(),
            React.createElement("div", { className: "HPlaceholder5px" }),
            (function () {
                if (hasExternalBaseLayers) {
                    return React.createElement(core_1.Callout, { intent: core_1.Intent.PRIMARY, icon: "info-sign" }, (0, i18n_1.tr)("QUICKPLOT_COMMERCIAL_LAYER_WARNING", locale));
                }
            })(),
            React.createElement("div", { className: "ButtonContainer FixWidth" },
                React.createElement(core_1.Button, { type: "submit", intent: core_1.Intent.PRIMARY, icon: "print", onClick: onGeneratePlot }, (0, i18n_1.tr)("QUICKPLOT_GENERATE", locale))),
            React.createElement("input", { type: "hidden", id: "margin", name: "margin" }),
            React.createElement("input", { type: "hidden", id: "normalizedBox", name: "normalizedBox", value: normBox }),
            React.createElement("input", { type: "hidden", id: "rotation", name: "rotation", value: -(rotation || 0) }),
            React.createElement("input", { type: "hidden", id: "sessionId", name: "sessionId", value: map.SessionId }),
            React.createElement("input", { type: "hidden", id: "mapName", name: "mapName", value: map.Name }),
            React.createElement("input", { type: "hidden", id: "box", name: "box", value: theBox }),
            React.createElement("input", { type: "hidden", id: "legalNotice", name: "legalNotice" })));
};
exports.QuickPlotContainer = QuickPlotContainer;


/***/ }),

/***/ "./src/containers/scale-display.tsx":
/*!******************************************!*\
  !*** ./src/containers/scale-display.tsx ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScaleDisplayContainer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var scale_display_1 = __webpack_require__(/*! ../components/scale-display */ "./src/components/scale-display.tsx");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var hooks_mapguide_1 = __webpack_require__(/*! ./hooks-mapguide */ "./src/containers/hooks-mapguide.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var ScaleDisplayContainer = function (props) {
    var style = props.style;
    var dispatch = (0, context_1.useReduxDispatch)();
    var locale = (0, hooks_1.useViewerLocale)();
    var activeMapName = (0, hooks_1.useActiveMapName)();
    var view = (0, hooks_1.useActiveMapView)();
    var finiteScales = (0, hooks_mapguide_1.useActiveMapFiniteScales)();
    var setScaleAction = function (mapName, scale) { return dispatch((0, map_1.setScale)(mapName, scale)); };
    var onScaleChanged = function (scale) {
        if (activeMapName) {
            setScaleAction(activeMapName, scale);
        }
    };
    if (view) {
        return React.createElement(scale_display_1.ScaleDisplay, { onScaleChanged: onScaleChanged, view: view, style: style, finiteScales: finiteScales, locale: locale });
    }
    else {
        return React.createElement("noscript", null);
    }
};
exports.ScaleDisplayContainer = ScaleDisplayContainer;


/***/ }),

/***/ "./src/containers/selected-feature-count.tsx":
/*!***************************************************!*\
  !*** ./src/containers/selected-feature-count.tsx ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectedFeatureCountContainer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var selection_count_1 = __webpack_require__(/*! ../api/selection-count */ "./src/api/selection-count.ts");
var selected_feature_count_1 = __webpack_require__(/*! ../components/selected-feature-count */ "./src/components/selected-feature-count.tsx");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var SelectedFeatureCountContainer = function (props) {
    var style = props.style;
    var selection = (0, hooks_1.useActiveMapSelectionSet)();
    var clientSelection = (0, hooks_1.useActiveMapClientSelectionSet)();
    var locale = (0, hooks_1.useViewerLocale)();
    var summary = (0, selection_count_1.countSelection)(selection === null || selection === void 0 ? void 0 : selection.FeatureSet, clientSelection);
    if (summary) {
        return React.createElement(selected_feature_count_1.SelectedFeatureCount, { locale: locale, style: style, summary: summary });
    }
    else {
        return React.createElement("div", null);
    }
};
exports.SelectedFeatureCountContainer = SelectedFeatureCountContainer;


/***/ }),

/***/ "./src/containers/selection-panel.tsx":
/*!********************************************!*\
  !*** ./src/containers/selection-panel.tsx ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionPanelContainer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var selection_panel_1 = __webpack_require__(/*! ../components/selection-panel */ "./src/components/selection-panel.tsx");
var runtime_1 = __webpack_require__(/*! ../api/runtime */ "./src/api/runtime.ts");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var context_1 = __webpack_require__(/*! ../components/context */ "./src/components/context.ts");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var hooks_mapguide_1 = __webpack_require__(/*! ./hooks-mapguide */ "./src/containers/hooks-mapguide.ts");
var context_2 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var composite_selection_1 = __webpack_require__(/*! ../api/composite-selection */ "./src/api/composite-selection.ts");
var SelectionPanelContainer = function (props) {
    var maxHeight = props.maxHeight, selectedFeatureRenderer = props.selectedFeatureRenderer;
    var locale = (0, hooks_1.useViewerLocale)();
    var map = (0, hooks_mapguide_1.useActiveMapState)();
    var selection = (0, hooks_1.useActiveMapSelectionSet)();
    var clientSelection = (0, hooks_1.useActiveMapClientSelectionSet)();
    var dispatch = (0, context_2.useReduxDispatch)();
    var activeMapName = (0, hooks_1.useActiveMapName)();
    var setCurrentViewAction = function (view) { return dispatch((0, map_1.setCurrentView)(view)); };
    var showSelectedFeatureAction = function (mapName, layerId, selectionKey) { return dispatch((0, map_1.showSelectedFeature)(mapName, layerId, selectionKey)); };
    var appContext = React.useContext(context_1.AppContext);
    var onZoomToSelectedFeature = function (feature) {
        if (feature.Bounds) {
            var bbox = feature.Bounds.split(" ").map(function (s) { return parseFloat(s); });
            var viewer = (0, runtime_1.getViewer)();
            if (viewer) {
                var view = viewer.getViewForExtent(bbox);
                setCurrentViewAction(view);
            }
        }
    };
    var resolveLayerLabel = function (layerId, _) {
        var _a, _b, _c;
        var layer = (_c = (_b = (_a = map === null || map === void 0 ? void 0 : map.Layer) === null || _a === void 0 ? void 0 : _a.filter) === null || _b === void 0 ? void 0 : _b.call(_a, function (l) { return l.ObjectId == layerId; })) === null || _c === void 0 ? void 0 : _c[0];
        if (layer) {
            return layer.LegendLabel;
        }
    };
    var onShowSelectedFeature = function (layerId, selectionKey) {
        if (activeMapName) {
            showSelectedFeatureAction(activeMapName, layerId, selectionKey);
        }
    };
    var compSel = new composite_selection_1.CompositeSelection(selection === null || selection === void 0 ? void 0 : selection.SelectedFeatures, clientSelection);
    if ((selection === null || selection === void 0 ? void 0 : selection.SelectedFeatures) != null || clientSelection) {
        return React.createElement(selection_panel_1.SelectionPanel, { locale: locale, onResolveLayerLabel: resolveLayerLabel, allowHtmlValues: appContext.allowHtmlValuesInSelection(), cleanHTML: appContext.getHTMLCleaner(), selection: compSel, onRequestZoomToFeature: onZoomToSelectedFeature, onShowSelectedFeature: onShowSelectedFeature, selectedFeatureRenderer: selectedFeatureRenderer, maxHeight: maxHeight });
    }
    else {
        return React.createElement(core_1.Callout, { intent: core_1.Intent.PRIMARY, icon: "info-sign" },
            React.createElement("p", { className: "selection-panel-no-selection" }, (0, i18n_1.tr)("NO_SELECTED_FEATURES", locale)));
    }
};
exports.SelectionPanelContainer = SelectionPanelContainer;


/***/ }),

/***/ "./src/containers/share-link-to-view.tsx":
/*!***********************************************!*\
  !*** ./src/containers/share-link-to-view.tsx ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShareLinkToViewContainer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var runtime_1 = __webpack_require__(/*! ../api/runtime */ "./src/api/runtime.ts");
var react_copy_to_clipboard_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! react-copy-to-clipboard */ "./node_modules/react-copy-to-clipboard/lib/index.js"));
var url_1 = __webpack_require__(/*! ../utils/url */ "./src/utils/url.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var hooks_mapguide_1 = __webpack_require__(/*! ./hooks-mapguide */ "./src/containers/hooks-mapguide.ts");
function NOOP() { }
var ShareLinkToViewContainer = function () {
    var _a = React.useState(false), showSession = _a[0], setShowSession = _a[1];
    var locale = (0, hooks_1.useViewerLocale)();
    var map = (0, hooks_mapguide_1.useActiveMapState)();
    var onShowSessionChanged = function () { return setShowSession(!showSession); };
    var onCopied = function () {
        var v = (0, runtime_1.getViewer)();
        if (v) {
            v.toastSuccess("clipboard", (0, i18n_1.tr)("SHARE_LINK_COPIED", locale));
        }
    };
    var parsed = (0, url_1.parseUrl)("" + window.location);
    if (!showSession) {
        delete parsed.query.session;
    }
    var shareUrl = parsed.url + "?" + (0, url_1.stringifyQuery)(parsed.query);
    return React.createElement("div", null,
        React.createElement(core_1.TextArea, { fill: true, rows: 16, readOnly: true, value: shareUrl, onChange: NOOP }),
        React.createElement("br", null),
        React.createElement("div", { style: { padding: 15 } },
            map && React.createElement(core_1.Checkbox, { checked: showSession, label: (0, i18n_1.tr)("SHARE_LINK_INCLUDE_SESSION", locale), onChange: onShowSessionChanged }),
            React.createElement(react_copy_to_clipboard_1.default, { text: shareUrl, onCopy: onCopied },
                React.createElement(core_1.Button, { intent: core_1.Intent.PRIMARY }, (0, i18n_1.tr)("SHARE_LINK_COPY_CLIPBOARD", locale)))));
};
exports.ShareLinkToViewContainer = ShareLinkToViewContainer;


/***/ }),

/***/ "./src/containers/subscriber.tsx":
/*!***************************************!*\
  !*** ./src/containers/subscriber.tsx ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Subscriber = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
/**
 *
 * @param props
 * @since 0.13
 */
var Subscriber = function (props) {
    var state = (0, context_1.useAppState)(props.appStateSelector, props.appStateEqualityFn);
    React.useEffect(function () {
        props.onNewState(state);
    }, [state]);
    return React.createElement("noscript", { "data-subscriber-name": props.name });
};
exports.Subscriber = Subscriber;


/***/ }),

/***/ "./src/containers/task-pane.tsx":
/*!**************************************!*\
  !*** ./src/containers/task-pane.tsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TaskPaneContainer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var task_pane_1 = __webpack_require__(/*! ../components/task-pane */ "./src/components/task-pane.tsx");
var url_1 = __webpack_require__(/*! ../utils/url */ "./src/utils/url.ts");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var taskpane_1 = __webpack_require__(/*! ../actions/taskpane */ "./src/actions/taskpane.ts");
var flyout_1 = __webpack_require__(/*! ../actions/flyout */ "./src/actions/flyout.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var TaskPaneContainerInner = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(TaskPaneContainerInner, _super);
    function TaskPaneContainerInner(props) {
        var _this = _super.call(this, props) || this;
        _this.onCloseFlyout = function (id) { var _a, _b; return (_b = (_a = _this.props).closeFlyout) === null || _b === void 0 ? void 0 : _b.call(_a, id); };
        _this.onOpenFlyout = function (id, metrics) { var _a, _b; return (_b = (_a = _this.props).openFlyout) === null || _b === void 0 ? void 0 : _b.call(_a, id, metrics); };
        _this.onUrlLoaded = function (url) {
            var _a = _this.props, navigationStack = _a.navigationStack, navIndex = _a.navIndex, pushUrl = _a.pushUrl;
            var currentUrl = navigationStack[navIndex];
            if (!(0, url_1.areUrlsSame)(currentUrl, url)) {
                pushUrl === null || pushUrl === void 0 ? void 0 : pushUrl(url);
            }
        };
        _this.canGoHome = function () {
            var _a, _b, _c, _d, _e;
            var _f = _this.props, initialUrl = _f.initialUrl, navigationStack = _f.navigationStack, navIndex = _f.navIndex, map = _f.map;
            if (initialUrl) { //An initial URL was set
                var initUrl = ((_a = map === null || map === void 0 ? void 0 : map.mapguide) === null || _a === void 0 ? void 0 : _a.runtimeMap) && initialUrl
                    ? (0, url_1.ensureParameters)(initialUrl, (_c = (_b = map === null || map === void 0 ? void 0 : map.mapguide) === null || _b === void 0 ? void 0 : _b.runtimeMap) === null || _c === void 0 ? void 0 : _c.Name, (_e = (_d = map === null || map === void 0 ? void 0 : map.mapguide) === null || _d === void 0 ? void 0 : _d.runtimeMap) === null || _e === void 0 ? void 0 : _e.SessionId, _this.getLocale())
                    : initialUrl;
                return navigationStack.length > 0 //We have a navigation stack
                    && !(0, url_1.areUrlsSame)(navigationStack[navIndex], initUrl); //The current URL is not initial.
            }
            return false;
        };
        _this.canGoBack = function () {
            var navIndex = _this.props.navIndex;
            return navIndex > 0;
        };
        _this.canGoForward = function () {
            var _a = _this.props, navigationStack = _a.navigationStack, navIndex = _a.navIndex;
            return navIndex < navigationStack.length - 1;
        };
        var locale = _this.getLocale();
        _this.homeAction = {
            bpIconName: "home",
            tooltip: (0, i18n_1.tr)("TT_GO_HOME", locale),
            enabled: _this.canGoHome,
            invoke: function () { var _a, _b; return (_b = (_a = _this.props).goHome) === null || _b === void 0 ? void 0 : _b.call(_a); }
        };
        _this.backAction = {
            bpIconName: "arrow-left",
            tooltip: (0, i18n_1.tr)("TT_GO_BACK", locale),
            enabled: _this.canGoBack,
            invoke: function () { var _a, _b; return (_b = (_a = _this.props).goBack) === null || _b === void 0 ? void 0 : _b.call(_a); }
        };
        _this.forwardAction = {
            bpIconName: "arrow-right",
            tooltip: (0, i18n_1.tr)("TT_GO_FORWARD", locale),
            enabled: _this.canGoForward,
            invoke: function () { var _a, _b; return (_b = (_a = _this.props).goForward) === null || _b === void 0 ? void 0 : _b.call(_a); }
        };
        return _this;
    }
    TaskPaneContainerInner.prototype.getLocale = function () {
        return this.props.locale;
    };
    TaskPaneContainerInner.prototype.render = function () {
        var _this = this;
        var _a, _b, _c, _d;
        var _e = this.props, navigationStack = _e.navigationStack, navIndex = _e.navIndex, hasTaskBar = _e.hasTaskBar, lastUrlPushed = _e.lastUrlPushed, map = _e.map, maxHeight = _e.maxHeight, flyouts = _e.flyouts, isResizing = _e.isResizing;
        if (navigationStack[navIndex]) {
            var flyoutStates = {};
            if (flyouts) {
                var ids = Object.keys(flyouts);
                for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
                    var fid = ids_1[_i];
                    flyoutStates[fid] = !!flyouts[fid].open;
                }
            }
            return React.createElement("div", null,
                React.createElement(task_pane_1.TaskPane, { currentUrl: navigationStack[navIndex], showTaskBar: hasTaskBar, lastUrlPushed: lastUrlPushed, homeAction: this.homeAction, backAction: this.backAction, onOpenFlyout: this.onOpenFlyout, onCloseFlyout: this.onCloseFlyout, forwardAction: this.forwardAction, session: (_b = (_a = map === null || map === void 0 ? void 0 : map.mapguide) === null || _a === void 0 ? void 0 : _a.runtimeMap) === null || _b === void 0 ? void 0 : _b.SessionId, mapName: (_d = (_c = map === null || map === void 0 ? void 0 : map.mapguide) === null || _c === void 0 ? void 0 : _c.runtimeMap) === null || _d === void 0 ? void 0 : _d.Name, onUrlLoaded: this.onUrlLoaded, maxHeight: maxHeight, flyoutStates: flyoutStates, locale: this.getLocale() }),
                (function () {
                    if (isResizing == true) {
                        return React.createElement("div", { style: { position: "absolute", left: 0, right: 0, top: 0, bottom: 0, backgroundColor: task_pane_1.TASK_PANE_OVERLAY_BGCOLOR } },
                            React.createElement(core_1.NonIdealState, { icon: "arrows-horizontal", description: (0, i18n_1.tr)("TASK_PANE_RESIZING", _this.getLocale()) }));
                    }
                })());
        }
        return React.createElement("noscript", null);
    };
    return TaskPaneContainerInner;
}(React.Component));
var TaskPaneContainer = function (props) {
    var locale = (0, hooks_1.useViewerLocale)();
    var map = (0, hooks_1.useActiveMapBranch)();
    var flyouts = (0, hooks_1.useViewerFlyouts)();
    var initialUrl = (0, hooks_1.useTaskPaneInitialUrl)();
    var lastUrlPushed = (0, hooks_1.useTaskPaneLastUrlPushed)();
    var navIndex = (0, hooks_1.useTaskPaneNavigationIndex)();
    var navigationStack = (0, hooks_1.useTaskPaneNavigationStack)();
    var hasTaskBar = (0, hooks_1.useConfiguredCapabilities)().hasTaskBar;
    var dispatch = (0, context_1.useReduxDispatch)();
    var invokeCommandAction = function (cmd, parameters) { return dispatch((0, map_1.invokeCommand)(cmd, parameters)); };
    var goHomeAction = function () { return dispatch((0, taskpane_1.goHome)()); };
    var goForwardAction = function () { return dispatch((0, taskpane_1.goForward)()); };
    var goBackAction = function () { return dispatch((0, taskpane_1.goBack)()); };
    var pushUrlAction = function (url, silent) { return dispatch((0, taskpane_1.pushUrl)(url, silent)); };
    var openFlyoutAction = function (id, metrics) { return dispatch((0, flyout_1.openFlyout)(id, metrics)); };
    var closeFlyoutAction = function (id) { return dispatch((0, flyout_1.closeFlyout)(id)); };
    return React.createElement(TaskPaneContainerInner, (0, tslib_1.__assign)({ map: map, locale: locale, flyouts: flyouts, initialUrl: initialUrl, lastUrlPushed: lastUrlPushed, navIndex: navIndex, navigationStack: navigationStack, invokeCommand: invokeCommandAction, hasTaskBar: hasTaskBar, goHome: goHomeAction, goForward: goForwardAction, goBack: goBackAction, pushUrl: pushUrlAction, openFlyout: openFlyoutAction, closeFlyout: closeFlyoutAction }, props));
};
exports.TaskPaneContainer = TaskPaneContainer;


/***/ }),

/***/ "./src/containers/toolbar.tsx":
/*!************************************!*\
  !*** ./src/containers/toolbar.tsx ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ToolbarContainer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var command_1 = __webpack_require__(/*! ../api/registry/command */ "./src/api/registry/command.ts");
var toolbar_1 = __webpack_require__(/*! ../components/toolbar */ "./src/components/toolbar.tsx");
var menu_1 = __webpack_require__(/*! ../utils/menu */ "./src/utils/menu.ts");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var flyout_1 = __webpack_require__(/*! ../actions/flyout */ "./src/actions/flyout.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var ToolbarContainer = function (props) {
    var containerClass = props.containerClass, containerStyle = props.containerStyle, vertical = props.vertical, hideVerticalLabels = props.hideVerticalLabels;
    var dispatch = (0, context_1.useReduxDispatch)();
    var flyouts = (0, context_1.useAppState)(function (state) { return state.toolbar.flyouts; });
    var toolbar = (0, context_1.useAppState)(function (state) { return state.toolbar.toolbars[props.id]; });
    var tbState = (0, hooks_1.useReducedToolbarAppState)();
    var invokeCommandAction = function (cmd, parameters) { return dispatch((0, map_1.invokeCommand)(cmd, parameters)); };
    var openFlyoutAction = function (id, metrics) { return dispatch((0, flyout_1.openFlyout)(id, metrics)); };
    var closeFlyoutAction = function (id) { return dispatch((0, flyout_1.closeFlyout)(id)); };
    var openComponentAction = function (id, metrics, name, props) { return dispatch((0, flyout_1.openComponent)(id, metrics, name, props)); };
    var closeComponentAction = function (id) { return dispatch((0, flyout_1.closeComponent)(id)); };
    var onCloseFlyout = function (id) { return closeFlyoutAction === null || closeFlyoutAction === void 0 ? void 0 : closeFlyoutAction(id); };
    var onOpenFlyout = function (id, metrics) { return openFlyoutAction === null || openFlyoutAction === void 0 ? void 0 : openFlyoutAction(id, metrics); };
    var onOpenComponent = function (id, metrics, name, props) { return openComponentAction === null || openComponentAction === void 0 ? void 0 : openComponentAction(id, metrics, name, props); };
    var onCloseComponent = function (id) { return closeComponentAction === null || closeComponentAction === void 0 ? void 0 : closeComponentAction(id); };
    var flyoutStates = {};
    if (flyouts) {
        var ids = Object.keys(flyouts);
        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
            var fid = ids_1[_i];
            flyoutStates[fid] = !!flyouts[fid].open;
        }
    }
    var tbContainerStyle = (0, tslib_1.__assign)({}, (containerStyle || {}));
    if (toolbar && toolbar.items && invokeCommandAction) {
        if (vertical === true) {
            tbContainerStyle.width = toolbar_1.DEFAULT_TOOLBAR_SIZE;
        }
        else {
            tbContainerStyle.height = toolbar_1.DEFAULT_TOOLBAR_SIZE;
            tbContainerStyle.overflow = "auto";
        }
        var items = toolbar.items.map(function (tb) { return (0, command_1.mapToolbarReference)(tb, tbState, invokeCommandAction); });
        var childItems = (0, menu_1.processMenuItems)(items);
        return React.createElement(toolbar_1.Toolbar, { vertical: vertical, hideVerticalLabels: hideVerticalLabels, childItems: childItems, containerClass: containerClass, containerStyle: tbContainerStyle, flyoutStates: flyoutStates, onOpenComponent: onOpenComponent, onCloseComponent: onCloseComponent, onOpenFlyout: onOpenFlyout, onCloseFlyout: onCloseFlyout });
    }
    else {
        return React.createElement("div", null);
    }
};
exports.ToolbarContainer = ToolbarContainer;


/***/ }),

/***/ "./src/containers/url-state.ts":
/*!*************************************!*\
  !*** ./src/containers/url-state.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getStateFromUrl = exports.updateUrl = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var url_1 = __webpack_require__(/*! ../utils/url */ "./src/utils/url.ts");
var S_DELIM = "_"; //This is the current layer/group name delimiter
/**
 * Updates the main URL with the given application state. If passing extra custom state,
 * this extra custom state is also included when getStateFromUrl() is called.
 *
 * Also if the custom state shares the same keys as the main application state, the application
 * state takes precedence (ie. The key/value in the custom state *will not* overwrite the application state for the same key).
 *
 * To avoid this, you should delete/omit said keys from the application state when calling this method if
 * you want to take the equivalent key/value from the custom state.
 *
 * @export
 * @param {IAppUrlState} state
 * @param {*} [extraState] Any extra state to include into the main URL
 * @rem
 * @since 0.13
 * @since 0.14 - New optional extraState argument
 */
function updateUrl(state, extraState) {
    var st = (0, tslib_1.__assign)({}, extraState);
    for (var k in state) {
        var val = state[k];
        switch (k) {
            case "ft":
                st.ft = (val == true) ? 1 : 0;
                break;
            case "sl":
                st.sl = val === null || val === void 0 ? void 0 : val.join(S_DELIM);
                break;
            case "hl":
                st.hl = val === null || val === void 0 ? void 0 : val.join(S_DELIM);
                break;
            case "sg":
                st.sg = val === null || val === void 0 ? void 0 : val.join(S_DELIM);
                break;
            case "hg":
                st.hg = val === null || val === void 0 ? void 0 : val.join(S_DELIM);
                break;
            default:
                st[k] = val;
                break;
        }
    }
    var url = (0, url_1.appendParameters)(window.location.href, st, true, false);
    window.history.replaceState(st, "", url);
}
exports.updateUrl = updateUrl;
/**
 * Gets the application state from the current main URL. If the URL was updated with custom state
 * via updateUrl(), they will also be included in the returned state.
 *
 * @export
 * @param {string[]} [ignoreKeys]
 * @returns {IAppUrlState}
 * @since 0.13
 * @since 0.14 - New optional ignoreKeys to avoid reading out certain properties from URL state
 */
function getStateFromUrl(ignoreKeys) {
    var st = (0, url_1.parseUrlParameters)(window.location.href);
    var state = {};
    var ignore = ignoreKeys !== null && ignoreKeys !== void 0 ? ignoreKeys : [];
    for (var k in st) {
        if (ignore.indexOf(k) >= 0) {
            continue;
        }
        var val = st[k];
        switch (k) {
            case "ft":
                {
                    var n = parseInt(val, 10);
                    if (!isNaN(n)) {
                        state.ft = (n == 0) ? false : true;
                    }
                }
                break;
            case "x":
                {
                    var n = parseFloat(val);
                    if (!isNaN(n)) {
                        state.x = n;
                    }
                }
                break;
            case "y":
                {
                    var n = parseFloat(val);
                    if (!isNaN(n)) {
                        state.y = n;
                    }
                }
                break;
            case "scale":
                {
                    var n = parseFloat(val);
                    if (!isNaN(n)) {
                        state.scale = n;
                    }
                }
                break;
            case "sl":
                state.sl = val === null || val === void 0 ? void 0 : val.split(S_DELIM);
                break;
            case "hl":
                state.hl = val === null || val === void 0 ? void 0 : val.split(S_DELIM);
                break;
            case "sg":
                state.sg = val === null || val === void 0 ? void 0 : val.split(S_DELIM);
                break;
            case "hg":
                state.hg = val === null || val === void 0 ? void 0 : val.split(S_DELIM);
                break;
            default:
                state[k] = val;
                break;
        }
    }
    return state;
}
exports.getStateFromUrl = getStateFromUrl;


/***/ }),

/***/ "./src/containers/view-size.tsx":
/*!**************************************!*\
  !*** ./src/containers/view-size.tsx ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViewSizeContainer = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var view_size_1 = __webpack_require__(/*! ../components/view-size */ "./src/components/view-size.tsx");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var hooks_mapguide_1 = __webpack_require__(/*! ./hooks-mapguide */ "./src/containers/hooks-mapguide.ts");
var ViewSizeContainer = function () {
    var width = (0, hooks_1.useActiveMapWidth)();
    var height = (0, hooks_1.useActiveMapHeight)();
    var sizeUnits = (0, hooks_1.useViewerSizeUnits)();
    var metersPerUnit = (0, hooks_mapguide_1.useActiveMapMetersPerUnit)();
    var view = (0, hooks_1.useActiveMapView)();
    var locale = (0, hooks_1.useViewerLocale)();
    if (width && height && metersPerUnit && view) {
        return React.createElement(view_size_1.ViewSize, { locale: locale, width: width, height: height, view: view, metersPerUnit: metersPerUnit, units: sizeUnits || common_1.UnitOfMeasure.Unknown });
    }
    else {
        return React.createElement("noscript", null);
    }
};
exports.ViewSizeContainer = ViewSizeContainer;


/***/ }),

/***/ "./src/containers/viewer-options.tsx":
/*!*******************************************!*\
  !*** ./src/containers/viewer-options.tsx ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViewerOptions = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var units_1 = __webpack_require__(/*! ../utils/units */ "./src/utils/units.tsx");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var hooks_mapguide_1 = __webpack_require__(/*! ./hooks-mapguide */ "./src/containers/hooks-mapguide.ts");
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var ViewerOptions = function () {
    var externalBaseLayers = (0, hooks_1.useActiveMapExternalBaseLayers)(false);
    var mapName = (0, hooks_1.useActiveMapName)();
    var layerTransparency = (0, hooks_mapguide_1.useActiveMapLayerTransparency)();
    var featureTooltipsEnabled = (0, hooks_1.useViewerFeatureTooltipsEnabled)();
    var selectDragPanEnabled = (0, hooks_1.useViewerSelectCanDragPan)();
    var manualFeatureTooltips = (0, hooks_1.useConfiguredManualFeatureTooltips)();
    var viewSizeUnits = (0, hooks_1.useViewerSizeUnits)();
    var stateless = (0, hooks_1.useViewerIsStateless)();
    var map = (0, hooks_mapguide_1.useActiveMapState)();
    var locale = (0, hooks_1.useViewerLocale)();
    var dispatch = (0, context_1.useReduxDispatch)();
    var toggleManualMapTipsAction = function (enabled) { return dispatch((0, map_1.setManualFeatureTooltipsEnabled)(enabled)); };
    var toggleMapTipsAction = function (enabled) { return dispatch((0, map_1.setFeatureTooltipsEnabled)(enabled)); };
    var toggleSelectDragPanAction = function (enabled) { return dispatch((0, map_1.enableSelectDragPan)(enabled)); };
    var setLayerTransparencyAction = function (mapName, id, opacity) { return dispatch((0, map_1.setLayerTransparency)(mapName, id, opacity)); };
    var setViewSizeDisplayUnitsAction = function (units) { return dispatch((0, map_1.setViewSizeUnits)(units)); };
    var onMgLayerOpacityChanged = function (mapName, layerId, value) {
        if (mapName) {
            setLayerTransparencyAction === null || setLayerTransparencyAction === void 0 ? void 0 : setLayerTransparencyAction(mapName, layerId, value);
        }
    };
    var onBaseOpacityChanged = function (value) {
        onMgLayerOpacityChanged(mapName, constants_1.LAYER_ID_BASE, value);
    };
    var onMgOpacityChanged = function (value) {
        onMgLayerOpacityChanged(mapName, constants_1.LAYER_ID_MG_BASE, value);
    };
    var onMgSelOpacityChanged = function (value) {
        onMgLayerOpacityChanged(mapName, constants_1.LAYER_ID_MG_SEL_OVERLAY, value);
    };
    var onViewSizeUnitsChanged = function (e) {
        setViewSizeDisplayUnitsAction(e.target.value);
    };
    var onFeatureTooltipsChanged = function (e) {
        toggleMapTipsAction(e.target.checked);
    };
    var onSelectDragPanEnabled = function (e) {
        toggleSelectDragPanAction(e.target.checked);
    };
    var onManualFeatureTooltipsChanged = function (e) {
        toggleManualMapTipsAction(e.target.checked);
    };
    var units = (0, units_1.getUnits)();
    var opBase = 1.0;
    var opMgBase = 1.0;
    var opMgSelOverlay = 1.0;
    if (layerTransparency) {
        if (constants_1.LAYER_ID_BASE in layerTransparency) {
            opBase = layerTransparency[constants_1.LAYER_ID_BASE];
        }
        if (constants_1.LAYER_ID_MG_BASE in layerTransparency) {
            opMgBase = layerTransparency[constants_1.LAYER_ID_MG_BASE];
        }
        if (constants_1.LAYER_ID_MG_SEL_OVERLAY in layerTransparency) {
            opMgSelOverlay = layerTransparency[constants_1.LAYER_ID_MG_SEL_OVERLAY];
        }
    }
    var isStateless = stateless;
    if (!map) {
        isStateless = true;
    }
    return React.createElement("div", { className: "component-viewer-options" },
        React.createElement("h5", null, (0, i18n_1.tr)("VIEWER_OPTIONS", locale)),
        React.createElement("hr", null),
        !isStateless && React.createElement("label", { className: "bp3-control bp3-switch" },
            React.createElement("input", { type: "checkbox", checked: featureTooltipsEnabled, onChange: onFeatureTooltipsChanged }),
            React.createElement("span", { className: "bp3-control-indicator" }),
            (0, i18n_1.tr)("FEATURE_TOOLTIPS", locale)),
        (function () {
            if (!isStateless && featureTooltipsEnabled) {
                return React.createElement("label", { className: "bp3-control bp3-switch" },
                    React.createElement("input", { type: "checkbox", checked: manualFeatureTooltips, onChange: onManualFeatureTooltipsChanged }),
                    React.createElement("span", { className: "bp3-control-indicator" }),
                    (0, i18n_1.tr)("MANUAL_FEATURE_TOOLTIPS", locale));
            }
        })(),
        React.createElement("label", { className: "bp3-control bp3-switch" },
            React.createElement("input", { type: "checkbox", checked: selectDragPanEnabled, onChange: onSelectDragPanEnabled }),
            React.createElement("span", { className: "bp3-control-indicator" }),
            (0, i18n_1.tr)("ENABLE_SELECT_DRAGPAN", locale)),
        React.createElement("fieldset", null,
            React.createElement("legend", null, (0, i18n_1.tr)("LAYER_TRANSPARENCY", locale)),
            (function () {
                if (externalBaseLayers) {
                    return React.createElement("label", { className: "bp3-label noselect" },
                        (0, i18n_1.tr)("LAYER_ID_BASE", locale),
                        React.createElement("div", { style: { paddingLeft: 8, paddingRight: 8 } },
                            React.createElement(core_1.Slider, { min: 0, max: 1.0, stepSize: 0.01, value: opBase, onChange: onBaseOpacityChanged })));
                }
            })(),
            React.createElement("label", { className: "bp3-label noselect" },
                map ? (0, i18n_1.tr)("LAYER_ID_MG_BASE", locale) : (0, i18n_1.tr)("LAYER_ID_SUBJECT", locale),
                React.createElement("div", { style: { paddingLeft: 8, paddingRight: 8 } },
                    React.createElement(core_1.Slider, { min: 0, max: 1.0, stepSize: 0.01, value: opMgBase, onChange: onMgOpacityChanged }))),
            !isStateless && React.createElement("label", { className: "bp3-label noselect" },
                (0, i18n_1.tr)("LAYER_ID_MG_SEL_OVERLAY", locale),
                React.createElement("div", { style: { paddingLeft: 8, paddingRight: 8 } },
                    React.createElement(core_1.Slider, { min: 0, max: 1.0, stepSize: 0.01, value: opMgSelOverlay, onChange: onMgSelOpacityChanged })))),
        React.createElement("label", { className: "bp3-label" },
            (0, i18n_1.tr)("MAP_SIZE_DISPLAY_UNITS", locale),
            React.createElement("div", { className: "bp3-select" },
                React.createElement(core_1.HTMLSelect, { value: viewSizeUnits, onChange: onViewSizeUnitsChanged }, units.map(function (u) {
                    var uom = u[0];
                    var ui = (0, units_1.getUnitOfMeasure)(uom);
                    return React.createElement("option", { key: uom, value: uom }, ui.localizedName(locale));
                })))));
};
exports.ViewerOptions = ViewerOptions;


/***/ }),

/***/ "./src/containers/viewer-shim.tsx":
/*!****************************************!*\
  !*** ./src/containers/viewer-shim.tsx ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViewerApiShim = exports.AjaxViewerMapActionCode = exports.AjaxViewerLineStringOrPolygon = exports.enableRedlineMessagePrompt = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var extent_1 = __webpack_require__(/*! ol/extent */ "./node_modules/ol/extent.js");
var Point_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/Point */ "./node_modules/ol/geom/Point.js"));
var LineString_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/LineString */ "./node_modules/ol/geom/LineString.js"));
var Polygon_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/geom/Polygon */ "./node_modules/ol/geom/Polygon.js"));
var client_1 = __webpack_require__(/*! ../api/client */ "./src/api/client.ts");
var error_1 = __webpack_require__(/*! ../api/error */ "./src/api/error.ts");
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var deArrayify_1 = __webpack_require__(/*! ../api/builders/deArrayify */ "./src/api/builders/deArrayify.ts");
var form_frame_shim_1 = __webpack_require__(/*! ../components/form-frame-shim */ "./src/components/form-frame-shim.tsx");
var command_1 = __webpack_require__(/*! ../api/registry/command */ "./src/api/registry/command.ts");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var mapagent_1 = __webpack_require__(/*! ../api/builders/mapagent */ "./src/api/builders/mapagent.ts");
var units_1 = __webpack_require__(/*! ../utils/units */ "./src/utils/units.tsx");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/containers/hooks.ts");
var runtime_1 = __webpack_require__(/*! ../api/runtime */ "./src/api/runtime.ts");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var legend_1 = __webpack_require__(/*! ../actions/legend */ "./src/actions/legend.ts");
var taskpane_1 = __webpack_require__(/*! ../actions/taskpane */ "./src/actions/taskpane.ts");
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
var hooks_mapguide_1 = __webpack_require__(/*! ./hooks-mapguide */ "./src/containers/hooks-mapguide.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
function isEmptySelection(selection) {
    if (selection && selection.FeatureSet) {
        var count = 0;
        for (var _i = 0, _a = selection.FeatureSet.Layer; _i < _a.length; _i++) {
            var l = _a[_i];
            count += l.Class.ID.length;
        }
        return count === 0;
    }
    return true; //Treat undefined/null as empty
}
/**
 * This class emulates a subset of the Fusion API. This represents the top-level object named "Fusion"
 */
var FusionApiShim = /** @class */ (function () {
    function FusionApiShim(parent) {
        this.parent = parent;
        this.Event = new FusionEventApiShim();
    }
    FusionApiShim.prototype.xml2json = function (callback, response, json) {
        if (json) {
            var o = JSON.parse(response.responseText);
            callback(o);
        }
        else {
            var options = {
                onSuccess: callback,
                method: 'POST',
                parameters: { 'xml': encodeURIComponent(response.responseText) }
            };
            this.ajaxRequest('common/php/Xml2JSON.php', options);
        }
    };
    FusionApiShim.prototype.ajaxRequest = function (url, options) {
        var reqUrl = (0, runtime_1.getFusionRoot)() + "/" + url;
        var client = this.parent.getClient();
        var resolve = options.onSuccess || (function () { return (0, logger_1.debug)("No success handler defined for this operation"); });
        var fail = options.onFailure || options.onException || (function (_r, res) { return (0, logger_1.error)(res); });
        if (client) {
            if (typeof (options.parameters) == 'string') {
                reqUrl += "?" + options.parameters;
                fetch(reqUrl, {
                    method: "GET"
                }).then(function (res) {
                    if (!res.ok) {
                        var stat_1 = res.statusText;
                        res.text().then(function (t) {
                            fail({
                                transport: {
                                    responseText: t
                                }
                            }, new error_1.MgError(stat_1));
                        });
                    }
                    else {
                        res.text().then(function (t) { return resolve({
                            responseText: t
                        }); });
                    }
                });
            }
            else {
                fetch(reqUrl, {
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
                    },
                    method: "POST",
                    body: (0, mapagent_1.serialize)(options.parameters, false) //form
                }).then(function (res) {
                    if (!res.ok) {
                        var stat_2 = res.statusText;
                        res.text().then(function (t) {
                            fail({
                                transport: {
                                    responseText: t
                                }
                            }, new error_1.MgError(stat_2));
                        });
                    }
                    else {
                        res.text().then(function (t) { return resolve({
                            responseText: t
                        }); });
                    }
                });
            }
        }
    };
    FusionApiShim.prototype.getMapByName = function (name) {
        if (this.parent.props.map && this.parent.props.map.Name == name) {
            return new FusionWidgetApiShim(this.parent);
        }
        return undefined;
    };
    FusionApiShim.prototype.getWidgetById = function (id) {
        if (id == constants_1.FUSION_TASKPANE_NAME ||
            id == constants_1.FUSION_MAP_NAME) {
            return new FusionWidgetApiShim(this.parent);
        }
        return undefined;
    };
    FusionApiShim.prototype.getWidgetsByType = function (type) {
        if (type == constants_1.FUSION_REDLINE_NAME) {
            return [
                new FusionWidgetApiShim(this.parent)
            ];
        }
        return [];
    };
    FusionApiShim.prototype.registerForEvent = function (eventID, callback) {
        this.parent.registerForEvent(eventID, callback);
    };
    return FusionApiShim;
}());
/**
 * This class emulates the OpenLayers.Function.bind helper
 */
var OL2FunctionHelper = /** @class */ (function () {
    function OL2FunctionHelper() {
    }
    OL2FunctionHelper.prototype.bind = function (func, obj_this) {
        return func.bind(obj_this);
    };
    return OL2FunctionHelper;
}());
/**
 * This class emulates a subset of the OpenLayers 2 API
 */
var OL2Shim = /** @class */ (function () {
    function OL2Shim() {
        this.Function = new OL2FunctionHelper();
    }
    OL2Shim.prototype.i18n = function (key) {
        return (0, i18n_1.tr)(key);
    };
    return OL2Shim;
}());
/**
 * This class emulates event constants defined by Fusion
 */
var FusionEventApiShim = /** @class */ (function () {
    function FusionEventApiShim() {
    }
    Object.defineProperty(FusionEventApiShim.prototype, "MAP_SELECTION_ON", {
        get: function () { return 1; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FusionEventApiShim.prototype, "MAP_SELECTION_OFF", {
        get: function () { return 2; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FusionEventApiShim.prototype, "MAP_ACTIVE_LAYER_CHANGED", {
        get: function () { return 3; },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FusionEventApiShim.prototype, "MAP_BUSY_CHANGED", {
        get: function () { return 4; },
        enumerable: false,
        configurable: true
    });
    return FusionEventApiShim;
}());
/**
 * This class emulates a digitized rectangle
 */
var OL2Rect = /** @class */ (function () {
    function OL2Rect(poly) {
        this.poly = poly;
    }
    OL2Rect.prototype.getVertices = function () {
        var coords = this.poly.getExtent();
        return [
            { x: coords[0], y: coords[1] },
            undefined,
            { x: coords[2], y: coords[3] } //2
        ];
    };
    return OL2Rect;
}());
/**
 * This class emulates an OpenLayers 2 geometry
 */
var OL2Geom = /** @class */ (function () {
    function OL2Geom(geom) {
        this.geom = geom;
    }
    Object.defineProperty(OL2Geom.prototype, "x", {
        get: function () {
            var g = this.geom;
            if (g instanceof Point_1.default) {
                return g.getCoordinates()[0];
            }
            return NaN;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(OL2Geom.prototype, "y", {
        get: function () {
            var g = this.geom;
            if (g instanceof Point_1.default) {
                return g.getCoordinates()[1];
            }
            return NaN;
        },
        enumerable: false,
        configurable: true
    });
    OL2Geom.prototype.getVertices = function () {
        var g = this.geom;
        if (g instanceof Point_1.default) {
        }
        else if (g instanceof LineString_1.default) {
            return g.getCoordinates().map(function (c) {
                return { x: c[0], y: c[1] };
            });
        }
        else if (g instanceof Polygon_1.default) {
            return g.getLinearRing(0).getCoordinates().map(function (c) {
                return { x: c[0], y: c[1] };
            });
        }
        return [];
    };
    Object.defineProperty(OL2Geom.prototype, "CLASS_NAME", {
        get: function () {
            if (this.geom instanceof Point_1.default) {
                return "OpenLayers.Geometry.Point";
            }
            else if (this.geom instanceof LineString_1.default) {
                return "OpenLayers.Geometry.LineString";
            }
            else if (this.geom instanceof Polygon_1.default) {
                return "OpenLayers.Geometry.Polygon";
            }
            else {
                return "Unknown";
            }
        },
        enumerable: false,
        configurable: true
    });
    return OL2Geom;
}());
/**
 * This class emulates OpenLayers.Bounds
 */
var OL2Bounds = /** @class */ (function () {
    function OL2Bounds(bounds) {
        if (Array.isArray(bounds)) {
            this.left = bounds[0];
            this.bottom = bounds[1];
            this.right = bounds[2];
            this.top = bounds[3];
        }
        else {
            this.left = bounds.left;
            this.bottom = bounds.bottom;
            this.right = bounds.right;
            this.top = bounds.top;
        }
    }
    return OL2Bounds;
}());
var mRedlineMessageEnabled;
/**
 * @hidden
 */
function isRedlineMessagePromptEnabled() {
    return !!mRedlineMessageEnabled;
}
/**
 * @hidden
 */
function enableRedlineMessagePrompt(enabled) {
    mRedlineMessageEnabled = enabled;
}
exports.enableRedlineMessagePrompt = enableRedlineMessagePrompt;
/**
 * This class emulates APIs from various widgets
 */
var FusionWidgetApiShim = /** @class */ (function () {
    function FusionWidgetApiShim(parent) {
        this.parent = parent;
    }
    FusionWidgetApiShim.prototype.goHome = function () {
        this.parent.goHome();
    };
    FusionWidgetApiShim.prototype.processFeatureInfo = function (r) {
        var o = JSON.parse(r.responseText);
        if (o.FeatureInformation) {
            var norm = (0, deArrayify_1.deArrayify)(o);
            if ((0, deArrayify_1.isQueryMapFeaturesResponse)(norm)) {
                var selXml = (0, deArrayify_1.buildSelectionXml)(norm.FeatureSet);
                this.setSelection(selXml, false);
            }
        }
        else if (o.Message) {
            this.warn(o.Message);
        }
    };
    FusionWidgetApiShim.prototype.getSelectableLayers = function () {
        var layers = [];
        var map = this.parent.props.map;
        if (map && map.Layer) {
            var matches = map.Layer
                .filter(function (l) { return l.Selectable; })
                .map(function (l) {
                return { layerName: l.Name, legendLabel: l.LegendLabel };
            });
            for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {
                var l = matches_1[_i];
                layers.push(l);
            }
        }
        return layers;
    };
    Object.defineProperty(FusionWidgetApiShim.prototype, "mapWidget", {
        get: function () {
            return this;
        },
        enumerable: false,
        configurable: true
    });
    FusionWidgetApiShim.prototype.getExtentFromPoint = function (x, y, scale) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            var view = viewer.getCurrentView();
            if (!scale) {
                scale = view.scale;
            }
            var res = viewer.scaleToResolution(scale);
            var size = viewer.getSize();
            var w = size[0] * res;
            var h = size[1] * res;
            return new OL2Bounds([
                x - w / 2,
                y - h / 2,
                x + w / 2,
                y + h / 2
            ]);
        }
        return undefined;
    };
    FusionWidgetApiShim.prototype.setExtents = function (bounds) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            viewer.zoomToExtent([bounds.left, bounds.bottom, bounds.right, bounds.top]);
        }
    };
    FusionWidgetApiShim.prototype.setActiveLayer = function (layer) {
        this._activeLayer = layer;
        var fusionAPI = this.parent.getFusionAPI();
        this.parent.triggerFusionEvent(fusionAPI.Event.MAP_ACTIVE_LAYER_CHANGED);
    };
    FusionWidgetApiShim.prototype.getActiveLayer = function () {
        return this._activeLayer;
    };
    FusionWidgetApiShim.prototype.clearSelection = function () {
        this.parent.ClearSelection();
    };
    FusionWidgetApiShim.prototype.cancelDigitization = function () {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            viewer.cancelDigitization();
        }
    };
    FusionWidgetApiShim.prototype.query = function (options) {
        var _a;
        var viewer = (_a = (0, runtime_1.getViewer)()) === null || _a === void 0 ? void 0 : _a.mapguideSupport();
        var map = this.parent.props.map;
        if (map && viewer) {
            var mapName = map.Name;
            var qmo = {
                mapname: mapName,
                session: map.SessionId,
                selectionvariant: options.selectionType,
                maxfeatures: options.maxFeatures,
                geometry: options.geometry,
                layernames: options.layers
            };
            if (qmo.maxfeatures == 0) {
                qmo.maxfeatures = -1;
            }
            viewer.setSelectionXml("", qmo);
        }
    };
    FusionWidgetApiShim.prototype.setSelection = function (xml, zoomTo) {
        var _this = this;
        var viewer = (0, runtime_1.getViewer)();
        var mgSupport = viewer === null || viewer === void 0 ? void 0 : viewer.mapguideSupport();
        if (viewer && mgSupport) {
            mgSupport.setSelectionXml(xml, {
                layerattributefilter: 0 //Need to set this in order for requestdata to be respected
            }, function (selection) {
                if (zoomTo) {
                    var fact_1 = viewer.getOLFactory();
                    var bounds_1 = null;
                    if (selection != null && selection.SelectedFeatures != null) {
                        selection.SelectedFeatures.SelectedLayer.forEach(function (layer) {
                            layer.Feature.forEach(function (feat) {
                                if (feat.Bounds) {
                                    var b = feat.Bounds.split(" ").map(function (s) { return parseFloat(s); });
                                    if (bounds_1 == null) {
                                        bounds_1 = b;
                                    }
                                    else {
                                        bounds_1 = fact_1.extendExtent(bounds_1, b);
                                    }
                                }
                            });
                        });
                    }
                    if (bounds_1) {
                        var bw = (0, extent_1.getWidth)(bounds_1);
                        var bh = (0, extent_1.getHeight)(bounds_1);
                        if (bw > 0 && bh > 0) { //Don't zoom if we get 0 bounds. Cruncing bounds from selected points would do this.
                            var view = viewer.getViewForExtent(bounds_1);
                            _this.parent.ZoomToView(view.x, view.y, view.scale);
                        }
                    }
                }
            });
        }
    };
    FusionWidgetApiShim.prototype.getSelectedLayers = function () {
        var layers = [];
        var map = this.parent.props.map;
        var selectionSet = this.parent.props.selectionSet;
        if (map && map.Layer && selectionSet && selectionSet.FeatureSet) {
            var _loop_1 = function (fl) {
                var ml = map.Layer.filter(function (l) { return l.ObjectId == fl["@id"]; })[0];
                if (ml) {
                    layers.push({ legendLabel: ml.LegendLabel, layerName: ml.Name });
                }
            };
            for (var _i = 0, _a = selectionSet.FeatureSet.Layer; _i < _a.length; _i++) {
                var fl = _a[_i];
                _loop_1(fl);
            }
        }
        return layers;
    };
    FusionWidgetApiShim.prototype.isBusy = function () {
        if (this.parent.props.busyCount)
            return this.parent.props.busyCount > 0;
        return false;
    };
    FusionWidgetApiShim.prototype.isMapLoaded = function () {
        return true;
    };
    FusionWidgetApiShim.prototype.redraw = function () {
        this.parent.Refresh();
    };
    FusionWidgetApiShim.prototype.reloadMap = function () {
        this.parent.Refresh();
    };
    FusionWidgetApiShim.prototype.info = function (msg) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            this._activeToast = viewer.toastPrimary("info-sign", React.createElement("div", { className: "mg-fusion-message", dangerouslySetInnerHTML: { __html: msg } }));
        }
    };
    FusionWidgetApiShim.prototype.warn = function (msg) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            this._activeToast = viewer.toastPrimary("warning-sign", React.createElement("div", { className: "mg-fusion-message", dangerouslySetInnerHTML: { __html: msg } }));
        }
    };
    FusionWidgetApiShim.prototype.error = function (msg) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            this._activeToast = viewer.toastPrimary("error", React.createElement("div", { className: "mg-fusion-message", dangerouslySetInnerHTML: { __html: msg } }));
        }
    };
    FusionWidgetApiShim.prototype.clear = function () {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer && this._activeToast) {
            viewer.dismissToast(this._activeToast);
        }
    };
    Object.defineProperty(FusionWidgetApiShim.prototype, "mapMessagePrompt", {
        get: function () {
            return isRedlineMessagePromptEnabled();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FusionWidgetApiShim.prototype, "container", {
        get: function () {
            return this;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FusionWidgetApiShim.prototype, "ownerDocument", {
        get: function () {
            return document;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FusionWidgetApiShim.prototype, "message", {
        get: function () {
            return this;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FusionWidgetApiShim.prototype, "layerRoot", {
        get: function () {
            return this;
        },
        enumerable: false,
        configurable: true
    });
    FusionWidgetApiShim.prototype.findLayerByAttribute = function (name, value) {
        var map = this.parent.props.map;
        if (map && map.Layer) {
            var ml = map.Layer.filter(function (lyr) {
                switch (name) {
                    case "layerName":
                        return lyr.Name == value;
                }
                return false;
            })[0];
            if (ml) {
                return { layerName: ml.Name };
            }
        }
        return null;
    };
    FusionWidgetApiShim.prototype.pixToGeoMeasure = function (tolerance) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            var res = viewer.getResolution();
            if (res) {
                return tolerance * res;
            }
        }
        return 0.000001; //Pull some random number
    };
    FusionWidgetApiShim.prototype.drawMap = function () {
        this.parent.Refresh();
    };
    FusionWidgetApiShim.prototype.registerForEvent = function (eventID, callback) {
        this.parent.registerForEvent(eventID, callback);
    };
    FusionWidgetApiShim.prototype.deregisterForEvent = function (eventID, callback) {
        this.parent.deregisterForEvent(eventID, callback);
    };
    FusionWidgetApiShim.toOL2Circle = function (circ) {
        var c = circ.getCenter();
        return {
            x: c[0],
            y: c[1],
            r: circ.getRadius()
        };
    };
    FusionWidgetApiShim.prototype.digitizePoint = function (_options, handler) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            viewer.digitizePoint(function (pt) {
                handler(new OL2Geom(pt));
            });
        }
    };
    FusionWidgetApiShim.prototype.digitizeLine = function (_options, handler) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            viewer.digitizeLine(function (ln) {
                handler(new OL2Geom(ln));
            });
        }
    };
    FusionWidgetApiShim.prototype.digitizeLineString = function (_options, handler) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            viewer.digitizeLineString(function (lstr) {
                handler(new OL2Geom(lstr));
            });
        }
    };
    FusionWidgetApiShim.prototype.digitizeRectangle = function (_options, handler) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            viewer.digitizeRectangle(function (rect) {
                handler(new OL2Rect(rect));
            });
        }
    };
    FusionWidgetApiShim.prototype.digitizePolygon = function (_options, handler) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            viewer.digitizePolygon(function (poly) {
                handler(new OL2Geom(poly));
            });
        }
    };
    FusionWidgetApiShim.prototype.digitizeCircle = function (_options, handler) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            viewer.digitizeCircle(function (circ) {
                handler(FusionWidgetApiShim.toOL2Circle(circ));
            });
        }
    };
    return FusionWidgetApiShim;
}());
var AjaxViewerLineStringOrPolygon = /** @class */ (function () {
    function AjaxViewerLineStringOrPolygon(coordinates) {
        this.coordinates = coordinates;
    }
    Object.defineProperty(AjaxViewerLineStringOrPolygon.prototype, "Count", {
        get: function () { return this.coordinates.length; },
        enumerable: false,
        configurable: true
    });
    AjaxViewerLineStringOrPolygon.prototype.Point = function (i) {
        var pt = this.coordinates[i];
        return pt;
    };
    return AjaxViewerLineStringOrPolygon;
}());
exports.AjaxViewerLineStringOrPolygon = AjaxViewerLineStringOrPolygon;
var AjaxViewerMapActionCode;
(function (AjaxViewerMapActionCode) {
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["PanMode"] = 1] = "PanMode";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["PanUp"] = 2] = "PanUp";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["PanDown"] = 3] = "PanDown";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["PanRight"] = 4] = "PanRight";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["PanLeft"] = 5] = "PanLeft";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["ZoomMode"] = 6] = "ZoomMode";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["ZoomIn"] = 7] = "ZoomIn";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["ZoomOut"] = 8] = "ZoomOut";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["ZoomRect"] = 9] = "ZoomRect";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["ZoomSelection"] = 10] = "ZoomSelection";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["ZoomExtents"] = 11] = "ZoomExtents";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["PrevView"] = 12] = "PrevView";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["NextView"] = 13] = "NextView";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["InitialView"] = 14] = "InitialView";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["SelectionMode"] = 15] = "SelectionMode";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["SelectRadius"] = 16] = "SelectRadius";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["SelectPolygon"] = 17] = "SelectPolygon";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["ClearSelection"] = 19] = "ClearSelection";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["RefreshMap"] = 20] = "RefreshMap";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["CopyMap"] = 21] = "CopyMap";
    AjaxViewerMapActionCode[AjaxViewerMapActionCode["About"] = 22] = "About";
})(AjaxViewerMapActionCode = exports.AjaxViewerMapActionCode || (exports.AjaxViewerMapActionCode = {}));
/**
 * This component installs a AJAX/Fusion viewer API compatibility layer when mounted allowing for existing
 * script content to work against this viewer.
 *
 * @export
 * @class ViewerApiShim
 * @extends {React.Component<ViewerApiShimProps, any>}
 */
var ViewerApiShimInner = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(ViewerApiShimInner, _super);
    function ViewerApiShimInner(props) {
        var _this = _super.call(this, props) || this;
        _this.onFormFrameMounted = function (form) {
            _this.formFrame = form;
        };
        _this.GetMapName = function () { var _a; return (_a = _this.props.map) === null || _a === void 0 ? void 0 : _a.Name; };
        _this.GetSessionId = function () { var _a; return (_a = _this.props.map) === null || _a === void 0 ? void 0 : _a.SessionId; };
        _this.goHome = function () { var _a, _b; return (_b = (_a = _this.props).goHome) === null || _b === void 0 ? void 0 : _b.call(_a); };
        _this.us = true;
        _this.userSelectionHandlers = [];
        _this.fusionEventHandlers = {};
        _this.ol2API = new OL2Shim();
        _this.fusionAPI = new FusionApiShim(_this);
        return _this;
    }
    ViewerApiShimInner.prototype.getClient = function () {
        var _a = this.props, agentUri = _a.agentUri, agentKind = _a.agentKind;
        if (agentUri && agentKind) {
            return new client_1.Client(agentUri, agentKind);
        }
        return undefined;
    };
    // ------------------------ Fusion API support ----------------------- //
    ViewerApiShimInner.prototype.getFusionAPI = function () {
        return this.fusionAPI;
    };
    ViewerApiShimInner.prototype.registerForEvent = function (eventID, callback) {
        (0, logger_1.debug)("Fusion registerForEvent - " + eventID);
        if (!this.fusionEventHandlers[eventID]) {
            this.fusionEventHandlers[eventID] = [];
        }
        this.fusionEventHandlers[eventID].push(callback);
    };
    ViewerApiShimInner.prototype.deregisterForEvent = function (eventID, callback) {
        (0, logger_1.debug)("Fusion deregisterForEvent - " + eventID);
        if (this.fusionEventHandlers[eventID]) {
            var funcs = this.fusionEventHandlers[eventID].filter(function (f) { return f != callback; });
            this.fusionEventHandlers[eventID] = funcs;
        }
        else {
            (0, logger_1.debug)("No callbacks registered for fusion event - " + eventID);
        }
    };
    ViewerApiShimInner.prototype.triggerFusionEvent = function (eventID) {
        if (this.fusionEventHandlers[eventID]) {
            (0, logger_1.debug)("Trigger Fusion Event ID - " + eventID);
            for (var _i = 0, _a = this.fusionEventHandlers[eventID]; _i < _a.length; _i++) {
                var cb = _a[_i];
                cb.apply(null, arguments);
            }
        }
    };
    ViewerApiShimInner.prototype.fusionSelectionHandler = function (selection) {
        var eventID = isEmptySelection(selection) ? this.fusionAPI.Event.MAP_SELECTION_OFF : this.fusionAPI.Event.MAP_SELECTION_ON;
        this.triggerFusionEvent(eventID);
    };
    Object.defineProperty(ViewerApiShimInner.prototype, "mapInit", {
        // ------------------------ Map Frame -------------------------------- //
        /**
         * Indicates if the map frame is ready
         *
         * Although this not part of the "public" API, most AJAX viewer examples test for this
         * flag anyways, so we might as well emulate it here
         */
        get: function () { var _a; return ((_a = this.props.map) === null || _a === void 0 ? void 0 : _a.SessionId) != null; },
        enumerable: false,
        configurable: true
    });
    ViewerApiShimInner.prototype.ExecuteMapAction = function (code) {
        var cmdName;
        switch (code) {
            case AjaxViewerMapActionCode.About:
                cmdName = command_1.DefaultCommands.About;
                break;
            case AjaxViewerMapActionCode.ClearSelection:
                cmdName = command_1.DefaultCommands.ClearSelection;
                break;
            case AjaxViewerMapActionCode.InitialView:
                cmdName = command_1.DefaultCommands.ZoomExtents;
                break;
            case AjaxViewerMapActionCode.NextView:
                cmdName = command_1.DefaultCommands.NextView;
                break;
            case AjaxViewerMapActionCode.PanDown:
                cmdName = command_1.DefaultCommands.PanDown;
                break;
            case AjaxViewerMapActionCode.PanLeft:
                cmdName = command_1.DefaultCommands.PanLeft;
                break;
            case AjaxViewerMapActionCode.PanMode:
                cmdName = command_1.DefaultCommands.Pan;
                break;
            case AjaxViewerMapActionCode.PanRight:
                cmdName = command_1.DefaultCommands.PanRight;
                break;
            case AjaxViewerMapActionCode.PanUp:
                cmdName = command_1.DefaultCommands.PanUp;
                break;
            case AjaxViewerMapActionCode.PrevView:
                cmdName = command_1.DefaultCommands.PreviousView;
                break;
            case AjaxViewerMapActionCode.RefreshMap:
                cmdName = command_1.DefaultCommands.RefreshMap;
                break;
            case AjaxViewerMapActionCode.SelectionMode:
                cmdName = command_1.DefaultCommands.Select;
                break;
            case AjaxViewerMapActionCode.SelectPolygon:
                cmdName = command_1.DefaultCommands.SelectPolygon;
                break;
            case AjaxViewerMapActionCode.SelectRadius:
                cmdName = command_1.DefaultCommands.SelectRadius;
                break;
            case AjaxViewerMapActionCode.ZoomExtents:
                cmdName = command_1.DefaultCommands.ZoomExtents;
                break;
            case AjaxViewerMapActionCode.ZoomIn:
                cmdName = command_1.DefaultCommands.ZoomIn;
                break;
            case AjaxViewerMapActionCode.ZoomMode:
                cmdName = command_1.DefaultCommands.Zoom;
                break;
            case AjaxViewerMapActionCode.ZoomOut:
                cmdName = command_1.DefaultCommands.ZoomOut;
                break;
            case AjaxViewerMapActionCode.ZoomRect:
                cmdName = command_1.DefaultCommands.Zoom;
                break;
            case AjaxViewerMapActionCode.ZoomSelection:
                cmdName = command_1.DefaultCommands.ZoomToSelection;
                break;
            default:
                (0, logger_1.warn)("Unknown command code: " + code);
                return;
        }
        var cmd = (0, command_1.getCommand)(cmdName);
        if (cmd && this.props.invokeCommand) {
            this.props.invokeCommand(cmd);
        }
    };
    ViewerApiShimInner.prototype.ClearSelection = function () {
        var _a, _b;
        (_b = (_a = (0, runtime_1.getViewer)()) === null || _a === void 0 ? void 0 : _a.mapguideSupport()) === null || _b === void 0 ? void 0 : _b.clearSelection();
    };
    ViewerApiShimInner.prototype.DigitizeCircle = function (handler) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            viewer.digitizeCircle(function (circle) {
                var center = circle.getCenter();
                var radius = circle.getRadius();
                handler({
                    Center: {
                        X: center[0],
                        Y: center[1]
                    },
                    Radius: radius
                });
            });
        }
    };
    ViewerApiShimInner.prototype.DigitizeLine = function (handler) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            viewer.digitizeLine(function (line) {
                var coords = line.getCoordinates().map(function (coord) {
                    return {
                        X: coord[0],
                        Y: coord[1]
                    };
                });
                handler(new AjaxViewerLineStringOrPolygon(coords));
            });
        }
    };
    ViewerApiShimInner.prototype.DigitizePoint = function (handler) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            viewer.digitizePoint(function (pt) {
                var coords = pt.getCoordinates();
                handler({ X: coords[0], Y: coords[1] });
            });
        }
    };
    ViewerApiShimInner.prototype.DigitizePolygon = function (handler) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            viewer.digitizePolygon(function (poly) {
                //Our API isn't expected to allow drawing polygons with holes, so the first (outer) ring
                //is what we're after
                var ring = poly.getLinearRing(0);
                var coords = ring.getCoordinates().map(function (coord) {
                    return {
                        X: coord[0],
                        Y: coord[1]
                    };
                });
                handler(new AjaxViewerLineStringOrPolygon(coords));
            });
        }
    };
    ViewerApiShimInner.prototype.DigitizeLineString = function (handler) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            viewer.digitizeLineString(function (line) {
                var coords = line.getCoordinates().map(function (coord) {
                    return {
                        X: coord[0],
                        Y: coord[1]
                    };
                });
                handler(new AjaxViewerLineStringOrPolygon(coords));
            });
        }
    };
    ViewerApiShimInner.prototype.DigitizeRectangle = function (handler) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            viewer.digitizeRectangle(function (rect) {
                var extent = rect.getExtent();
                handler({
                    Point1: {
                        X: extent[0],
                        Y: extent[1]
                    },
                    Point2: {
                        X: extent[2],
                        Y: extent[3]
                    }
                });
            });
        }
    };
    ViewerApiShimInner.prototype.GetCenter = function () {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            var view = viewer.getCurrentView();
            return { X: view.x, Y: view.y };
        }
        return null;
    };
    ViewerApiShimInner.prototype.GetLayers = function (onlyVisible, onlySelectable) {
        var selLayers = [];
        var _a = this.props, map = _a.map, selectionSet = _a.selectionSet;
        if (map && selectionSet && selectionSet.FeatureSet) {
            var fset = selectionSet.FeatureSet;
            var ids = fset.Layer.map(function (l) { return l["@id"]; });
            if (map.Layer) {
                for (var _i = 0, _b = map.Layer; _i < _b.length; _i++) {
                    var layer = _b[_i];
                    if (ids.indexOf(layer.ObjectId) >= 0) {
                        if (onlyVisible === true && layer.Visible === true) {
                            selLayers.push({ legend: layer.LegendLabel, name: layer.Name, objectid: layer.ObjectId });
                        }
                        if (onlySelectable === true && layer.Selectable === true) {
                            selLayers.push({ legend: layer.LegendLabel, name: layer.Name, objectid: layer.ObjectId });
                        }
                    }
                }
            }
        }
        return selLayers;
    };
    ViewerApiShimInner.prototype.GetMetersPerUnit = function () {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            return viewer.getMetersPerUnit();
        }
        return null;
    };
    ViewerApiShimInner.prototype.GetMapHeight = function () {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            var _a = viewer.getSize(), gh = _a[1];
            return gh;
        }
        return NaN;
    };
    ViewerApiShimInner.prototype.GetMapUnitsType = function () {
        var uom = (0, units_1.getUnitOfMeasure)(this.props.sizeUnits || common_1.UnitOfMeasure.Unknown);
        return uom.name;
    };
    ViewerApiShimInner.prototype.GetMapWidth = function () {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            var gw = viewer.getSize()[0];
            return gw;
        }
        return NaN;
    };
    ViewerApiShimInner.prototype.GetScale = function () {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            var view = viewer.getCurrentView();
            return view.scale;
        }
        return null;
    };
    ViewerApiShimInner.prototype.GetSelectedLayers = function () {
        var selLayers = [];
        var _a = this.props, map = _a.map, selectionSet = _a.selectionSet;
        if (map && selectionSet && selectionSet.FeatureSet) {
            var fset = selectionSet.FeatureSet;
            var ids = fset.Layer.map(function (l) { return l["@id"]; });
            if (map.Layer) {
                for (var _i = 0, _b = map.Layer; _i < _b.length; _i++) {
                    var layer = _b[_i];
                    if (ids.indexOf(layer.ObjectId) >= 0) {
                        selLayers.push({ legend: layer.LegendLabel, name: layer.Name, objectid: layer.ObjectId });
                    }
                }
            }
        }
        return selLayers;
    };
    ViewerApiShimInner.prototype.GetSelectionXML = function () {
        var selectionSet = this.props.selectionSet;
        if (!selectionSet || !selectionSet.FeatureSet) {
            return "";
        }
        else {
            return (0, deArrayify_1.buildSelectionXml)(selectionSet.FeatureSet);
        }
    };
    ViewerApiShimInner.prototype.GetSelectedBounds = function () {
        var bounds = null;
        var selectionSet = this.props.selectionSet;
        if (selectionSet && selectionSet.SelectedFeatures) {
            var fset = selectionSet.SelectedFeatures;
            fset.SelectedLayer.forEach(function (layer) {
                layer.Feature.forEach(function (feature) {
                    var bbox = feature.Bounds
                        ? feature.Bounds.split(" ").map(function (s) { return parseFloat(s); })
                        : undefined;
                    if (bbox) {
                        if (bounds == null) {
                            bounds = { minx: bbox[0], miny: bbox[1], maxx: bbox[2], maxy: bbox[3] };
                        }
                        else {
                            if (bbox[0] < bounds.minx)
                                bounds.minx = bbox[0];
                            if (bbox[1] < bounds.miny)
                                bounds.miny = bbox[1];
                            if (bbox[2] > bounds.maxx)
                                bounds.maxx = bbox[2];
                            if (bbox[3] > bounds.maxy)
                                bounds.maxy = bbox[3];
                        }
                    }
                });
            });
        }
        return bounds;
    };
    ViewerApiShimInner.prototype.GetSelectedCount = function () {
        var count = 0;
        var selectionSet = this.props.selectionSet;
        if (selectionSet && selectionSet.FeatureSet) {
            var fset = selectionSet.FeatureSet;
            fset.Layer.forEach(function (layer) {
                layer.Class.ID.forEach(function () {
                    count++;
                });
            });
        }
        return count;
    };
    ViewerApiShimInner.prototype.GetSelectedFeatures = function () {
        var _a;
        var viewer = (_a = (0, runtime_1.getViewer)()) === null || _a === void 0 ? void 0 : _a.mapguideSupport();
        if (viewer) {
            var selection = viewer.getSelection();
            if (selection && selection.SelectedFeatures) {
                var sel = {};
                for (var _i = 0, _b = selection.SelectedFeatures.SelectedLayer; _i < _b.length; _i++) {
                    var sl = _b[_i];
                    sel[sl["@name"]] = sl.Feature.map(function (f) {
                        if (f.Bounds) {
                            var bbox = f.Bounds.split(" ").map(function (s) { return parseFloat(s); });
                            return {
                                zoom: { minx: bbox[0], miny: bbox[1], maxx: bbox[2], maxy: bbox[3] },
                                values: f.Property.map(function (p) { return ({ name: p.Name, value: p.Value }); })
                            };
                        }
                        return undefined;
                    }).filter(function (f) { return f != null; });
                }
                return sel;
            }
        }
    };
    ViewerApiShimInner.prototype.IsDigitizing = function () {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            return viewer.isDigitizing();
        }
        else {
            return false;
        }
    };
    ViewerApiShimInner.prototype.IsEnglishUnits = function () {
        return this.us;
    };
    ViewerApiShimInner.prototype.IsLatLongDisplayUnits = function () {
        return true; //This is what the AJAX viewer returns
    };
    ViewerApiShimInner.prototype.MapUnitsToLatLon = function () {
        throw new error_1.MgError("Un-implemented AJAX viewer shim API: map_frame.MapUnitsToLatLon(x, y)");
    };
    ViewerApiShimInner.prototype.Refresh = function () {
        var _a, _b;
        var viewer = (0, runtime_1.getViewer)();
        viewer === null || viewer === void 0 ? void 0 : viewer.refreshMap(common_1.RefreshMode.LayersOnly | common_1.RefreshMode.SelectionOnly);
        (_b = (_a = this.props).legendRefresh) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    ViewerApiShimInner.prototype.ScreenToMapUnits = function (x, y) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            var _a = viewer.screenToMapUnits(x, y), sx = _a[0], sy = _a[1];
            return { X: sx, Y: sy };
        }
    };
    ViewerApiShimInner.prototype.SetEnglishUnits = function (usEnglish) {
        this.us = usEnglish;
    };
    ViewerApiShimInner.prototype.SetLatLongDisplayUnits = function () {
        //This is what the AJAX viewer does
    };
    ViewerApiShimInner.prototype.SetSelectionXML = function (xmlSet) {
        var _a;
        var viewer = (_a = (0, runtime_1.getViewer)()) === null || _a === void 0 ? void 0 : _a.mapguideSupport();
        if (viewer) {
            viewer.setSelectionXml(xmlSet);
        }
    };
    ViewerApiShimInner.prototype.ZoomToView = function (x, y, scale) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            viewer.zoomToView(x, y, scale);
        }
    };
    ViewerApiShimInner.prototype.SetStatusMsg = function (msg) {
        window.status = msg || ""; //Most browsers do nothing with window.status, but that is what this method does in the AJAX viewer
    };
    //This isn't in the AJAX Viewer API reference, but there are samples referencing it!
    ViewerApiShimInner.prototype.ZoomToScale = function (scale) {
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            var view = viewer.getCurrentView();
            viewer.zoomToView(view.x, view.y, scale);
        }
    };
    //Form frame
    ViewerApiShimInner.prototype.Submit = function (url, params, frameTarget) {
        this.formFrame.submit(url, params, frameTarget);
    };
    ViewerApiShimInner.prototype.RegisterSelectionHandler = function (handler) {
        this.userSelectionHandlers.push(handler);
        return this.userSelectionHandlers.length;
    };
    ViewerApiShimInner.prototype.UnregisterSelectionHandler = function (handler) {
        this.userSelectionHandlers = this.userSelectionHandlers.filter(function (h) { return h != handler; });
        return this.userSelectionHandlers.length;
    };
    ViewerApiShimInner.prototype.installShims = function (browserWindow) {
        var _this = this;
        browserWindow.Fusion = this.fusionAPI;
        browserWindow.OpenLayers = this.ol2API;
        browserWindow.GetMapFrame = browserWindow.GetMapFrame || (function () { return _this; });
        //NOTE: mapFrame is technically not part of the "public" API for the AJAX viewer, but since most examples test
        //for this in place of GetMapFrame(), we might as well emulate it here
        browserWindow.mapFrame = browserWindow.GetMapFrame();
        browserWindow.formFrame = browserWindow.mapFrame;
        browserWindow.ExecuteMapAction = browserWindow.ExecuteMapAction || (function (code) { return _this.ExecuteMapAction(code); });
        browserWindow.Refresh = browserWindow.Refresh || (function () { return _this.Refresh(); });
        browserWindow.SetSelectionXML = browserWindow.SetSelectionXML || (function (xmlSet) { return _this.SetSelectionXML(xmlSet); });
        browserWindow.ZoomToView = browserWindow.ZoomToView || (function (x, y, scale) { return _this.ZoomToView(x, y, scale); });
        browserWindow.GotoHomePage = browserWindow.GotoHomePage || (function () { return _this.goHome(); });
        // ======= Extended Viewer API ========== //
        browserWindow.GetViewerInterface = browserWindow.GetViewerInterface || (function () { return (0, runtime_1.getViewer)(); });
        browserWindow.RegisterSelectionHandler = browserWindow.RegisterSelectionHandler || (function (handler) { return _this.RegisterSelectionHandler(handler); });
        browserWindow.UnregisterSelectionHandler = browserWindow.UnregisterSelectionHandler || (function (handler) { return _this.UnregisterSelectionHandler(handler); });
    };
    ViewerApiShimInner.prototype.componentDidMount = function () {
        var _this = this;
        //Install shims into browser window
        var browserWindow = window;
        this.installShims(browserWindow);
        this.installShims(window.parent);
        this.RegisterSelectionHandler(function (_mapName, selection) {
            _this.fusionSelectionHandler(selection);
        });
    };
    ViewerApiShimInner.prototype.componentDidUpdate = function (prevProps) {
        var _a;
        var nextProps = this.props;
        if (nextProps.map && nextProps.selectionSet != prevProps.selectionSet) {
            for (var _i = 0, _b = this.userSelectionHandlers; _i < _b.length; _i++) {
                var handler = _b[_i];
                handler(nextProps.map.Name, (_a = nextProps.selectionSet) !== null && _a !== void 0 ? _a : undefined);
            }
        }
        if (nextProps.busyCount != prevProps.busyCount) {
            this.triggerFusionEvent(this.fusionAPI.Event.MAP_BUSY_CHANGED);
        }
    };
    ViewerApiShimInner.prototype.render = function () {
        //This is for all intents and purposes, a "background" component. There is no real DOM representation
        return React.createElement("div", null,
            React.createElement(form_frame_shim_1.FormFrameShim, { ref: this.onFormFrameMounted }));
    };
    return ViewerApiShimInner;
}(React.Component));
var ViewerApiShim = function () {
    var map = (0, hooks_mapguide_1.useActiveMapState)();
    var selectionSet = (0, hooks_1.useActiveMapSelectionSet)();
    var agentUri = (0, hooks_1.useConfiguredAgentUri)();
    var agentKind = (0, hooks_1.useConfiguredAgentKind)();
    var busyCount = (0, hooks_1.useViewerBusyCount)();
    var sizeUnits = (0, hooks_1.useViewerSizeUnits)();
    var dispatch = (0, context_1.useReduxDispatch)();
    var goHomeAction = function () { return dispatch((0, taskpane_1.goHome)()); };
    var legendRefresh = function () { return dispatch((0, legend_1.refresh)()); };
    var invokeCommandAction = function (cmd, parameters) { return dispatch((0, map_1.invokeCommand)(cmd, parameters)); };
    var setSelectionAction = function (mapName, res) { return dispatch((0, map_1.setSelection)(mapName, res)); };
    var queryMapFeaturesAction = function (mapName, options) { return dispatch((0, map_1.queryMapFeatures)(mapName, options)); };
    return React.createElement(ViewerApiShimInner, { map: map, selectionSet: selectionSet, agentUri: agentUri, agentKind: agentKind, busyCount: busyCount, sizeUnits: sizeUnits, goHome: goHomeAction, legendRefresh: legendRefresh, invokeCommand: invokeCommandAction, setSelection: setSelectionAction, queryMapFeatures: queryMapFeaturesAction });
};
exports.ViewerApiShim = ViewerApiShim;


/***/ }),

/***/ "./src/entries/application.tsx":
/*!*************************************!*\
  !*** ./src/entries/application.tsx ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationViewModel = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var ReactDOM = (0, tslib_1.__importStar)(__webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"));
var app_1 = __webpack_require__(/*! ../containers/app */ "./src/containers/app.tsx");
var configure_store_1 = __webpack_require__(/*! ../store/configure-store */ "./src/store/configure-store.ts");
var config_1 = __webpack_require__(/*! ../reducers/config */ "./src/reducers/config.ts");
var command_1 = __webpack_require__(/*! ../api/registry/command */ "./src/api/registry/command.ts");
var subscriber_1 = __webpack_require__(/*! ../containers/subscriber */ "./src/containers/subscriber.tsx");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var init_mapguide_1 = __webpack_require__(/*! ../actions/init-mapguide */ "./src/actions/init-mapguide.ts");
/**
 * This is the entry point to the Application component
 *
 * In the browser globals context, this is accessible via MapGuide.Application
 */
var ApplicationViewModel = /** @class */ (function () {
    /**
     * @hidden
     */
    function ApplicationViewModel() {
    }
    /**
     * Returns any extra initial state to include as part of initializing the redux store
     *
     * Overridable by sub-classes that want to include extra initial state
     *
     * @virtual
     * @protected
     * @returns {*}
     * @memberof ApplicationViewModel
     */
    ApplicationViewModel.prototype.getExtraInitialState = function () { return {}; };
    /**
     * Returns any extra reducers to include as part of initializing the redux store
     *
     * Overridable by sub-classes that want to include custom reducers
     *
     * @virtual
     * @protected
     * @returns {*}
     * @memberof ApplicationViewModel
     */
    ApplicationViewModel.prototype.getExtraReducers = function () { return {}; };
    /**
     * Mounts the map viewer application at the specified DOM element with the
     * given component props.
     *
     * For the viewer templates already provided, this method is already called
     * for you in the template's HTML. If you are creating your own viewer template, be
     * sure to call this method must on the template's HTML.
     *
     * @param {Element} node
     * @param {IAppProps & IApplicationMountOptions} props
     *
     * @memberof ApplicationViewModel
     */
    ApplicationViewModel.prototype.mount = function (node, props) {
        var _a, _b, _c, _d;
        var subs = (_a = props.subscribers) !== null && _a !== void 0 ? _a : [];
        var agentConf = {
            agentUri: (_b = props.mapguide) === null || _b === void 0 ? void 0 : _b.agentUri,
            agentKind: (_d = (_c = props.mapguide) === null || _c === void 0 ? void 0 : _c.agentKind) !== null && _d !== void 0 ? _d : "mapagent"
        };
        var initState = (0, tslib_1.__assign)({ config: (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, config_1.CONFIG_INITIAL_STATE), agentConf), (props.initialConfig || {})) }, this.getExtraInitialState());
        var extraReducers = this.getExtraReducers();
        this._store = (0, configure_store_1.configureStore)(initState, extraReducers);
        var initCommand;
        if (props.initCommandFactory)
            initCommand = props.initCommandFactory(this._store.dispatch);
        else
            initCommand = new init_mapguide_1.DefaultViewerInitCommand(this._store.dispatch);
        ReactDOM.render(React.createElement(context_1.ReduxProvider, { store: this._store },
            React.createElement(app_1.App, (0, tslib_1.__assign)({}, props, { initCommand: initCommand })),
            subs.map(function (s, i) { return React.createElement(subscriber_1.Subscriber, (0, tslib_1.__assign)({ key: "subscriber-" + i + "-" + s.name }, s)); })), node);
    };
    /**
     * Dispatches the given action
     *
     * @param {(ViewerAction | ReduxThunkedAction)} action
     * @memberof ApplicationViewModel
     * @remarks Usage outside of the react component context should be used sparingly. In particular
     * you should avoid trying to call this method multiple times in succession. You should call this
     * method once in response to a DOM element event (eg. A button click)
     * @alpha
     */
    ApplicationViewModel.prototype.dispatch = function (action) {
        this._store.dispatch(action);
    };
    /**
     * Gets the command registered by the specific name
     *
     * @param {string} commandName
     * @returns {(ICommand | undefined)}
     * @memberof ApplicationViewModel
     */
    ApplicationViewModel.prototype.getCommand = function (commandName) {
        return (0, command_1.getCommand)(commandName);
    };
    /**
     * Returns the current application state. This state is read-only and should not be modified.
     *
     * @returns {Readonly<IApplicationState>}
     * @memberof ApplicationViewModel
     */
    ApplicationViewModel.prototype.getState = function () {
        return this._store.getState();
    };
    return ApplicationViewModel;
}());
exports.ApplicationViewModel = ApplicationViewModel;


/***/ }),

/***/ "./src/entries/library.tsx":
/*!*********************************!*\
  !*** ./src/entries/library.tsx ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Actions = exports.getStateFromUrl = exports.updateUrl = exports.MapGuideViewerInitCommand = exports.setAssetRoot = exports.Application = exports.Externals = exports.Registry = exports.__BRANCH__ = exports.__COMMITHASH__ = exports.__VERSION__ = exports.__DEV__ = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var ReactDOM = (0, tslib_1.__importStar)(__webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"));
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var default_commands_1 = __webpack_require__(/*! ../api/default-commands */ "./src/api/default-commands.ts");
var ajax_viewer_1 = __webpack_require__(/*! ../layouts/ajax-viewer */ "./src/layouts/ajax-viewer.tsx");
var sidebar_1 = __webpack_require__(/*! ../layouts/sidebar */ "./src/layouts/sidebar.tsx");
var aqua_1 = __webpack_require__(/*! ../layouts/aqua */ "./src/layouts/aqua.tsx");
var turquoise_yellow_1 = __webpack_require__(/*! ../layouts/turquoise-yellow */ "./src/layouts/turquoise-yellow.tsx");
var limegold_1 = __webpack_require__(/*! ../layouts/limegold */ "./src/layouts/limegold.tsx");
var slate_1 = __webpack_require__(/*! ../layouts/slate */ "./src/layouts/slate.tsx");
var maroon_1 = __webpack_require__(/*! ../layouts/maroon */ "./src/layouts/maroon.tsx");
var layout_1 = __webpack_require__(/*! ../api/registry/layout */ "./src/api/registry/layout.ts");
var command_1 = __webpack_require__(/*! ../api/registry/command */ "./src/api/registry/command.ts");
var component_1 = __webpack_require__(/*! ../api/registry/component */ "./src/api/registry/component.tsx");
var default_components_1 = __webpack_require__(/*! ../api/default-components */ "./src/api/default-components.tsx");
var bootstrap_1 = __webpack_require__(/*! ../api/bootstrap */ "./src/api/bootstrap.ts");
var proj4_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! proj4 */ "./node_modules/proj4/lib/index.js"));
var MapActions = (0, tslib_1.__importStar)(__webpack_require__(/*! ../actions/map */ "./src/actions/map.ts"));
var LegendActions = (0, tslib_1.__importStar)(__webpack_require__(/*! ../actions/legend */ "./src/actions/legend.ts"));
var FlyoutActions = (0, tslib_1.__importStar)(__webpack_require__(/*! ../actions/flyout */ "./src/actions/flyout.ts"));
var ModalActions = (0, tslib_1.__importStar)(__webpack_require__(/*! ../actions/modal */ "./src/actions/modal.ts"));
var TaskPaneActions = (0, tslib_1.__importStar)(__webpack_require__(/*! ../actions/taskpane */ "./src/actions/taskpane.ts"));
var TemplateActions = (0, tslib_1.__importStar)(__webpack_require__(/*! ../actions/template */ "./src/actions/template.ts"));
var factory_1 = __webpack_require__(/*! ../api/builders/factory */ "./src/api/builders/factory.ts");
var mapagent_1 = __webpack_require__(/*! ../api/builders/mapagent */ "./src/api/builders/mapagent.ts");
var driver_registry_1 = __webpack_require__(/*! ../api/layer-manager/driver-registry */ "./src/api/layer-manager/driver-registry.ts");
var csv_driver_1 = __webpack_require__(/*! ../api/layer-manager/csv-driver */ "./src/api/layer-manager/csv-driver.ts");
var format_driver_1 = __webpack_require__(/*! ../api/layer-manager/format-driver */ "./src/api/layer-manager/format-driver.ts");
var GeoJSON_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/format/GeoJSON */ "./node_modules/ol/format/GeoJSON.js"));
var TopoJSON_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/format/TopoJSON */ "./node_modules/ol/format/TopoJSON.js"));
var KML_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/format/KML */ "./node_modules/ol/format/KML.js"));
var GPX_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/format/GPX */ "./node_modules/ol/format/GPX.js"));
var IGC_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ol/format/IGC */ "./node_modules/ol/format/IGC.js"));
var mapguide_commands_1 = __webpack_require__(/*! ../api/mapguide-commands */ "./src/api/mapguide-commands.ts");
var mapguide_components_1 = __webpack_require__(/*! ../api/mapguide-components */ "./src/api/mapguide-components.tsx");
var mapguide_1 = __webpack_require__(/*! ../components/map-providers/mapguide */ "./src/components/map-providers/mapguide.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var neo_map_viewer_1 = __webpack_require__(/*! ../containers/neo-map-viewer */ "./src/containers/neo-map-viewer.tsx");
__webpack_require__(/*! ../styles/index.css */ "./src/styles/index.css");
__webpack_require__(/*! ol/ol.css */ "./node_modules/ol/ol.css");
__webpack_require__(/*! @blueprintjs/core/lib/css/blueprint.css */ "./node_modules/@blueprintjs/core/lib/css/blueprint.css");
__webpack_require__(/*! react-splitter-layout/lib/index.css */ "./node_modules/react-splitter-layout/lib/index.css");
var generic_1 = __webpack_require__(/*! ../layouts/generic */ "./src/layouts/generic.tsx");
var external_layer_1 = __webpack_require__(/*! ../api/registry/external-layer */ "./src/api/registry/external-layer.ts");
(0, bootstrap_1.bootstrap)();
(0, driver_registry_1.addFormatDriver)(new csv_driver_1.CsvFormatDriver(csv_driver_1.CSV_COLUMN_ALIASES));
(0, driver_registry_1.addFormatDriver)(new format_driver_1.FormatDriver("GeoJSON", new GeoJSON_1.default()));
(0, driver_registry_1.addFormatDriver)(new format_driver_1.FormatDriver("TopoJSON", new TopoJSON_1.default()));
(0, driver_registry_1.addFormatDriver)(new format_driver_1.FormatDriver("KML", new KML_1.default(), "EPSG:4326"));
(0, driver_registry_1.addFormatDriver)(new format_driver_1.FormatDriver("GPX", new GPX_1.default(), "EPSG:4326"));
(0, driver_registry_1.addFormatDriver)(new format_driver_1.FormatDriver("IGC", new IGC_1.default()));
var DEFAULT_CAPS = {
    hasTaskPane: true
};
(0, layout_1.registerLayout)("ajax-viewer", function () { return React.createElement(ajax_viewer_1.AjaxViewerLayout, null); }, DEFAULT_CAPS);
(0, layout_1.registerLayout)("sidebar", function () { return React.createElement(sidebar_1.SidebarLayout, null); }, DEFAULT_CAPS);
(0, layout_1.registerLayout)("aqua", function () { return React.createElement(aqua_1.AquaTemplateLayout, null); }, DEFAULT_CAPS);
(0, layout_1.registerLayout)("turquoise-yellow", function () { return React.createElement(turquoise_yellow_1.TurquoiseYellowTemplateLayout, null); }, DEFAULT_CAPS);
(0, layout_1.registerLayout)("limegold", function () { return React.createElement(limegold_1.LimeGoldTemplateLayout, null); }, DEFAULT_CAPS);
(0, layout_1.registerLayout)("slate", function () { return React.createElement(slate_1.SlateTemplateLayout, null); }, DEFAULT_CAPS);
(0, layout_1.registerLayout)("maroon", function () { return React.createElement(maroon_1.MaroonTemplateLayout, null); }, DEFAULT_CAPS);
(0, layout_1.registerLayout)("generic", function () { return React.createElement(generic_1.GenericLayout, null); }, {
    hasTaskPane: false
});
(0, default_commands_1.initDefaultCommands)();
(0, mapguide_commands_1.initMapGuideCommands)();
(0, default_components_1.registerDefaultComponents)();
(0, mapguide_components_1.registerMapGuideComponents)();
// Register our MapGuide-specific viewer implementation
var PROVIDER_IMPL = new mapguide_1.MapGuideMapProviderContext();
(0, component_1.registerComponentFactory)(component_1.DefaultComponentNames.Map, function (props) { return React.createElement(context_1.MapProviderContextProvider, { value: PROVIDER_IMPL },
    React.createElement(neo_map_viewer_1.MapViewer, (0, tslib_1.__assign)({}, props))); });
//Register the default mapagent request builder (that can be replaced later on if desired)
(0, factory_1.registerRequestBuilder)("mapagent", function (agentUri, locale) { return new mapagent_1.MapAgentRequestBuilder(agentUri, locale); });
/**
 * A helper class for use in the browser globals context to register any of the following:
 *  - String bundles
 *  - Layout components
 *  - Custom commands
 *  - Component factories
 *
 * @export
 * @class Registry
 */
var Registry = /** @class */ (function () {
    function Registry() {
    }
    /**
     * Registers the given string bundle under the given locale
     *
     * @static
     * @param {string} locale The locale
     * @param {*} bundle The string bundle
     *
     * @memberof Registry
     */
    Registry.registerStringBundle = function (locale, bundle) {
        (0, i18n_1.registerStringBundle)(locale, bundle);
    };
    /**
     * Registers the given JSX element factory for the given viewer template name
     *
     * @static
     * @param {string} name The viewer template name
     * @param {() => JSX.Element} factory The JSX element factory that creates the viewer template component
     * @param caps Viewer template capabilities
     *
     * @memberof Registry
     * @since 0.14 Added required caps parameter
     */
    Registry.registerLayout = function (name, factory, caps) {
        (0, layout_1.registerLayout)(name, factory, caps);
    };
    /**
     * Registers the given command with the given name
     *
     * @static
     * @param {string} name The name of the command
     * @param {(Common.ICommand | Common.IInvokeUrlCommand | Common.ISearchCommand)} cmdDef The command to register
     *
     * @memberof Registry
     */
    Registry.registerCommand = function (name, cmdDef) {
        (0, command_1.registerCommand)(name, cmdDef);
    };
    /**
     * Registers the given JSX element factory for the given component id
     *
     * @static
     * @param {string} id The component id
     * @param {(props: any) => JSX.Element} factory The JSX element factory that creates the component
     *
     * @memberof Registry
     */
    Registry.registerComponentFactory = function (id, factory) {
        (0, component_1.registerComponentFactory)(id, factory);
    };
    /**
     * Registers the given external vector layer factory method
     *
     * @param driverName
     * @param creator
     * @since 0.14
     */
    Registry.registerExternalVectorLayerCreator = function (driverName, creator) {
        var reg = external_layer_1.ExternalLayerFactoryRegistry.getInstance();
        reg.registerExternalVectorLayerCreator(driverName, creator);
    };
    return Registry;
}());
exports.Registry = Registry;
/**
 * The top-level namespace for key external libraries
 */
exports.Externals = {
    /**
     * The exported public API for proj4js
     */
    proj4: proj4_1.default,
    /**
     * The exported public API for React
     */
    React: React,
    /**
     * The exported public API for ReactDOM
     */
    ReactDOM: ReactDOM
};
var application_1 = __webpack_require__(/*! ./application */ "./src/entries/application.tsx");
Object.defineProperty(exports, "Application", ({ enumerable: true, get: function () { return application_1.ApplicationViewModel; } }));
var asset_1 = __webpack_require__(/*! ../utils/asset */ "./src/utils/asset.ts");
Object.defineProperty(exports, "setAssetRoot", ({ enumerable: true, get: function () { return asset_1.setAssetRoot; } }));
var init_mapguide_1 = __webpack_require__(/*! ../actions/init-mapguide */ "./src/actions/init-mapguide.ts");
Object.defineProperty(exports, "MapGuideViewerInitCommand", ({ enumerable: true, get: function () { return init_mapguide_1.DefaultViewerInitCommand; } }));
var url_state_1 = __webpack_require__(/*! ../containers/url-state */ "./src/containers/url-state.ts");
Object.defineProperty(exports, "updateUrl", ({ enumerable: true, get: function () { return url_state_1.updateUrl; } }));
Object.defineProperty(exports, "getStateFromUrl", ({ enumerable: true, get: function () { return url_state_1.getStateFromUrl; } }));
/**
 * The top-level namespace for all dispatchable actions
 */
exports.Actions = {
    Map: MapActions,
    Legend: LegendActions,
    Flyout: FlyoutActions,
    Modal: ModalActions,
    TaskPane: TaskPaneActions,
    Template: TemplateActions
};


/***/ }),

/***/ "./src/layouts/ajax-viewer.tsx":
/*!*************************************!*\
  !*** ./src/layouts/ajax-viewer.tsx ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AjaxViewerLayout = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var component_1 = __webpack_require__(/*! ../api/registry/component */ "./src/api/registry/component.tsx");
var toolbar_1 = __webpack_require__(/*! ../components/toolbar */ "./src/components/toolbar.tsx");
var toolbar_2 = __webpack_require__(/*! ../containers/toolbar */ "./src/containers/toolbar.tsx");
var flyout_region_1 = __webpack_require__(/*! ../containers/flyout-region */ "./src/containers/flyout-region.tsx");
var viewer_shim_1 = __webpack_require__(/*! ../containers/viewer-shim */ "./src/containers/viewer-shim.tsx");
var modal_launcher_1 = __webpack_require__(/*! ../containers/modal-launcher */ "./src/containers/modal-launcher.tsx");
var init_warning_display_1 = __webpack_require__(/*! ../containers/init-warning-display */ "./src/containers/init-warning-display.tsx");
var react_splitter_layout_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! react-splitter-layout */ "./node_modules/react-splitter-layout/lib/index.js"));
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/layouts/hooks.ts");
var hooks_2 = __webpack_require__(/*! ../containers/hooks */ "./src/containers/hooks.ts");
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
/**
 * A viewer template that resembles the MapGuide AJAX viewer
 */
var AjaxViewerLayout = function () {
    var _a = (0, hooks_1.useCommonTemplateState)(), isResizing = _a.isResizing, locale = _a.locale, capabilities = _a.capabilities, onDragStart = _a.onDragStart, onDragEnd = _a.onDragEnd, onSplitterChanged = _a.onSplitterChanged;
    var initInfoPaneWidth = (0, hooks_2.useTemplateInitialInfoPaneWidth)();
    var initTaskPaneWidth = (0, hooks_2.useTemplateInitialTaskPaneWidth)();
    var hasToolbar = false;
    var hasTaskPane = false;
    var hasStatusBar = false;
    var hasNavigator = false;
    var hasSelectionPanel = false;
    var hasLegend = false;
    if (capabilities) {
        hasToolbar = capabilities.hasToolbar;
        hasTaskPane = capabilities.hasTaskPane;
        hasStatusBar = capabilities.hasStatusBar;
        hasNavigator = capabilities.hasNavigator;
        hasSelectionPanel = capabilities.hasSelectionPanel;
        hasLegend = capabilities.hasLegend;
    }
    var TB_Z_INDEX = 10;
    var topOffset = hasToolbar ? toolbar_1.DEFAULT_TOOLBAR_SIZE : 0;
    var bottomOffset = hasStatusBar ? 20 : 0;
    var lgStyle = {};
    var selStyle = {};
    return React.createElement("div", { style: { width: "100%", height: "100%" } },
        React.createElement("div", { style: { position: "absolute", left: 0, right: 0, top: 0, bottom: bottomOffset } },
            React.createElement(react_splitter_layout_1.default, { customClassName: "ajax-viewer-splitter", primaryIndex: 0, secondaryInitialSize: initTaskPaneWidth, onDragStart: onDragStart, onDragEnd: onDragEnd },
                React.createElement("div", null,
                    (function () {
                        if (hasToolbar) {
                            return React.createElement(toolbar_2.ToolbarContainer, { id: constants_1.WEBLAYOUT_TOOLBAR, containerStyle: { position: "absolute", left: 0, top: 0, right: 0, zIndex: TB_Z_INDEX, backgroundColor: toolbar_1.TOOLBAR_BACKGROUND_COLOR } });
                        }
                    })(),
                    React.createElement("div", { style: { position: "absolute", left: 0, top: topOffset, bottom: 0, right: 0 } },
                        React.createElement(react_splitter_layout_1.default, { customClassName: "ajax-viewer-splitter", primaryIndex: 1, secondaryInitialSize: initInfoPaneWidth, onSecondaryPaneSizeChange: onSplitterChanged },
                            (function () {
                                if (hasLegend || hasSelectionPanel) {
                                    return React.createElement(react_splitter_layout_1.default, { customClassName: "ajax-viewer-splitter", vertical: true, onDragStart: onDragStart, onDragEnd: onDragEnd },
                                        (function () {
                                            if (hasLegend) {
                                                return React.createElement("div", { className: "ajax-sidebar-panel", style: lgStyle },
                                                    React.createElement("div", { className: "ajax-sidebar-panel-heading" },
                                                        React.createElement("p", null, (0, i18n_1.tr)("TPL_TITLE_LEGEND", locale))),
                                                    React.createElement("div", { className: "ajax-sidebar-panel-body" },
                                                        React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Legend, locale: locale, componentProps: { inlineBaseLayerSwitcher: true } })));
                                            }
                                        })(),
                                        (function () {
                                            if (hasSelectionPanel) {
                                                return React.createElement("div", { className: "ajax-sidebar-panel", style: selStyle },
                                                    React.createElement("div", { className: "ajax-sidebar-panel-heading" },
                                                        React.createElement("p", null, (0, i18n_1.tr)("TPL_TITLE_SELECTION_PANEL", locale))),
                                                    React.createElement("div", { className: "ajax-sidebar-panel-body" },
                                                        React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.SelectionPanel, locale: locale })));
                                            }
                                        })());
                                }
                            })(),
                            React.createElement("div", { style: { position: "absolute", left: 0, right: 0, top: 0, bottom: 0 } },
                                React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Map, locale: locale }),
                                (function () {
                                    if (hasNavigator) {
                                        return React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Navigator, locale: locale });
                                    }
                                })())))),
                (function () {
                    if (hasTaskPane) {
                        return React.createElement(component_1.PlaceholderComponent, { locale: locale, id: component_1.DefaultComponentNames.TaskPane, componentProps: { isResizing: isResizing } });
                    }
                })())),
        (function () {
            if (hasStatusBar) {
                return React.createElement("div", { style: { position: "absolute", left: 0, right: 0, bottom: 0, height: bottomOffset, backgroundColor: toolbar_1.TOOLBAR_BACKGROUND_COLOR } },
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.MouseCoordinates, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.ScaleDisplay, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.ViewSize, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.SelectedFeatureCount, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.PoweredByMapGuide, locale: locale }));
            }
        })(),
        React.createElement(viewer_shim_1.ViewerApiShim, null),
        React.createElement(modal_launcher_1.ModalLauncher, null),
        React.createElement(flyout_region_1.FlyoutRegionContainer, null),
        React.createElement(init_warning_display_1.InitWarningDisplay, null));
};
exports.AjaxViewerLayout = AjaxViewerLayout;


/***/ }),

/***/ "./src/layouts/aqua.tsx":
/*!******************************!*\
  !*** ./src/layouts/aqua.tsx ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AquaTemplateLayout = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var component_1 = __webpack_require__(/*! ../api/registry/component */ "./src/api/registry/component.tsx");
var toolbar_1 = __webpack_require__(/*! ../components/toolbar */ "./src/components/toolbar.tsx");
var toolbar_2 = __webpack_require__(/*! ../containers/toolbar */ "./src/containers/toolbar.tsx");
var viewer_shim_1 = __webpack_require__(/*! ../containers/viewer-shim */ "./src/containers/viewer-shim.tsx");
var modal_launcher_1 = __webpack_require__(/*! ../containers/modal-launcher */ "./src/containers/modal-launcher.tsx");
var flyout_region_1 = __webpack_require__(/*! ../containers/flyout-region */ "./src/containers/flyout-region.tsx");
var modal_dialog_1 = __webpack_require__(/*! ../components/modal-dialog */ "./src/components/modal-dialog.tsx");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var init_warning_display_1 = __webpack_require__(/*! ../containers/init-warning-display */ "./src/containers/init-warning-display.tsx");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/layouts/hooks.ts");
var hooks_2 = __webpack_require__(/*! ../containers/hooks */ "./src/containers/hooks.ts");
var template_1 = __webpack_require__(/*! ../actions/template */ "./src/actions/template.ts");
var hooks_mapguide_1 = __webpack_require__(/*! ../containers/hooks-mapguide */ "./src/containers/hooks-mapguide.ts");
var hooks_generic_1 = __webpack_require__(/*! ../containers/hooks-generic */ "./src/containers/hooks-generic.ts");
function aquaTemplateReducer(origState, state, action) {
    switch (action.type) {
        case actions_1.ActionType.MAP_SET_SELECTION:
            {
                //This is the only template that does not conform to the selection/legend/taskpane is a mutually
                //exclusive visible set. We take advantage of the custom template reducer function to apply the
                //correct visibility state against the *original state* effectively discarding whatever the root
                //template reducer has done against this action.
                var selection = action.payload.selection;
                if (selection && selection.SelectedFeatures) {
                    if (selection.SelectedFeatures.SelectedLayer.length && origState.autoDisplaySelectionPanelOnSelection) {
                        return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, origState), { selectionPanelVisible: true });
                    }
                }
                return state; //No action taken: Return "current" state
            }
        case actions_1.ActionType.MAP_ADD_CLIENT_SELECTED_FEATURE:
            {
                //This is the only template that does not conform to the selection/legend/taskpane is a mutually
                //exclusive visible set. We take advantage of the custom template reducer function to apply the
                //correct visibility state against the *original state* effectively discarding whatever the root
                //template reducer has done against this action.
                var feature = action.payload.feature;
                if (feature === null || feature === void 0 ? void 0 : feature.properties) {
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, origState), { selectionPanelVisible: true });
                }
                return state; //No action taken: Return "current" state
            }
        case actions_1.ActionType.FUSION_SET_LEGEND_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = { legendVisible: data };
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.FUSION_SET_SELECTION_PANEL_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = { selectionPanelVisible: data };
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.TASK_INVOKE_URL:
            {
                var state1 = { taskPaneVisible: true };
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
            }
        case actions_1.ActionType.FUSION_SET_TASK_PANE_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = { taskPaneVisible: data };
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
    }
    return state;
}
var SELECTION_DIALOG_HEIGHT = 300;
var LEGEND_DIALOG_HEIGHT = 400;
var TASK_DIALOG_HEIGHT = 500;
var STATUS_BAR_HEIGHT = 18;
/**
 * A viewer template that resembles the Aqua Fusion template
 */
var AquaTemplateLayout = function () {
    var _a = (0, hooks_1.useCommonTemplateState)(aquaTemplateReducer), locale = _a.locale, capabilities = _a.capabilities, showSelection = _a.showSelection, showLegend = _a.showLegend, showTaskPane = _a.showTaskPane, dispatch = _a.dispatch;
    var map = (0, hooks_mapguide_1.useActiveMapState)();
    var subject = (0, hooks_generic_1.useActiveMapSubjectLayer)();
    var hideLegend = function () { return dispatch((0, template_1.setLegendVisibility)(false)); };
    var hideSelection = function () { return dispatch((0, template_1.setSelectionPanelVisibility)(false)); };
    var hideTaskPane = function () { return dispatch((0, template_1.setTaskPaneVisibility)(false)); };
    var onHideTaskPane = function () { return hideTaskPane(); };
    var onHideLegend = function () { return hideLegend(); };
    var onHideSelection = function () { return hideSelection(); };
    var hasTaskPane = false;
    var hasStatusBar = false;
    var hasNavigator = false;
    var hasSelectionPanel = false;
    var hasLegend = false;
    if (capabilities) {
        hasTaskPane = capabilities.hasTaskPane;
        hasStatusBar = capabilities.hasStatusBar;
        hasNavigator = capabilities.hasNavigator;
        hasSelectionPanel = capabilities.hasSelectionPanel;
        hasLegend = capabilities.hasLegend;
    }
    var bottomOffset = hasStatusBar ? STATUS_BAR_HEIGHT : 0;
    var left = toolbar_1.DEFAULT_TOOLBAR_SIZE;
    var right = 0;
    /*
    if (hasLegend || hasSelectionPanel) {
        left = sbWidth;
    }
    if (hasTaskPane) {
        right = tpWidth;
    }*/
    var TB_Z_INDEX = 0;
    var initInfoPaneWidth = (0, hooks_2.useTemplateInitialInfoPaneWidth)();
    var initTaskPaneWidth = (0, hooks_2.useTemplateInitialTaskPaneWidth)();
    return React.createElement("div", { style: { width: "100%", height: "100%" } },
        React.createElement(toolbar_2.ToolbarContainer, { id: "FileMenu", containerClass: "aqua-file-menu", containerStyle: { position: "absolute", left: 0, top: 0, zIndex: TB_Z_INDEX, right: 0 } }),
        React.createElement(toolbar_2.ToolbarContainer, { id: "Toolbar", containerClass: "aqua-toolbar", containerStyle: { position: "absolute", left: 0, top: toolbar_1.DEFAULT_TOOLBAR_SIZE, height: toolbar_1.DEFAULT_TOOLBAR_SIZE, zIndex: TB_Z_INDEX, right: 0 } }),
        React.createElement(toolbar_2.ToolbarContainer, { id: "ToolbarVertical", containerClass: "aqua-toolbar-vertical", vertical: true, containerStyle: { position: "absolute", left: 0, top: ((toolbar_1.DEFAULT_TOOLBAR_SIZE * 2) - 1), zIndex: TB_Z_INDEX, bottom: bottomOffset } }),
        React.createElement("div", { style: { position: "absolute", left: left, top: (toolbar_1.DEFAULT_TOOLBAR_SIZE * 2), bottom: bottomOffset, right: right } },
            (function () {
                //NOTE: We have to delay render this behind an IIFE because otherwise this component may be mounted with
                //sidebar elements not being ready, which may result in a distorted OL map when it mounts, requiring a updateSize()
                //call to fix
                var theMap = map !== null && map !== void 0 ? map : subject;
                if (theMap) {
                    return React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Map, locale: locale });
                }
            })(),
            (function () {
                if (hasNavigator) {
                    return React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Navigator, locale: locale });
                }
            })()),
        (function () {
            if (hasStatusBar) {
                return React.createElement("div", { className: "aqua-status-bar", style: { position: "absolute", left: 0, bottom: 0, right: 0, height: bottomOffset } },
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.MouseCoordinates, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.ScaleDisplay, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.SelectedFeatureCount, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.ViewSize, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.PoweredByMapGuide, locale: locale }));
            }
        })(),
        React.createElement(viewer_shim_1.ViewerApiShim, null),
        React.createElement(modal_launcher_1.ModalLauncher, null,
            (function () {
                if (hasSelectionPanel) {
                    return React.createElement(modal_dialog_1.RndModalDialog, { icon: "th", locale: locale, isOpen: !!showSelection, onClose: onHideSelection, title: (0, i18n_1.tr)("TPL_TITLE_SELECTION_PANEL", locale), x: 40, y: 500, width: initInfoPaneWidth, height: SELECTION_DIALOG_HEIGHT, disableYOverflow: true, enableInteractionMask: true }, function (_a) {
                        var h = _a[1];
                        return React.createElement(component_1.PlaceholderComponent, { locale: locale, id: component_1.DefaultComponentNames.SelectionPanel, componentProps: { maxHeight: h } });
                    });
                }
            })(),
            (function () {
                if (hasLegend) {
                    return React.createElement(modal_dialog_1.RndModalDialog, { icon: "layers", locale: locale, isOpen: !!showLegend, onClose: onHideLegend, title: (0, i18n_1.tr)("TPL_TITLE_LEGEND", locale), x: 40, y: 70, width: initInfoPaneWidth, height: LEGEND_DIALOG_HEIGHT, enableInteractionMask: true }, function (_a) {
                        var h = _a[1];
                        return React.createElement(component_1.PlaceholderComponent, { locale: locale, id: component_1.DefaultComponentNames.Legend, componentProps: { inlineBaseLayerSwitcher: false, maxHeight: h } });
                    });
                }
            })(),
            (function () {
                if (hasTaskPane) {
                    return React.createElement(modal_dialog_1.RndModalDialog, { icon: "application", locale: locale, isOpen: !!showTaskPane, onClose: onHideTaskPane, width: initTaskPaneWidth, height: TASK_DIALOG_HEIGHT, title: (0, i18n_1.tr)("TPL_TITLE_TASKPANE", locale), x: document.body.clientWidth - initTaskPaneWidth - 70, y: 80, disableYOverflow: true, enableInteractionMask: false }, function (_a) {
                        var h = _a[1];
                        return React.createElement(component_1.PlaceholderComponent, { locale: locale, id: component_1.DefaultComponentNames.TaskPane, componentProps: { maxHeight: h - 15 /* some height breathing space */ } });
                    });
                }
            })()),
        React.createElement(flyout_region_1.FlyoutRegionContainer, null),
        React.createElement(init_warning_display_1.InitWarningDisplay, null));
};
exports.AquaTemplateLayout = AquaTemplateLayout;


/***/ }),

/***/ "./src/layouts/generic.tsx":
/*!*********************************!*\
  !*** ./src/layouts/generic.tsx ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenericLayout = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var component_1 = __webpack_require__(/*! ../api/registry/component */ "./src/api/registry/component.tsx");
var viewer_shim_1 = __webpack_require__(/*! ../containers/viewer-shim */ "./src/containers/viewer-shim.tsx");
var modal_launcher_1 = __webpack_require__(/*! ../containers/modal-launcher */ "./src/containers/modal-launcher.tsx");
var flyout_region_1 = __webpack_require__(/*! ../containers/flyout-region */ "./src/containers/flyout-region.tsx");
var init_warning_display_1 = __webpack_require__(/*! ../containers/init-warning-display */ "./src/containers/init-warning-display.tsx");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var map_1 = __webpack_require__(/*! ../actions/map */ "./src/actions/map.ts");
var command_1 = __webpack_require__(/*! ../api/registry/command */ "./src/api/registry/command.ts");
var hooks_1 = __webpack_require__(/*! ../containers/hooks */ "./src/containers/hooks.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
var hooks_mapguide_1 = __webpack_require__(/*! ../containers/hooks-mapguide */ "./src/containers/hooks-mapguide.ts");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var hooks_2 = __webpack_require__(/*! ./hooks */ "./src/layouts/hooks.ts");
var MapToolbar = function (props) {
    var locale = props.locale, featureTooltipsEnabled = props.featureTooltipsEnabled, hasSelection = props.hasSelection, map = props.map, onInvokeCommand = props.onInvokeCommand, onSetActiveTool = props.onSetActiveTool, activeTool = props.activeTool, isLayerManagerOpen = props.isLayerManagerOpen, setIsLayerManagerOpen = props.setIsLayerManagerOpen, setIsLegendOpen = props.setIsLegendOpen, setIsSelectionPanelOpen = props.setIsSelectionPanelOpen, onSetFeatureTooltips = props.onSetFeatureTooltips;
    var context = (0, context_1.useMapProviderContext)();
    var _a = React.useState(false), isExportingImage = _a[0], setIsExportingImage = _a[1];
    return React.createElement(React.Fragment, null,
        React.createElement(core_1.ButtonGroup, { vertical: true, style: { position: "absolute", left: 30, top: 30 } },
            React.createElement(core_1.Button, { icon: "plus", title: (0, i18n_1.tr)("NAVIGATOR_ZOOM_IN"), onClick: function () { return onInvokeCommand(command_1.DefaultCommands.ZoomIn); } }),
            React.createElement(core_1.Button, { icon: "minus", title: (0, i18n_1.tr)("NAVIGATOR_ZOOM_OUT"), onClick: function () { return onInvokeCommand(command_1.DefaultCommands.ZoomOut); } }),
            React.createElement(core_1.Button, { icon: "hand", intent: activeTool == common_1.ActiveMapTool.Pan ? core_1.Intent.PRIMARY : core_1.Intent.NONE, onClick: function () { return onInvokeCommand(command_1.DefaultCommands.Pan); } }),
            React.createElement(core_1.Button, { icon: "zoom-to-fit", title: (0, i18n_1.tr)("LAYER_MANAGER_TT_ZOOM_EXTENTS"), onClick: function () { return onInvokeCommand(command_1.DefaultCommands.ZoomExtents); } }),
            React.createElement(core_1.Button, { icon: "select", intent: activeTool == common_1.ActiveMapTool.Select ? core_1.Intent.PRIMARY : core_1.Intent.NONE, onClick: function () { return onSetActiveTool(common_1.ActiveMapTool.Select); } }),
            React.createElement(core_1.Button, { icon: "layers", title: (0, i18n_1.tr)("MANAGE_LAYERS", locale), intent: isLayerManagerOpen ? core_1.Intent.PRIMARY : core_1.Intent.NONE, onClick: function () { return setIsLayerManagerOpen(!isLayerManagerOpen); } }),
            map && React.createElement(core_1.Button, { icon: "comment", title: (0, i18n_1.tr)("FEATURE_TOOLTIPS", locale), intent: featureTooltipsEnabled ? core_1.Intent.PRIMARY : core_1.Intent.NONE, onClick: function () { return onSetFeatureTooltips(!featureTooltipsEnabled); } }),
            React.createElement(core_1.Button, { icon: "th", intent: hasSelection ? core_1.Intent.SUCCESS : core_1.Intent.NONE, title: (0, i18n_1.tr)("TPL_TITLE_SELECTION_PANEL", locale), onClick: function () { return setIsSelectionPanelOpen(true); } }),
            map && React.createElement(core_1.Button, { icon: "properties", title: (0, i18n_1.tr)("TPL_TITLE_LEGEND", locale), onClick: function () { return setIsLegendOpen(true); } }),
            React.createElement(core_1.Popover, { usePortal: false, position: "right", minimal: false },
                React.createElement(core_1.Button, { icon: "map" }),
                React.createElement(core_1.Card, { interactive: true, elevation: core_1.Elevation.TWO, style: { minWidth: 200 } },
                    React.createElement("h5", { className: "bp3-heading" },
                        React.createElement("a", { href: "#" }, "Active Base Layer")),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.BaseMapSwitcher, locale: locale }),
                    React.createElement("h5", { className: "bp3-heading" },
                        React.createElement("a", { href: "#" }, "Current Map")),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.MapMenu, locale: locale }))),
            React.createElement(core_1.Popover, { usePortal: false, position: "right", minimal: false },
                React.createElement(core_1.Button, { icon: "cog", title: (0, i18n_1.tr)("VIEWER_OPTIONS", locale) }),
                React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.ViewerOptions })),
            React.createElement(core_1.Button, { icon: "print", onClick: function () { return onInvokeCommand(command_1.DefaultCommands.Print); } })));
};
/**
 * A viewer template geared towards general purpose display of maps
 *
 * @since 0.14
 */
var GenericLayout = function () {
    var _a = React.useState(false), isLayerManagerOpen = _a[0], setIsLayerManagerOpen = _a[1];
    var _b = React.useState(false), isLegendOpen = _b[0], setIsLegendOpen = _b[1];
    var _c = React.useState(false), isSelectionPanelOpen = _c[0], setIsSelectionPanelOpen = _c[1];
    var _d = (0, hooks_2.useCommonTemplateState)(), locale = _d.locale, dispatch = _d.dispatch;
    var map = (0, hooks_mapguide_1.useActiveMapState)();
    var tbState = (0, hooks_1.useReducedToolbarAppState)();
    //console.log("tbState", tbState.hasClientSelection, tbState.hasSelection);
    var activeTool = (0, hooks_1.useViewerActiveTool)();
    var onInvokeCommand = function (name) {
        var cmd = (0, command_1.getCommand)(name);
        if (cmd) {
            dispatch((0, map_1.invokeCommand)(cmd));
        }
    };
    var onSetActiveTool = function (tool) {
        dispatch((0, map_1.setActiveTool)(common_1.ActiveMapTool.Select));
    };
    var onSetFeatureTooltips = function (flag) {
        dispatch((0, map_1.setFeatureTooltipsEnabled)(flag));
    };
    return React.createElement("div", { style: { width: "100%", height: "100%" } },
        React.createElement(modal_launcher_1.ModalLauncher, null),
        React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Map, locale: locale, componentProps: {
                // MapToolbar has to be a child component, otherwise the map provider context is not accessible
                children: React.createElement(MapToolbar, { locale: locale, featureTooltipsEnabled: tbState.featureTooltipsEnabled, hasSelection: tbState.hasClientSelection || tbState.hasSelection, map: map, activeTool: activeTool, isLayerManagerOpen: isLayerManagerOpen, setIsLegendOpen: function (f) { return setIsLegendOpen(f); }, setIsSelectionPanelOpen: function (f) { return setIsSelectionPanelOpen(f); }, setIsLayerManagerOpen: function (f) { return setIsLayerManagerOpen(f); }, onInvokeCommand: onInvokeCommand, onSetActiveTool: onSetActiveTool, onSetFeatureTooltips: onSetFeatureTooltips })
            } }),
        React.createElement(core_1.Drawer, { icon: "layers", size: core_1.DrawerSize.SMALL, canOutsideClickClose: true, onClose: function () { return setIsLayerManagerOpen(false); }, title: (0, i18n_1.tr)("MANAGE_LAYERS", locale), position: core_1.Position.LEFT, usePortal: false, isOpen: isLayerManagerOpen },
            React.createElement("div", { style: { overflowY: "auto" } },
                React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.AddManageLayers, locale: locale }))),
        React.createElement(core_1.Drawer, { icon: "properties", size: core_1.DrawerSize.SMALL, canOutsideClickClose: true, onClose: function () { return setIsLegendOpen(false); }, title: (0, i18n_1.tr)("TPL_TITLE_LEGEND", locale), position: core_1.Position.LEFT, usePortal: false, isOpen: isLegendOpen },
            React.createElement("div", { style: { overflowY: "auto" } },
                React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Legend, locale: locale }))),
        React.createElement(core_1.Drawer, { icon: "th", size: core_1.DrawerSize.SMALL, canOutsideClickClose: true, onClose: function () { return setIsSelectionPanelOpen(false); }, title: (0, i18n_1.tr)("TPL_TITLE_SELECTION_PANEL", locale), position: core_1.Position.LEFT, usePortal: false, isOpen: isSelectionPanelOpen },
            React.createElement("div", { style: { width: "100%", height: "100%", position: "relative" } },
                React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.SelectionPanel, locale: locale }))),
        React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Navigator, locale: locale }),
        React.createElement(viewer_shim_1.ViewerApiShim, null),
        React.createElement(flyout_region_1.FlyoutRegionContainer, null),
        React.createElement(init_warning_display_1.InitWarningDisplay, null),
        React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.MouseCoordinates, locale: locale }));
};
exports.GenericLayout = GenericLayout;


/***/ }),

/***/ "./src/layouts/hooks.ts":
/*!******************************!*\
  !*** ./src/layouts/hooks.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.useCommonTemplateState = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var hooks_1 = __webpack_require__(/*! ../containers/hooks */ "./src/containers/hooks.ts");
var template_1 = __webpack_require__(/*! ../reducers/template */ "./src/reducers/template.ts");
var runtime_1 = __webpack_require__(/*! ../api/runtime */ "./src/api/runtime.ts");
var template_2 = __webpack_require__(/*! ../actions/template */ "./src/actions/template.ts");
var context_1 = __webpack_require__(/*! ../components/map-providers/context */ "./src/components/map-providers/context.tsx");
function useCommonTemplateState(templateReducer) {
    //TODO: To promote more reusability, the resizing flag should be defined and set on a 
    //dispatcher-defined basis.
    //
    //ie. A template could have more than 1 resizing flag. Right now, the AJAX viewer template is
    //one such template, which awkwardly shows "Task Pane is resizing" UI when resizing the info pane
    //(on the opposite side of the task pane!) due to this current limitation when it uses this hook
    var _a = React.useState(false), isResizing = _a[0], setIsResizing = _a[1];
    var locale = (0, hooks_1.useViewerLocale)();
    var capabilities = (0, hooks_1.useConfiguredCapabilities)();
    var showSelection = (0, hooks_1.useTemplateSelectionVisible)();
    var showLegend = (0, hooks_1.useTemplateLegendVisible)();
    var showTaskPane = (0, hooks_1.useTemplateTaskPaneVisible)();
    var dispatch = (0, context_1.useReduxDispatch)();
    var setElementStatesAction = function (states) { return dispatch((0, template_2.setElementStates)(states)); };
    var onDragStart = function () { return setIsResizing(true); };
    var onDragEnd = function () { return setIsResizing(false); };
    //componentDidMount
    React.useEffect(function () {
        if (templateReducer) {
            (0, template_1.setCustomTemplateReducer)(templateReducer);
        }
    }, []);
    var onSplitterChanged = function () {
        //With the introduction of the splitter, we can no longer rely on a map 
        //filling 100% of its space without needing to manually call updateSize(),
        //so we do it here
        var viewer = (0, runtime_1.getViewer)();
        if (viewer) {
            viewer.updateSize();
        }
    };
    var onActiveElementChanged = function (id) {
        var states = {
            legendVisible: false,
            taskPaneVisible: false,
            selectionPanelVisible: false
        };
        switch (id) {
            case "Legend":
                states.legendVisible = true;
                break;
            case "TaskPane":
                states.taskPaneVisible = true;
                break;
            case "Selection":
                states.selectionPanelVisible = true;
                break;
        }
        //One of these must be true
        if (states.legendVisible || states.taskPaneVisible || states.selectionPanelVisible)
            setElementStatesAction(states);
    };
    return {
        isResizing: isResizing,
        setIsResizing: setIsResizing,
        locale: locale,
        capabilities: capabilities,
        showSelection: showSelection,
        showLegend: showLegend,
        showTaskPane: showTaskPane,
        onDragStart: onDragStart,
        onDragEnd: onDragEnd,
        onSplitterChanged: onSplitterChanged,
        onActiveElementChanged: onActiveElementChanged,
        dispatch: dispatch
    };
}
exports.useCommonTemplateState = useCommonTemplateState;


/***/ }),

/***/ "./src/layouts/limegold.tsx":
/*!**********************************!*\
  !*** ./src/layouts/limegold.tsx ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LimeGoldTemplateLayout = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var component_1 = __webpack_require__(/*! ../api/registry/component */ "./src/api/registry/component.tsx");
var toolbar_1 = __webpack_require__(/*! ../components/toolbar */ "./src/components/toolbar.tsx");
var toolbar_2 = __webpack_require__(/*! ../containers/toolbar */ "./src/containers/toolbar.tsx");
var viewer_shim_1 = __webpack_require__(/*! ../containers/viewer-shim */ "./src/containers/viewer-shim.tsx");
var modal_launcher_1 = __webpack_require__(/*! ../containers/modal-launcher */ "./src/containers/modal-launcher.tsx");
var flyout_region_1 = __webpack_require__(/*! ../containers/flyout-region */ "./src/containers/flyout-region.tsx");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var template_1 = __webpack_require__(/*! ../reducers/template */ "./src/reducers/template.ts");
var init_warning_display_1 = __webpack_require__(/*! ../containers/init-warning-display */ "./src/containers/init-warning-display.tsx");
var react_splitter_layout_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! react-splitter-layout */ "./node_modules/react-splitter-layout/lib/index.js"));
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/layouts/hooks.ts");
var hooks_2 = __webpack_require__(/*! ../containers/hooks */ "./src/containers/hooks.ts");
function limegoldTemplateReducer(origState, state, action) {
    switch (action.type) {
        case actions_1.ActionType.FUSION_SET_LEGEND_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = void 0;
                    if (data === true) {
                        state1 = { legendVisible: true, taskPaneVisible: false, selectionPanelVisible: false };
                    }
                    else {
                        state1 = { legendVisible: data };
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.FUSION_SET_SELECTION_PANEL_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = void 0;
                    if (data === true) {
                        state1 = { legendVisible: false, taskPaneVisible: false, selectionPanelVisible: true };
                    }
                    else {
                        state1 = { selectionPanelVisible: data };
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.TASK_INVOKE_URL:
            {
                var state1 = { taskPaneVisible: true, selectionPanelVisible: false, legendVisible: false };
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
            }
        case actions_1.ActionType.FUSION_SET_TASK_PANE_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = void 0;
                    if (data === true) {
                        state1 = { legendVisible: false, taskPaneVisible: true, selectionPanelVisible: false };
                    }
                    else {
                        state1 = { taskPaneVisible: data };
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.FUSION_SET_ELEMENT_STATE:
            {
                var data = action.payload;
                if ((0, template_1.isElementState)(data)) {
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), data);
                }
            }
    }
    return state;
}
var SIDEBAR_PADDING = 0;
var TOP_BAR_HEIGHT = 35;
var TAB_BAR_HEIGHT = 30;
var STATUS_BAR_HEIGHT = 18;
/**
 * A viewer template that resembles the LimeGold Fusion template
 */
var LimeGoldTemplateLayout = function () {
    var _a = (0, hooks_1.useCommonTemplateState)(limegoldTemplateReducer), isResizing = _a.isResizing, locale = _a.locale, capabilities = _a.capabilities, showSelection = _a.showSelection, showLegend = _a.showLegend, showTaskPane = _a.showTaskPane, onDragStart = _a.onDragStart, onDragEnd = _a.onDragEnd, onSplitterChanged = _a.onSplitterChanged, onActiveElementChanged = _a.onActiveElementChanged;
    var hasTaskPane = false;
    var hasStatusBar = false;
    var hasNavigator = false;
    var hasSelectionPanel = false;
    var hasLegend = false;
    if (capabilities) {
        hasTaskPane = capabilities.hasTaskPane;
        hasStatusBar = capabilities.hasStatusBar;
        hasNavigator = capabilities.hasNavigator;
        hasSelectionPanel = capabilities.hasSelectionPanel;
        hasLegend = capabilities.hasLegend;
    }
    var bottomOffset = hasStatusBar ? STATUS_BAR_HEIGHT : 0;
    var topOffset = (TOP_BAR_HEIGHT + (toolbar_1.DEFAULT_TOOLBAR_SIZE * 2));
    var initInfoPaneWidth = (0, hooks_2.useTemplateInitialInfoPaneWidth)();
    var initTaskPaneWidth = (0, hooks_2.useTemplateInitialTaskPaneWidth)();
    var sbWidth = Math.max(initInfoPaneWidth, initTaskPaneWidth);
    var tabPanelStyle = {
        position: "absolute",
        top: TAB_BAR_HEIGHT,
        left: 0,
        right: 0,
        bottom: 0
    };
    var states = [
        { id: "Selection", visible: showSelection },
        { id: "TaskPane", visible: showTaskPane },
        { id: "Legend", visible: showLegend }
    ];
    var active = states.filter(function (st) { return st.visible; });
    var extraTabsProps = {};
    if (active.length == 1) {
        extraTabsProps.selectedTabId = active[0].id;
    }
    var taskPaneTitle = (0, i18n_1.tr)("TPL_TITLE_TASKPANE", locale);
    var legendTitle = (0, i18n_1.tr)("TPL_TITLE_LEGEND", locale);
    var selectionTitle = (0, i18n_1.tr)("TPL_TITLE_SELECTION_PANEL", locale);
    var TB_Z_INDEX = 0;
    return React.createElement("div", { style: { width: "100%", height: "100%" } },
        React.createElement(toolbar_2.ToolbarContainer, { id: "FileMenu", containerClass: "limegold-file-menu", containerStyle: { position: "absolute", left: 0, top: ((TOP_BAR_HEIGHT - toolbar_1.DEFAULT_TOOLBAR_SIZE) / 2), zIndex: TB_Z_INDEX, right: 0 } }),
        React.createElement(toolbar_2.ToolbarContainer, { id: "Toolbar", containerClass: "limegold-toolbar", containerStyle: { position: "absolute", left: 0, top: TOP_BAR_HEIGHT, zIndex: TB_Z_INDEX, right: 0 } }),
        React.createElement(toolbar_2.ToolbarContainer, { id: "ToolbarSecondary", containerClass: "limegold-toolbar-secondary", containerStyle: { position: "absolute", left: 0, top: (TOP_BAR_HEIGHT + toolbar_1.DEFAULT_TOOLBAR_SIZE), zIndex: TB_Z_INDEX, right: 0 } }),
        React.createElement("div", { style: { position: "absolute", left: 0, top: topOffset, bottom: (bottomOffset + SIDEBAR_PADDING), right: 0 } },
            React.createElement(react_splitter_layout_1.default, { customClassName: "limegold-splitter", primaryIndex: 0, secondaryInitialSize: sbWidth, onSecondaryPaneSizeChange: onSplitterChanged, onDragStart: onDragStart, onDragEnd: onDragEnd },
                React.createElement("div", { style: { position: "absolute", left: 0, right: 0, top: 0, bottom: 0 } },
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Map, locale: locale }),
                    (function () {
                        if (hasNavigator) {
                            return React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Navigator, locale: locale });
                        }
                    })()),
                (function () {
                    if (showSelection || showTaskPane || showLegend) {
                        return React.createElement("div", { className: "limegold-sidebar", style: { position: "absolute", right: SIDEBAR_PADDING, top: 0, left: 0, bottom: 0 } },
                            React.createElement(core_1.Tabs, (0, tslib_1.__assign)({ className: "limegold-sidebar-tabs", id: "SidebarTabs", onChange: onActiveElementChanged }, extraTabsProps),
                                (function () {
                                    if (hasTaskPane) {
                                        var panel = React.createElement("div", { style: tabPanelStyle },
                                            React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.TaskPane, locale: locale, componentProps: { isResizing: isResizing } }));
                                        return React.createElement(core_1.Tab, { id: "TaskPane", title: taskPaneTitle, panel: panel });
                                    }
                                })(),
                                (function () {
                                    if (hasLegend) {
                                        var p1 = { overflow: "auto" };
                                        var panel = React.createElement("div", { style: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, tabPanelStyle), p1) },
                                            React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Legend, locale: locale, componentProps: { inlineBaseLayerSwitcher: false } }));
                                        return React.createElement(core_1.Tab, { id: "Legend", title: legendTitle, panel: panel });
                                    }
                                })(),
                                (function () {
                                    if (hasSelectionPanel) {
                                        var panel = React.createElement("div", { style: tabPanelStyle },
                                            React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.SelectionPanel, locale: locale }));
                                        return React.createElement(core_1.Tab, { id: "Selection", title: selectionTitle, panel: panel });
                                    }
                                })()));
                    }
                })())),
        (function () {
            if (hasStatusBar) {
                return React.createElement("div", { className: "limegold-status-bar", style: { position: "absolute", left: 0, bottom: 0, right: 0, height: bottomOffset } },
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.MouseCoordinates, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.ScaleDisplay, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.SelectedFeatureCount, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.ViewSize, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.PoweredByMapGuide, locale: locale }));
            }
        })(),
        React.createElement(viewer_shim_1.ViewerApiShim, null),
        React.createElement(modal_launcher_1.ModalLauncher, null),
        React.createElement(flyout_region_1.FlyoutRegionContainer, null),
        React.createElement(init_warning_display_1.InitWarningDisplay, null));
};
exports.LimeGoldTemplateLayout = LimeGoldTemplateLayout;


/***/ }),

/***/ "./src/layouts/maroon.tsx":
/*!********************************!*\
  !*** ./src/layouts/maroon.tsx ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MaroonTemplateLayout = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var component_1 = __webpack_require__(/*! ../api/registry/component */ "./src/api/registry/component.tsx");
var toolbar_1 = __webpack_require__(/*! ../components/toolbar */ "./src/components/toolbar.tsx");
var toolbar_2 = __webpack_require__(/*! ../containers/toolbar */ "./src/containers/toolbar.tsx");
var viewer_shim_1 = __webpack_require__(/*! ../containers/viewer-shim */ "./src/containers/viewer-shim.tsx");
var modal_launcher_1 = __webpack_require__(/*! ../containers/modal-launcher */ "./src/containers/modal-launcher.tsx");
var flyout_region_1 = __webpack_require__(/*! ../containers/flyout-region */ "./src/containers/flyout-region.tsx");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var accordion_1 = __webpack_require__(/*! ../components/accordion */ "./src/components/accordion.tsx");
var template_1 = __webpack_require__(/*! ../reducers/template */ "./src/reducers/template.ts");
var init_warning_display_1 = __webpack_require__(/*! ../containers/init-warning-display */ "./src/containers/init-warning-display.tsx");
var react_splitter_layout_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! react-splitter-layout */ "./node_modules/react-splitter-layout/lib/index.js"));
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/layouts/hooks.ts");
var hooks_2 = __webpack_require__(/*! ../containers/hooks */ "./src/containers/hooks.ts");
function maroonTemplateReducer(origState, state, action) {
    switch (action.type) {
        case actions_1.ActionType.FUSION_SET_LEGEND_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = void 0;
                    if (data === true) {
                        state1 = { legendVisible: true, taskPaneVisible: false, selectionPanelVisible: false };
                    }
                    else {
                        state1 = { legendVisible: data };
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.FUSION_SET_SELECTION_PANEL_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = void 0;
                    if (data === true) {
                        state1 = { legendVisible: false, taskPaneVisible: false, selectionPanelVisible: true };
                    }
                    else {
                        state1 = { selectionPanelVisible: data };
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.TASK_INVOKE_URL:
            {
                var state1 = { taskPaneVisible: true, selectionPanelVisible: false, legendVisible: false };
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
            }
        case actions_1.ActionType.FUSION_SET_TASK_PANE_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = void 0;
                    if (data === true) {
                        state1 = { legendVisible: false, taskPaneVisible: true, selectionPanelVisible: false };
                    }
                    else {
                        state1 = { taskPaneVisible: data };
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.FUSION_SET_ELEMENT_STATE:
            {
                var data = action.payload;
                if ((0, template_1.isElementState)(data)) {
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), data);
                }
            }
    }
    return state;
}
var STATUS_BAR_HEIGHT = 18;
var OUTER_PADDING = 3;
/**
 * A viewer template that resembles the Maroon Fusion template
 */
var MaroonTemplateLayout = function () {
    var _a = (0, hooks_1.useCommonTemplateState)(maroonTemplateReducer), isResizing = _a.isResizing, locale = _a.locale, capabilities = _a.capabilities, showSelection = _a.showSelection, showLegend = _a.showLegend, showTaskPane = _a.showTaskPane, onDragStart = _a.onDragStart, onDragEnd = _a.onDragEnd, onSplitterChanged = _a.onSplitterChanged, onActiveElementChanged = _a.onActiveElementChanged;
    var hasStatusBar = false;
    var hasNavigator = false;
    if (capabilities) {
        hasStatusBar = capabilities.hasStatusBar;
        hasNavigator = capabilities.hasNavigator;
    }
    var bottomOffset = hasStatusBar ? STATUS_BAR_HEIGHT : 0;
    var topOffset = (toolbar_1.DEFAULT_TOOLBAR_SIZE * 2) + OUTER_PADDING;
    var panels = [
        {
            id: "Legend",
            title: (0, i18n_1.tr)("TPL_TITLE_LEGEND", locale),
            contentRenderer: function (dim) {
                return React.createElement("div", { style: { width: dim.width, height: dim.height, overflowY: "auto" } },
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Legend, locale: locale, componentProps: { inlineBaseLayerSwitcher: false } }));
            }
        },
        {
            id: "Selection",
            title: (0, i18n_1.tr)("TPL_TITLE_SELECTION_PANEL", locale),
            contentRenderer: function (dim) {
                return React.createElement("div", { style: { width: dim.width, height: dim.height, overflowY: "auto" } },
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.SelectionPanel, locale: locale }));
            }
        },
        {
            id: "TaskPane",
            title: (0, i18n_1.tr)("TPL_TITLE_TASKPANE", locale),
            contentRenderer: function (dim, isResizing) {
                return React.createElement("div", { style: { width: dim.width, height: dim.height, overflowY: "auto" } },
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.TaskPane, locale: locale, componentProps: { isResizing: isResizing } }));
            }
        }
    ];
    var activeId;
    var states = [
        { id: "Selection", visible: showSelection },
        { id: "TaskPane", visible: showTaskPane },
        { id: "Legend", visible: showLegend }
    ];
    var active = states.filter(function (st) { return st.visible; });
    if (active.length == 1) {
        activeId = active[0].id;
    }
    var initInfoPaneWidth = (0, hooks_2.useTemplateInitialInfoPaneWidth)();
    var initTaskPaneWidth = (0, hooks_2.useTemplateInitialTaskPaneWidth)();
    var sbWidth = Math.max(initInfoPaneWidth, initTaskPaneWidth);
    var TB_Z_INDEX = 0;
    return React.createElement("div", { style: { width: "100%", height: "100%" } },
        React.createElement("div", { style: { position: "absolute", left: 0, top: 0, bottom: bottomOffset, right: 0 } },
            React.createElement(react_splitter_layout_1.default, { customClassName: "maroon-splitter", primaryIndex: 0, secondaryInitialSize: sbWidth, onSecondaryPaneSizeChange: onSplitterChanged, onDragStart: onDragStart, onDragEnd: onDragEnd },
                React.createElement("div", null,
                    React.createElement(toolbar_2.ToolbarContainer, { id: "FileMenu", containerClass: "maroon-file-menu", containerStyle: { position: "absolute", left: OUTER_PADDING, top: OUTER_PADDING, right: 0, zIndex: TB_Z_INDEX } }),
                    React.createElement(toolbar_2.ToolbarContainer, { id: "Toolbar", containerClass: "maroon-toolbar", containerStyle: { position: "absolute", left: OUTER_PADDING, top: toolbar_1.DEFAULT_TOOLBAR_SIZE + OUTER_PADDING, right: 0, zIndex: TB_Z_INDEX } }),
                    React.createElement(toolbar_2.ToolbarContainer, { id: "ToolbarVertical", containerClass: "maroon-toolbar-vertical", vertical: true, containerStyle: { position: "absolute", left: OUTER_PADDING, top: topOffset, bottom: 0, zIndex: TB_Z_INDEX, right: 0 } }),
                    React.createElement("div", { style: { position: "absolute", left: OUTER_PADDING + toolbar_1.DEFAULT_TOOLBAR_SIZE, right: 0, top: topOffset, bottom: 0 } },
                        React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Map, locale: locale }),
                        (function () {
                            if (hasNavigator) {
                                return React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Navigator, locale: locale });
                            }
                        })())),
                (function () {
                    if (showSelection || showTaskPane || showLegend) {
                        return React.createElement("div", null,
                            React.createElement(accordion_1.Accordion, { style: { position: "absolute", top: OUTER_PADDING, bottom: 0, right: OUTER_PADDING, left: 0 }, onActivePanelChanged: onActiveElementChanged, activePanelId: activeId, panels: panels, isResizing: isResizing }));
                    }
                })())),
        (function () {
            if (hasStatusBar) {
                return React.createElement("div", { className: "maroon-status-bar", style: { position: "absolute", left: 0, bottom: 0, right: 0, height: bottomOffset } },
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.MouseCoordinates, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.ScaleDisplay, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.SelectedFeatureCount, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.ViewSize, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.PoweredByMapGuide, locale: locale }));
            }
        })(),
        React.createElement(viewer_shim_1.ViewerApiShim, null),
        React.createElement(modal_launcher_1.ModalLauncher, null),
        React.createElement(flyout_region_1.FlyoutRegionContainer, null),
        React.createElement(init_warning_display_1.InitWarningDisplay, null));
};
exports.MaroonTemplateLayout = MaroonTemplateLayout;


/***/ }),

/***/ "./src/layouts/sidebar.tsx":
/*!*********************************!*\
  !*** ./src/layouts/sidebar.tsx ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SidebarLayout = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var component_1 = __webpack_require__(/*! ../api/registry/component */ "./src/api/registry/component.tsx");
var toolbar_1 = __webpack_require__(/*! ../containers/toolbar */ "./src/containers/toolbar.tsx");
var viewer_shim_1 = __webpack_require__(/*! ../containers/viewer-shim */ "./src/containers/viewer-shim.tsx");
var modal_launcher_1 = __webpack_require__(/*! ../containers/modal-launcher */ "./src/containers/modal-launcher.tsx");
var flyout_region_1 = __webpack_require__(/*! ../containers/flyout-region */ "./src/containers/flyout-region.tsx");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var init_warning_display_1 = __webpack_require__(/*! ../containers/init-warning-display */ "./src/containers/init-warning-display.tsx");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var hooks_1 = __webpack_require__(/*! ../containers/hooks */ "./src/containers/hooks.ts");
var hooks_2 = __webpack_require__(/*! ./hooks */ "./src/layouts/hooks.ts");
var template_1 = __webpack_require__(/*! ../reducers/template */ "./src/reducers/template.ts");
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
var ismobilejs_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! ismobilejs */ "./node_modules/ismobilejs/esm/index.js"));
var template_2 = __webpack_require__(/*! ../actions/template */ "./src/actions/template.ts");
function sidebarTemplateReducer(origState, state, action) {
    switch (action.type) {
        case actions_1.ActionType.MAP_SET_SELECTION:
            {
                //This is the only template that does not conform to the selection/legend/taskpane is a mutually
                //exclusive visible set. We take advantage of the custom template reducer function to apply the
                //correct visibility state against the *original state* effectively discarding whatever the root
                //template reducer has done against this action.
                var selection = action.payload.selection;
                if (selection && selection.SelectedFeatures) {
                    var autoExpandSelectionPanel = origState.autoDisplaySelectionPanelOnSelection;
                    var ism = (0, ismobilejs_1.default)(navigator.userAgent);
                    if (ism.phone) {
                        return origState; //Take no action on mobile
                    }
                    if (selection.SelectedFeatures.SelectedLayer.length && autoExpandSelectionPanel) {
                        return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, origState), { selectionPanelVisible: true, taskPaneVisible: false, legendVisible: false });
                    }
                }
                return state; //No action taken: Return "current" state
            }
        case actions_1.ActionType.MAP_ADD_CLIENT_SELECTED_FEATURE:
            {
                //This is the only template that does not conform to the selection/legend/taskpane is a mutually
                //exclusive visible set. We take advantage of the custom template reducer function to apply the
                //correct visibility state against the *original state* effectively discarding whatever the root
                //template reducer has done against this action.
                var feature = action.payload.feature;
                if (feature === null || feature === void 0 ? void 0 : feature.properties) {
                    var autoExpandSelectionPanel = origState.autoDisplaySelectionPanelOnSelection;
                    var ism = (0, ismobilejs_1.default)(navigator.userAgent);
                    if (ism.phone) {
                        return origState; //Take no action on mobile
                    }
                    if (autoExpandSelectionPanel) {
                        return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, origState), { selectionPanelVisible: true, taskPaneVisible: false, legendVisible: false });
                    }
                }
            }
        case actions_1.ActionType.FUSION_SET_LEGEND_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = void 0;
                    if (data === true) {
                        state1 = { legendVisible: true, taskPaneVisible: false, selectionPanelVisible: false };
                    }
                    else {
                        state1 = { legendVisible: data };
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.FUSION_SET_SELECTION_PANEL_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = void 0;
                    if (data === true) {
                        state1 = { legendVisible: false, taskPaneVisible: false, selectionPanelVisible: true };
                    }
                    else {
                        state1 = { selectionPanelVisible: data };
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.TASK_INVOKE_URL:
            {
                var state1 = { taskPaneVisible: true, selectionPanelVisible: false, legendVisible: false };
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
            }
        case actions_1.ActionType.FUSION_SET_TASK_PANE_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = void 0;
                    if (data === true) {
                        state1 = { legendVisible: false, taskPaneVisible: true, selectionPanelVisible: false };
                    }
                    else {
                        state1 = { taskPaneVisible: data };
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.FUSION_SET_ELEMENT_STATE:
            {
                var data = action.payload;
                if ((0, template_1.isElementState)(data)) {
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), data);
                }
            }
    }
    return state;
}
var SidebarHeader = function (props) {
    var sbHeaderStyle = {
        position: "absolute",
        top: 0,
        right: 0,
        height: 40,
        left: 0,
        margin: 0
    };
    sbHeaderStyle.paddingLeft = 10;
    return React.createElement("h1", { style: sbHeaderStyle, className: "sidebar-header" },
        props.text,
        React.createElement("span", { className: "sidebar-close", onClick: props.onCloseClick },
            React.createElement("i", { className: "icon-left-open" })));
};
var Sidebar = function (props) {
    var onActivateTasks = function (e) {
        var onActivateTab = props.onActivateTab;
        e.preventDefault();
        onActivateTab("tasks");
        return false;
    };
    var onActivateLegend = function (e) {
        var onActivateTab = props.onActivateTab;
        e.preventDefault();
        onActivateTab("legend");
        return false;
    };
    var onActivateSelection = function (e) {
        var onActivateTab = props.onActivateTab;
        e.preventDefault();
        onActivateTab("selection");
        return false;
    };
    var onClickCollapse = function (e) {
        var onCollapse = props.onCollapse;
        e.preventDefault();
        onCollapse();
        return false;
    };
    var onClickExpand = function (e) {
        var onExpand = props.onExpand;
        e.preventDefault();
        onExpand();
        return false;
    };
    var lastAction = (0, hooks_1.useLastDispatchedAction)();
    React.useEffect(function () {
        switch (lastAction.type) {
            case actions_1.ActionType.TASK_INVOKE_URL:
                {
                    props.onActivateTab("tasks", false);
                }
                break;
            case actions_1.ActionType.MAP_SET_SELECTION:
            case actions_1.ActionType.MAP_ADD_CLIENT_SELECTED_FEATURE:
                break;
        }
    }, [lastAction]);
    var position = props.position, busy = props.busy, collapsed = props.collapsed, activeTab = props.activeTab;
    return React.createElement("div", { className: "sidebar " + (collapsed ? "collapsed" : "") + " sidebar-" + position },
        React.createElement("div", { className: "sidebar-tabs" },
            React.createElement("ul", { role: "tablist" },
                React.createElement("li", null, (function () {
                    if (busy === true) {
                        return React.createElement("a", null,
                            React.createElement(core_1.Spinner, { intent: core_1.Intent.WARNING, size: core_1.Spinner.SIZE_SMALL }));
                    }
                    else {
                        if (collapsed) {
                            return React.createElement("a", { onClick: onClickExpand },
                                React.createElement(core_1.Icon, { icon: "menu-open" }));
                        }
                        else {
                            return React.createElement("a", { onClick: onClickCollapse },
                                React.createElement(core_1.Icon, { icon: "menu-closed" }));
                        }
                    }
                })()),
                (function () {
                    if (props.taskpane) {
                        return React.createElement("li", { className: collapsed == false && activeTab == "tasks" ? "active" : "" },
                            React.createElement("a", { onClick: onActivateTasks, title: (0, i18n_1.tr)("TPL_SIDEBAR_OPEN_TASKPANE", props.locale), role: "tab" },
                                React.createElement(core_1.Icon, { icon: "application" })));
                    }
                })(),
                (function () {
                    if (props.legend) {
                        return React.createElement("li", { className: collapsed == false && activeTab == "legend" ? "active" : "" },
                            React.createElement("a", { onClick: onActivateLegend, title: (0, i18n_1.tr)("TPL_SIDEBAR_OPEN_LEGEND", props.locale), role: "tab" },
                                React.createElement(core_1.Icon, { icon: "layers" })));
                    }
                })(),
                (function () {
                    if (props.selection) {
                        return React.createElement("li", { className: collapsed == false && activeTab == "selection" ? "active" : "" },
                            React.createElement("a", { onClick: onActivateSelection, title: (0, i18n_1.tr)("TPL_SIDEBAR_OPEN_SELECTION_PANEL", props.locale), role: "tab" },
                                React.createElement(core_1.Icon, { icon: "th" })),
                            props.hasSelection && React.createElement("div", { className: "sidebar-has-selection-badge" }, constants_1.NBSP));
                    }
                })(),
                React.createElement("li", { className: "sidebar-separator" }))),
        React.createElement("div", { className: "sidebar-content" },
            (function () {
                if (props.taskpane) {
                    return React.createElement("div", { className: "sidebar-pane " + (activeTab == "tasks" ? "active" : "") },
                        React.createElement(SidebarHeader, { text: (0, i18n_1.tr)("TPL_TITLE_TASKPANE", props.locale), onCloseClick: onClickCollapse }),
                        React.createElement("div", { style: { position: "absolute", top: 40, bottom: 0, right: 0, left: 0 } },
                            React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.TaskPane, locale: props.locale })));
                }
            })(),
            (function () {
                if (props.legend) {
                    return React.createElement("div", { className: "sidebar-pane " + (activeTab == "legend" ? "active" : "") },
                        React.createElement(SidebarHeader, { text: (0, i18n_1.tr)("TPL_TITLE_LEGEND", props.locale), onCloseClick: onClickCollapse }),
                        React.createElement("div", { style: { position: "absolute", top: 40, bottom: 0, right: 0, left: 0, overflow: "auto" } },
                            React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Legend, locale: props.locale, componentProps: { inlineBaseLayerSwitcher: true } })));
                }
            })(),
            (function () {
                if (props.selection) {
                    return React.createElement("div", { className: "sidebar-pane " + (activeTab == "selection" ? "active" : "") },
                        React.createElement(SidebarHeader, { text: (0, i18n_1.tr)("TPL_TITLE_SELECTION_PANEL", props.locale), onCloseClick: onClickCollapse }),
                        React.createElement("div", { style: { position: "absolute", top: 40, bottom: 0, right: 0, left: 0 } },
                            React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.SelectionPanel, locale: props.locale })));
                }
            })()));
};
/**
 * A viewer template that is based on the design of the {@link https://github.com/Turbo87/sidebar-v2 Sidebar Map Layout}
 */
var SidebarLayout = function () {
    var _a = (0, hooks_2.useCommonTemplateState)(sidebarTemplateReducer), dispatch = _a.dispatch, locale = _a.locale, capabilities = _a.capabilities, showSelection = _a.showSelection, showLegend = _a.showLegend, showTaskPane = _a.showTaskPane;
    var tbState = (0, hooks_1.useReducedToolbarAppState)();
    var setElementStatesAction = function (states) { return dispatch((0, template_2.setElementStates)(states)); };
    //console.log(`leg: ${showLegend}, sel: ${showSelection}, task: ${showTaskPane}`);
    var hasTaskPane = capabilities.hasTaskPane, hasStatusBar = capabilities.hasStatusBar, hasNavigator = capabilities.hasNavigator, hasSelectionPanel = capabilities.hasSelectionPanel, hasLegend = capabilities.hasLegend, hasViewSize = capabilities.hasViewSize, hasToolbar = capabilities.hasToolbar;
    var busyCount = (0, hooks_1.useViewerBusyCount)();
    var defaultActiveTab = "tasks";
    if (showLegend) {
        defaultActiveTab = "legend";
    }
    else if (showSelection) {
        defaultActiveTab = "selection";
    }
    var _b = React.useState(defaultActiveTab), activeTab = _b[0], setActiveTab = _b[1];
    // Need to apply an effect to update active tab from element states in the redux store
    React.useEffect(function () {
        var tab = "tasks";
        if (showLegend) {
            tab = "legend";
        }
        else if (showSelection) {
            tab = "selection";
        }
        setActiveTab(tab);
    }, [showLegend, showSelection, showTaskPane]);
    var onCollapse = function () {
        setElementStatesAction({
            taskPaneVisible: false,
            legendVisible: false,
            selectionPanelVisible: false
        });
    };
    var onExpand = function () {
        var est = {
            legendVisible: false,
            selectionPanelVisible: false,
            taskPaneVisible: false
        };
        switch (activeTab) {
            case "legend":
                est.legendVisible = true;
                break;
            case "selection":
                est.selectionPanelVisible = true;
                break;
            case "tasks":
                est.taskPaneVisible = true;
                break;
        }
        if (est.legendVisible || est.selectionPanelVisible || est.taskPaneVisible) {
            setElementStatesAction(est);
        }
    };
    var onActivateTab = function (tab) {
        var est = {
            legendVisible: false,
            selectionPanelVisible: false,
            taskPaneVisible: false
        };
        switch (tab) {
            case "legend":
                est.legendVisible = true;
                break;
            case "selection":
                est.selectionPanelVisible = true;
                break;
            case "tasks":
                est.taskPaneVisible = true;
                break;
        }
        if (est.legendVisible || est.selectionPanelVisible || est.taskPaneVisible) {
            setElementStatesAction(est);
            setActiveTab(tab);
        }
    };
    var collapsed = !(showLegend || showSelection || showTaskPane);
    return React.createElement("div", { style: { width: "100%", height: "100%" } },
        React.createElement(Sidebar, { position: "left", busy: busyCount > 0, legend: hasLegend, selection: hasSelectionPanel, taskpane: hasTaskPane, hasSelection: tbState.hasSelection || tbState.hasClientSelection, locale: locale, collapsed: collapsed || false, activeTab: activeTab || "tasks", onCollapse: onCollapse, onActivateTab: onActivateTab, onExpand: onExpand }),
        (function () {
            if (hasToolbar) {
                var top_1 = 180;
                if (!hasSelectionPanel) {
                    top_1 -= 40;
                }
                if (!hasLegend) {
                    top_1 -= 40;
                }
                if (!hasTaskPane) {
                    top_1 -= 40;
                }
                return React.createElement("div", { id: "toolbar-region", style: { top: top_1 } },
                    React.createElement(toolbar_1.ToolbarContainer, { id: constants_1.WEBLAYOUT_TOOLBAR, containerClass: "sidebar-toolbar", vertical: true, hideVerticalLabels: true, containerStyle: { position: "absolute", left: 4, right: 6, zIndex: 100 } }));
            }
        })(),
        (function () {
            if (hasNavigator) {
                return React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Navigator, locale: locale });
            }
        })(),
        (function () {
            if (hasStatusBar) {
                return React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.MouseCoordinates, locale: locale });
            }
        })(),
        (function () {
            if (hasStatusBar) {
                return React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.ScaleDisplay, locale: locale });
            }
        })(),
        (function () {
            if (hasViewSize) {
                return React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.ViewSize, locale: locale });
            }
        })(),
        (function () {
            if (hasStatusBar) {
                return React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.SelectedFeatureCount, locale: locale });
            }
        })(),
        React.createElement(viewer_shim_1.ViewerApiShim, null),
        React.createElement(modal_launcher_1.ModalLauncher, null),
        React.createElement(flyout_region_1.FlyoutRegionContainer, null),
        React.createElement(init_warning_display_1.InitWarningDisplay, null),
        React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Map, locale: locale }),
        React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.PoweredByMapGuide, locale: locale }));
};
exports.SidebarLayout = SidebarLayout;


/***/ }),

/***/ "./src/layouts/slate.tsx":
/*!*******************************!*\
  !*** ./src/layouts/slate.tsx ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SlateTemplateLayout = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var component_1 = __webpack_require__(/*! ../api/registry/component */ "./src/api/registry/component.tsx");
var toolbar_1 = __webpack_require__(/*! ../components/toolbar */ "./src/components/toolbar.tsx");
var toolbar_2 = __webpack_require__(/*! ../containers/toolbar */ "./src/containers/toolbar.tsx");
var viewer_shim_1 = __webpack_require__(/*! ../containers/viewer-shim */ "./src/containers/viewer-shim.tsx");
var modal_launcher_1 = __webpack_require__(/*! ../containers/modal-launcher */ "./src/containers/modal-launcher.tsx");
var flyout_region_1 = __webpack_require__(/*! ../containers/flyout-region */ "./src/containers/flyout-region.tsx");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var accordion_1 = __webpack_require__(/*! ../components/accordion */ "./src/components/accordion.tsx");
var template_1 = __webpack_require__(/*! ../reducers/template */ "./src/reducers/template.ts");
var init_warning_display_1 = __webpack_require__(/*! ../containers/init-warning-display */ "./src/containers/init-warning-display.tsx");
var react_splitter_layout_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! react-splitter-layout */ "./node_modules/react-splitter-layout/lib/index.js"));
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/layouts/hooks.ts");
var hooks_2 = __webpack_require__(/*! ../containers/hooks */ "./src/containers/hooks.ts");
function slateTemplateReducer(origState, state, action) {
    switch (action.type) {
        case actions_1.ActionType.FUSION_SET_LEGEND_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = void 0;
                    if (data === true) {
                        state1 = { legendVisible: true, taskPaneVisible: false, selectionPanelVisible: false };
                    }
                    else {
                        state1 = { legendVisible: data };
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.FUSION_SET_SELECTION_PANEL_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = void 0;
                    if (data === true) {
                        state1 = { legendVisible: false, taskPaneVisible: false, selectionPanelVisible: true };
                    }
                    else {
                        state1 = { selectionPanelVisible: data };
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.TASK_INVOKE_URL:
            {
                var state1 = { taskPaneVisible: true, selectionPanelVisible: false, legendVisible: false };
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
            }
        case actions_1.ActionType.FUSION_SET_TASK_PANE_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = void 0;
                    if (data === true) {
                        state1 = { legendVisible: false, taskPaneVisible: true, selectionPanelVisible: false };
                    }
                    else {
                        state1 = { taskPaneVisible: data };
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.FUSION_SET_ELEMENT_STATE:
            {
                var data = action.payload;
                if ((0, template_1.isElementState)(data)) {
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), data);
                }
            }
    }
    return state;
}
var STATUS_BAR_HEIGHT = 18;
/**
 * A viewer template that resembles the Slate Fusion template
 */
var SlateTemplateLayout = function () {
    var _a = (0, hooks_1.useCommonTemplateState)(slateTemplateReducer), isResizing = _a.isResizing, locale = _a.locale, capabilities = _a.capabilities, showSelection = _a.showSelection, showLegend = _a.showLegend, showTaskPane = _a.showTaskPane, onDragStart = _a.onDragStart, onDragEnd = _a.onDragEnd, onSplitterChanged = _a.onSplitterChanged, onActiveElementChanged = _a.onActiveElementChanged;
    var hasStatusBar = false;
    var hasNavigator = false;
    if (capabilities) {
        hasStatusBar = capabilities.hasStatusBar;
        hasNavigator = capabilities.hasNavigator;
    }
    var initInfoPaneWidth = (0, hooks_2.useTemplateInitialInfoPaneWidth)();
    var initTaskPaneWidth = (0, hooks_2.useTemplateInitialTaskPaneWidth)();
    var sbWidth = Math.max(initInfoPaneWidth, initTaskPaneWidth);
    var bottomOffset = hasStatusBar ? STATUS_BAR_HEIGHT : 0;
    var topOffset = (toolbar_1.DEFAULT_TOOLBAR_SIZE * 3);
    var panels = [
        {
            id: "Legend",
            title: (0, i18n_1.tr)("TPL_TITLE_LEGEND", locale),
            contentRenderer: function (dim) {
                return React.createElement("div", { style: { width: dim.width, height: dim.height, overflowY: "auto" } },
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Legend, locale: locale, componentProps: { inlineBaseLayerSwitcher: false } }));
            }
        },
        {
            id: "Selection",
            title: (0, i18n_1.tr)("TPL_TITLE_SELECTION_PANEL", locale),
            contentRenderer: function (dim) {
                return React.createElement("div", { style: { width: dim.width, height: dim.height, overflowY: "auto" } },
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.SelectionPanel, locale: locale }));
            }
        },
        {
            id: "TaskPane",
            title: (0, i18n_1.tr)("TPL_TITLE_TASKPANE", locale),
            contentRenderer: function (dim, isResizing) {
                return React.createElement("div", { style: { width: dim.width, height: dim.height, overflowY: "auto" } },
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.TaskPane, locale: locale, componentProps: { isResizing: isResizing } }));
            }
        }
    ];
    var activeId;
    var states = [
        { id: "Selection", visible: showSelection },
        { id: "TaskPane", visible: showTaskPane },
        { id: "Legend", visible: showLegend }
    ];
    var active = states.filter(function (st) { return st.visible; });
    if (active.length == 1) {
        activeId = active[0].id;
    }
    var TB_Z_INDEX = 0;
    return React.createElement("div", { style: { width: "100%", height: "100%" } },
        React.createElement("div", { style: { position: "absolute", left: 0, top: 0, bottom: bottomOffset, right: 0 } },
            React.createElement(react_splitter_layout_1.default, { customClassName: "slate-splitter", primaryIndex: 1, secondaryInitialSize: sbWidth, onSecondaryPaneSizeChange: onSplitterChanged, onDragStart: onDragStart, onDragEnd: onDragEnd },
                (function () {
                    if (showSelection || showTaskPane || showLegend) {
                        return React.createElement("div", null,
                            React.createElement(accordion_1.Accordion, { style: { position: "absolute", top: 0, bottom: 0, left: 0, right: 0 }, onActivePanelChanged: onActiveElementChanged, activePanelId: activeId, panels: panels, isResizing: isResizing }));
                    }
                })(),
                React.createElement("div", null,
                    React.createElement(toolbar_2.ToolbarContainer, { id: "FileMenu", containerClass: "slate-file-menu", containerStyle: { position: "absolute", left: 0, top: 0, zIndex: TB_Z_INDEX, right: 0 } }),
                    React.createElement(toolbar_2.ToolbarContainer, { id: "Toolbar", containerClass: "slate-toolbar", containerStyle: { position: "absolute", left: 0, top: toolbar_1.DEFAULT_TOOLBAR_SIZE, zIndex: TB_Z_INDEX, right: 0 } }),
                    React.createElement(toolbar_2.ToolbarContainer, { id: "ToolbarSecondary", containerClass: "slate-toolbar-secondary", containerStyle: { position: "absolute", left: 0, top: (toolbar_1.DEFAULT_TOOLBAR_SIZE * 2), zIndex: TB_Z_INDEX, right: 0 } }),
                    React.createElement("div", { style: { position: "absolute", left: 0, right: 0, top: topOffset, bottom: 0 } },
                        React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Map, locale: locale }),
                        (function () {
                            if (hasNavigator) {
                                return React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Navigator, locale: locale });
                            }
                        })()),
                    React.createElement(viewer_shim_1.ViewerApiShim, null)))),
        (function () {
            if (hasStatusBar) {
                return React.createElement("div", { className: "slate-status-bar", style: { position: "absolute", left: 0, bottom: 0, right: 0, height: bottomOffset } },
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.MouseCoordinates, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.ScaleDisplay, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.SelectedFeatureCount, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.ViewSize, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.PoweredByMapGuide, locale: locale }));
            }
        })(),
        React.createElement(modal_launcher_1.ModalLauncher, null),
        React.createElement(flyout_region_1.FlyoutRegionContainer, null),
        React.createElement(init_warning_display_1.InitWarningDisplay, null));
};
exports.SlateTemplateLayout = SlateTemplateLayout;


/***/ }),

/***/ "./src/layouts/turquoise-yellow.tsx":
/*!******************************************!*\
  !*** ./src/layouts/turquoise-yellow.tsx ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TurquoiseYellowTemplateLayout = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var React = (0, tslib_1.__importStar)(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var component_1 = __webpack_require__(/*! ../api/registry/component */ "./src/api/registry/component.tsx");
var toolbar_1 = __webpack_require__(/*! ../components/toolbar */ "./src/components/toolbar.tsx");
var toolbar_2 = __webpack_require__(/*! ../containers/toolbar */ "./src/containers/toolbar.tsx");
var viewer_shim_1 = __webpack_require__(/*! ../containers/viewer-shim */ "./src/containers/viewer-shim.tsx");
var modal_launcher_1 = __webpack_require__(/*! ../containers/modal-launcher */ "./src/containers/modal-launcher.tsx");
var flyout_region_1 = __webpack_require__(/*! ../containers/flyout-region */ "./src/containers/flyout-region.tsx");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var template_1 = __webpack_require__(/*! ../reducers/template */ "./src/reducers/template.ts");
var init_warning_display_1 = __webpack_require__(/*! ../containers/init-warning-display */ "./src/containers/init-warning-display.tsx");
var react_splitter_layout_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! react-splitter-layout */ "./node_modules/react-splitter-layout/lib/index.js"));
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
var core_1 = __webpack_require__(/*! @blueprintjs/core */ "./node_modules/@blueprintjs/core/lib/esm/index.js");
var hooks_1 = __webpack_require__(/*! ./hooks */ "./src/layouts/hooks.ts");
var hooks_2 = __webpack_require__(/*! ../containers/hooks */ "./src/containers/hooks.ts");
function turquoiseYellowTemplateReducer(origState, state, action) {
    switch (action.type) {
        case actions_1.ActionType.FUSION_SET_LEGEND_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = void 0;
                    if (data === true) {
                        state1 = { legendVisible: true, taskPaneVisible: false, selectionPanelVisible: false };
                    }
                    else {
                        state1 = { legendVisible: data };
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.FUSION_SET_SELECTION_PANEL_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = void 0;
                    if (data === true) {
                        state1 = { legendVisible: false, taskPaneVisible: false, selectionPanelVisible: true };
                    }
                    else {
                        state1 = { selectionPanelVisible: data };
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.TASK_INVOKE_URL:
            {
                var state1 = { taskPaneVisible: true, selectionPanelVisible: false, legendVisible: false };
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
            }
        case actions_1.ActionType.FUSION_SET_TASK_PANE_VISIBILITY:
            {
                var data = action.payload;
                if (typeof (data) == "boolean") {
                    var state1 = void 0;
                    if (data === true) {
                        state1 = { legendVisible: false, taskPaneVisible: true, selectionPanelVisible: false };
                    }
                    else {
                        state1 = { taskPaneVisible: data };
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.FUSION_SET_ELEMENT_STATE:
            {
                var data = action.payload;
                if ((0, template_1.isElementState)(data)) {
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), data);
                }
            }
    }
    return state;
}
var SIDEBAR_PADDING = 3;
var TOP_BAR_HEIGHT = 35;
var TAB_BAR_HEIGHT = 30;
var STATUS_BAR_HEIGHT = 18;
/**
 * A viewer template that resembles the TurquoiseYellow Fusion template
 */
var TurquoiseYellowTemplateLayout = function () {
    var _a = (0, hooks_1.useCommonTemplateState)(turquoiseYellowTemplateReducer), isResizing = _a.isResizing, locale = _a.locale, capabilities = _a.capabilities, showSelection = _a.showSelection, showLegend = _a.showLegend, showTaskPane = _a.showTaskPane, onDragStart = _a.onDragStart, onDragEnd = _a.onDragEnd, onSplitterChanged = _a.onSplitterChanged, onActiveElementChanged = _a.onActiveElementChanged;
    var hasTaskPane = false;
    var hasStatusBar = false;
    var hasNavigator = false;
    var hasSelectionPanel = false;
    var hasLegend = false;
    if (capabilities) {
        hasTaskPane = capabilities.hasTaskPane;
        hasStatusBar = capabilities.hasStatusBar;
        hasNavigator = capabilities.hasNavigator;
        hasSelectionPanel = capabilities.hasSelectionPanel;
        hasLegend = capabilities.hasLegend;
    }
    var bottomOffset = hasStatusBar ? STATUS_BAR_HEIGHT : 0;
    var initInfoPaneWidth = (0, hooks_2.useTemplateInitialInfoPaneWidth)();
    var initTaskPaneWidth = (0, hooks_2.useTemplateInitialTaskPaneWidth)();
    var sbWidth = Math.max(initInfoPaneWidth, initTaskPaneWidth);
    var tabPanelStyle = {
        position: "absolute",
        top: TAB_BAR_HEIGHT,
        left: 0,
        right: 0,
        bottom: 0
    };
    var states = [
        { id: "Selection", visible: showSelection },
        { id: "TaskPane", visible: showTaskPane },
        { id: "Legend", visible: showLegend }
    ];
    var active = states.filter(function (st) { return st.visible; });
    var extraTabsProps = {};
    if (active.length == 1) {
        extraTabsProps.selectedTabId = active[0].id;
    }
    var taskPaneTitle = (0, i18n_1.tr)("TPL_TITLE_TASKPANE", locale);
    var legendTitle = (0, i18n_1.tr)("TPL_TITLE_LEGEND", locale);
    var selectionTitle = (0, i18n_1.tr)("TPL_TITLE_SELECTION_PANEL", locale);
    var TB_Z_INDEX = 0;
    return React.createElement("div", { style: { width: "100%", height: "100%" } },
        React.createElement("div", { style: { position: "absolute", left: 0, top: 0, bottom: bottomOffset, right: 0 } },
            React.createElement(react_splitter_layout_1.default, { customClassName: "turquoise-yellow-splitter", primaryIndex: 1, secondaryInitialSize: sbWidth, onSecondaryPaneSizeChange: onSplitterChanged, onDragStart: onDragStart, onDragEnd: onDragEnd },
                (function () {
                    if (showSelection || showTaskPane || showLegend) {
                        return React.createElement("div", { className: "turquoise-yellow-sidebar", style: { position: "absolute", left: SIDEBAR_PADDING, top: TOP_BAR_HEIGHT, bottom: SIDEBAR_PADDING, right: 0 } },
                            React.createElement(core_1.Tabs, (0, tslib_1.__assign)({ className: "turquoise-yellow-sb-tabs", id: "SidebarTabs", onChange: onActiveElementChanged }, extraTabsProps),
                                (function () {
                                    if (hasTaskPane) {
                                        var panel = React.createElement("div", { style: tabPanelStyle },
                                            React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.TaskPane, locale: locale, componentProps: { isResizing: isResizing } }));
                                        return React.createElement(core_1.Tab, { id: "TaskPane", title: taskPaneTitle, panel: panel });
                                    }
                                })(),
                                (function () {
                                    if (hasLegend) {
                                        var p1 = { overflow: "auto" };
                                        var panel = React.createElement("div", { style: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, tabPanelStyle), p1) },
                                            React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Legend, locale: locale, componentProps: { inlineBaseLayerSwitcher: false } }));
                                        return React.createElement(core_1.Tab, { id: "Legend", title: legendTitle, panel: panel });
                                    }
                                })(),
                                (function () {
                                    if (hasSelectionPanel) {
                                        var panel = React.createElement("div", { style: tabPanelStyle },
                                            React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.SelectionPanel, locale: locale }));
                                        return React.createElement(core_1.Tab, { id: "Selection", title: selectionTitle, panel: panel });
                                    }
                                })()));
                    }
                })(),
                React.createElement("div", null,
                    React.createElement(toolbar_2.ToolbarContainer, { id: "FileMenu", containerClass: "turquoise-yellow-file-menu", containerStyle: { position: "absolute", left: 0, top: (TOP_BAR_HEIGHT - toolbar_1.DEFAULT_TOOLBAR_SIZE), zIndex: TB_Z_INDEX, right: 0 } }),
                    React.createElement(toolbar_2.ToolbarContainer, { id: "Toolbar", containerClass: "turquoise-yellow-toolbar", containerStyle: { position: "absolute", left: 0, top: TOP_BAR_HEIGHT, zIndex: TB_Z_INDEX, right: 0 } }),
                    React.createElement(toolbar_2.ToolbarContainer, { id: "ToolbarVertical", containerClass: "turquoise-yellow-toolbar-vertical", vertical: true, containerStyle: { position: "absolute", left: 0, top: (TOP_BAR_HEIGHT + toolbar_1.DEFAULT_TOOLBAR_SIZE), zIndex: TB_Z_INDEX, bottom: SIDEBAR_PADDING } }),
                    React.createElement("div", { style: { position: "absolute", left: (toolbar_1.DEFAULT_TOOLBAR_SIZE), top: (TOP_BAR_HEIGHT + toolbar_1.DEFAULT_TOOLBAR_SIZE), bottom: SIDEBAR_PADDING, right: 0 } },
                        React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Map, locale: locale }),
                        (function () {
                            if (hasNavigator) {
                                return React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.Navigator, locale: locale });
                            }
                        })())))),
        (function () {
            if (hasStatusBar) {
                return React.createElement("div", { className: "turquoise-yellow-status-bar", style: { position: "absolute", left: 0, bottom: 0, right: 0, height: bottomOffset } },
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.MouseCoordinates, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.ScaleDisplay, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.SelectedFeatureCount, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.ViewSize, locale: locale }),
                    React.createElement(component_1.PlaceholderComponent, { id: component_1.DefaultComponentNames.PoweredByMapGuide, locale: locale }));
            }
        })(),
        React.createElement(viewer_shim_1.ViewerApiShim, null),
        React.createElement(modal_launcher_1.ModalLauncher, null),
        React.createElement(flyout_region_1.FlyoutRegionContainer, null),
        React.createElement(init_warning_display_1.InitWarningDisplay, null));
};
exports.TurquoiseYellowTemplateLayout = TurquoiseYellowTemplateLayout;


/***/ }),

/***/ "./src/reducers/config.ts":
/*!********************************!*\
  !*** ./src/reducers/config.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configReducer = exports.CONFIG_INITIAL_STATE = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
var units_1 = __webpack_require__(/*! ../utils/units */ "./src/utils/units.tsx");
var type_guards_1 = __webpack_require__(/*! ../utils/type-guards */ "./src/utils/type-guards.ts");
exports.CONFIG_INITIAL_STATE = {
    agentUri: undefined,
    agentKind: "mapagent",
    locale: i18n_1.DEFAULT_LOCALE,
    activeMapName: undefined,
    availableMaps: undefined,
    viewRotation: 0,
    viewRotationEnabled: true,
    viewSizeUnits: common_1.UnitOfMeasure.Meters,
    manualFeatureTooltips: false,
    cancelDigitizationKey: common_1.KC_ESCAPE,
    undoLastPointKey: common_1.KC_U,
    selectCanDragPan: false,
    coordinates: {
        decimals: 6
    },
    viewer: {
        isStateless: false,
        imageFormat: "PNG",
        selectionImageFormat: "PNG8",
        selectionColor: "0x0000FFAA",
        activeSelectedFeatureColor: "0xFF0000AA",
        pointSelectionBuffer: 2,
        loadIndicatorPositioning: "top",
        loadIndicatorColor: "rgba(34, 153, 221, 0.9)",
    },
    capabilities: {
        hasTaskPane: false,
        hasTaskBar: false,
        hasStatusBar: false,
        hasNavigator: false,
        hasSelectionPanel: false,
        hasLegend: false,
        hasToolbar: false,
        hasViewSize: false
    }
};
function configReducer(state, action) {
    var _a, _b;
    if (state === void 0) { state = exports.CONFIG_INITIAL_STATE; }
    switch (action.type) {
        case actions_1.ActionType.SET_LOCALE:
            {
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), { locale: action.payload });
            }
        case actions_1.ActionType.INIT_APP:
            {
                var payload = (_a = action.payload) !== null && _a !== void 0 ? _a : {};
                var maps = payload.maps;
                var availableMaps = [];
                var am = payload.activeMapName;
                var mapNames = Object.keys(maps);
                for (var _i = 0, mapNames_1 = mapNames; _i < mapNames_1.length; _i++) {
                    var mapName = mapNames_1[_i];
                    availableMaps.push({ name: maps[mapName].mapGroupId, value: mapName });
                }
                if (mapNames.indexOf(am) < 0) {
                    (0, logger_1.warn)("Invalid initial active map name: " + am + ". Probably because we haven't properly implemented recovery of runtime maps on reload yet");
                    am = mapNames[0];
                }
                var state1 = {
                    locale: payload.locale || i18n_1.DEFAULT_LOCALE,
                    capabilities: payload.capabilities,
                    activeMapName: am,
                    availableMaps: availableMaps
                };
                var newState = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                if (payload.config != null && Object.keys(payload.config).length > 0) {
                    var coordConfig = (0, tslib_1.__assign)({}, state.coordinates);
                    var viewerConfig = (0, tslib_1.__assign)({}, state.viewer);
                    if (payload.config.isStateless != null) {
                        viewerConfig.isStateless = payload.config.isStateless;
                    }
                    if (payload.config.imageFormat != null) {
                        viewerConfig.imageFormat = payload.config.imageFormat;
                    }
                    if (payload.config.selectionImageFormat != null) {
                        viewerConfig.selectionImageFormat = payload.config.selectionImageFormat;
                    }
                    if (payload.config.selectionColor != null) {
                        viewerConfig.selectionColor = payload.config.selectionColor;
                    }
                    if (payload.config.pointSelectionBuffer != null) {
                        viewerConfig.pointSelectionBuffer = payload.config.pointSelectionBuffer;
                    }
                    if (payload.config.coordinateProjection != null) {
                        coordConfig.projection = payload.config.coordinateProjection;
                    }
                    if (payload.config.coordinateDecimals != null) {
                        coordConfig.decimals = payload.config.coordinateDecimals;
                    }
                    if (payload.config.coordinateDisplayFormat != null) {
                        coordConfig.format = payload.config.coordinateDisplayFormat;
                    }
                    var state2 = { viewer: viewerConfig, coordinates: coordConfig };
                    var mapKeys = Object.keys(payload.maps);
                    if (payload.config.viewSizeUnits != null) {
                        state2.viewSizeUnits = payload.config.viewSizeUnits;
                    }
                    else if (mapKeys.length == 1) {
                        var m = payload.maps[mapKeys[0]].map;
                        if (m) {
                            var arbCs = void 0;
                            if ((0, type_guards_1.isRuntimeMap)(m)) {
                                arbCs = (0, units_1.tryParseArbitraryCs)(m.CoordinateSystem.MentorCode);
                            }
                            else {
                                arbCs = (0, units_1.tryParseArbitraryCs)((_b = m === null || m === void 0 ? void 0 : m.meta) === null || _b === void 0 ? void 0 : _b.projection);
                            }
                            // If arbitrary, infer units from it
                            if (arbCs) {
                                state2.viewSizeUnits = arbCs.units;
                            }
                        }
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, newState), state2);
                }
                else {
                    return newState;
                }
            }
        case actions_1.ActionType.MAP_ENABLE_SELECT_DRAGPAN:
            {
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), { selectCanDragPan: action.payload });
            }
        case actions_1.ActionType.MAP_SET_VIEW_ROTATION:
            {
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), { viewRotation: action.payload });
            }
        case actions_1.ActionType.MAP_SET_VIEW_ROTATION_ENABLED:
            {
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), { viewRotationEnabled: action.payload });
            }
        case actions_1.ActionType.MAP_SET_ACTIVE_MAP:
            {
                var data = action.payload;
                if (data) {
                    var state1 = {
                        activeMapName: data
                    };
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
        case actions_1.ActionType.MAP_SET_VIEW_SIZE_UNITS:
            {
                //HACK: Huh? It's typed UnitOfMeasure on both ends, so where is the string coming from that causes
                //the RHS type to be string | UnitOfMeasure?
                var state1 = { viewSizeUnits: action.payload };
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
            }
        case actions_1.ActionType.MAP_SET_MANUAL_MAPTIP:
            {
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), { manualFeatureTooltips: action.payload });
            }
    }
    return state;
}
exports.configReducer = configReducer;


/***/ }),

/***/ "./src/reducers/init-error.ts":
/*!************************************!*\
  !*** ./src/reducers/init-error.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initErrorReducer = exports.INIT_ERROR_INITIAL_STATE = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var array_1 = __webpack_require__(/*! ../utils/array */ "./src/utils/array.ts");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
exports.INIT_ERROR_INITIAL_STATE = {
    options: {},
    error: undefined,
    includeStack: true,
    warnings: []
};
function initErrorReducer(state, action) {
    if (state === void 0) { state = exports.INIT_ERROR_INITIAL_STATE; }
    switch (action.type) {
        case actions_1.ActionType.INIT_ACKNOWLEDGE_WARNINGS:
            {
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), { warnings: [] });
            }
        case actions_1.ActionType.INIT_APP:
            {
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), { warnings: (0, array_1.makeUnique)(action.payload.warnings) });
            }
        case actions_1.ActionType.INIT_ERROR:
            {
                var payload = action.payload;
                var error = payload.error;
                var options = payload.options;
                var includeStack = payload.includeStack;
                if (typeof (includeStack) == 'undefined') {
                    includeStack = true;
                }
                return { error: error, options: options, includeStack: includeStack, warnings: [] };
            }
    }
    return state;
}
exports.initErrorReducer = initErrorReducer;


/***/ }),

/***/ "./src/reducers/last-action.ts":
/*!*************************************!*\
  !*** ./src/reducers/last-action.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lastAction = exports.NULL_ACTION = void 0;
// A reducer to remember the last dispatched action. This is primarily used by layout
// templates to listen on certain actions and be able to update their panel states
//
// As suggested by the creator of redux:
// https://github.com/reactjs/redux/issues/580
var type_guards_1 = __webpack_require__(/*! ../utils/type-guards */ "./src/utils/type-guards.ts");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
exports.NULL_ACTION = {};
function lastAction(state, action) {
    if (state === void 0) { state = null; }
    if ((0, type_guards_1.isAction)(action)) {
        switch (action.type) {
            case actions_1.ActionType.MAP_SET_BUSY_COUNT:
            case actions_1.ActionType.TASK_INVOKE_URL:
            case actions_1.ActionType.MAP_SET_SELECTION:
            case actions_1.ActionType.MAP_ADD_CLIENT_SELECTED_FEATURE:
            case actions_1.ActionType.MAP_SET_MAPTIP:
            case actions_1.ActionType.MAP_SET_ACTIVE_TOOL:
                return action;
        }
    }
    //As we're returning a const reference subsequent dispatched actions that
    //are not the ones listed above should give us the same branch in the eyes
    //of redux
    return exports.NULL_ACTION;
}
exports.lastAction = lastAction;


/***/ }),

/***/ "./src/reducers/map-state.ts":
/*!***********************************!*\
  !*** ./src/reducers/map-state.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapStateReducer = exports.MAP_STATE_INITIAL_SUB_STATE = exports.MG_INITIAL_SUB_STATE = exports.MAP_STATE_INITIAL_STATE = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var type_guards_1 = __webpack_require__(/*! ../utils/type-guards */ "./src/utils/type-guards.ts");
var array_1 = __webpack_require__(/*! ../utils/array */ "./src/utils/array.ts");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
var defs_1 = __webpack_require__(/*! ../actions/defs */ "./src/actions/defs.ts");
var logger_1 = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.ts");
var ol_style_contracts_1 = __webpack_require__(/*! ../api/ol-style-contracts */ "./src/api/ol-style-contracts.ts");
var units_1 = __webpack_require__(/*! ../utils/units */ "./src/utils/units.tsx");
exports.MAP_STATE_INITIAL_STATE = {};
exports.MG_INITIAL_SUB_STATE = {
    selectionSet: undefined,
    layerTransparency: {},
    selectableLayers: {},
    expandedGroups: {},
    runtimeMap: undefined,
    isArbitraryCs: false,
    showLayers: [],
    showGroups: [],
    hideLayers: [],
    hideGroups: [],
    activeSelectedFeature: undefined,
};
exports.MAP_STATE_INITIAL_SUB_STATE = {
    currentView: undefined,
    initialView: undefined,
    history: [],
    historyIndex: -1,
    externalBaseLayers: [],
    initialExternalLayers: [],
    layers: undefined,
    mapguide: undefined,
    generic: undefined,
    clientSelection: undefined
};
function applyMapGuideSubState(state, mapName, applyFn) {
    var subState = state[mapName];
    if (subState) {
        var mgSubState = subState.mapguide;
        if (mgSubState) {
            var toApply = applyFn(mgSubState);
            var mgSubState1 = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, mgSubState), toApply);
            return mergeSubState(state, mapName, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, subState), { mapguide: mgSubState1 }));
        }
    }
    return state;
}
function setLayerAction(state, mapName, layerName, selector) {
    var subState = state[mapName];
    if (subState && subState.layers) {
        var layers = subState.layers.map(function (l) {
            if (l.name == layerName) {
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, l), (selector(l)));
            }
            else {
                return l;
            }
        });
        var state1 = {
            layers: layers
        };
        return mergeSubState(state, mapName, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, subState), state1));
    }
    return state;
}
function mergeSubState(state, mapName, subState) {
    var state1 = {};
    state1[mapName] = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state[mapName]), subState);
    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
}
function mapStateReducer(state, action) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (state === void 0) { state = exports.MAP_STATE_INITIAL_STATE; }
    switch (action.type) {
        case actions_1.ActionType.MAP_REFRESH:
            {
                var payload_1 = action.payload;
                return applyMapGuideSubState(state, payload_1.mapName, function (_) { return ({
                    runtimeMap: payload_1.map,
                    isArbitraryCs: (0, units_1.tryParseArbitraryCs)(payload_1.map.CoordinateSystem.MentorCode) != null
                }); });
            }
        case actions_1.ActionType.INIT_APP:
            {
                var payload = action.payload;
                var maps = payload.maps;
                var mapKeys = Object.keys(maps);
                var newState = {};
                var mapNameToApplyInitialState = payload.activeMapName;
                if (!mapNameToApplyInitialState && mapKeys.length == 1) {
                    mapNameToApplyInitialState = mapKeys[0];
                }
                for (var _i = 0, mapKeys_1 = mapKeys; _i < mapKeys_1.length; _i++) {
                    var mapName = mapKeys_1[_i];
                    var cv = void 0;
                    if (payload.initialView && mapName == mapNameToApplyInitialState) {
                        cv = {
                            currentView: (0, tslib_1.__assign)({}, payload.initialView)
                        };
                    }
                    var isel = void 0;
                    if (payload.initialSelections && payload.initialSelections[mapName]) {
                        isel = {
                            selectionSet: payload.initialSelections[mapName]
                        };
                        (0, logger_1.debug)("Restoring client-side selection set for: " + mapName);
                    }
                    var sl = [];
                    var sg = [];
                    var hl = [];
                    var hg = [];
                    var mrtm = void 0;
                    var mgeneric = void 0;
                    var rtm = maps[mapName].map;
                    if (rtm) {
                        if (!(0, defs_1.isGenericSubjectMapLayer)(rtm)) {
                            var arbCs = (0, units_1.tryParseArbitraryCs)(rtm.CoordinateSystem.MentorCode);
                            mrtm = { runtimeMap: rtm, isArbitraryCs: arbCs != null };
                        }
                        else {
                            mgeneric = { subject: (0, tslib_1.__assign)({}, rtm) };
                        }
                    }
                    if (mapName == mapNameToApplyInitialState) {
                        if (rtm && !(0, defs_1.isGenericSubjectMapLayer)(rtm)) {
                            var isl = (_a = payload.initialShowLayers) !== null && _a !== void 0 ? _a : [];
                            var isg = (_b = payload.initialShowGroups) !== null && _b !== void 0 ? _b : [];
                            var ihl = (_c = payload.initialHideLayers) !== null && _c !== void 0 ? _c : [];
                            var ihg = (_d = payload.initialHideGroups) !== null && _d !== void 0 ? _d : [];
                            //Only initally show what is initially hidden and vice versa
                            //NOTE: A map could have duplicate group/layer names, we make no attempt
                            //to pick out the "correct" one. It's first come first serve.
                            if (rtm.Layer) {
                                for (var _j = 0, _k = rtm.Layer; _j < _k.length; _j++) {
                                    var l = _k[_j];
                                    if (isl.indexOf(l.Name) >= 0 && !l.Visible) {
                                        sl.push(l.ObjectId);
                                    }
                                    else if (ihl.indexOf(l.Name) >= 0 && l.Visible) {
                                        hl.push(l.ObjectId);
                                    }
                                }
                            }
                            if (rtm.Group) {
                                for (var _l = 0, _m = rtm.Group; _l < _m.length; _l++) {
                                    var g = _m[_l];
                                    if (isg.indexOf(g.Name) >= 0 && !g.Visible) {
                                        sg.push(g.ObjectId);
                                    }
                                    else if (ihg.indexOf(g.Name) >= 0 && g.Visible) {
                                        hg.push(g.ObjectId);
                                    }
                                }
                            }
                            (0, logger_1.debug)("Initially showing layers: " + isl.join("|"));
                            (0, logger_1.debug)("Initially showing groups: " + isg.join("|"));
                            (0, logger_1.debug)("Initially hiding layers: " + ihl.join("|"));
                            (0, logger_1.debug)("Initially hiding groups: " + ihg.join("|"));
                            (0, logger_1.debug)("Initially showing layer ids: " + sl.join("|"));
                            (0, logger_1.debug)("Initially showing group ids: " + sg.join("|"));
                            (0, logger_1.debug)("Initially hiding layer ids: " + hl.join("|"));
                            (0, logger_1.debug)("Initially hiding group ids: " + hg.join("|"));
                        }
                    }
                    var newMgSubState = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, exports.MG_INITIAL_SUB_STATE), mrtm), (isel || {})), (sl.length > 0 ? { showLayers: (0, tslib_1.__spreadArray)([], sl, true) } : {})), (sg.length > 0 ? { showGroups: (0, tslib_1.__spreadArray)([], sg, true) } : {})), (hl.length > 0 ? { hideLayers: (0, tslib_1.__spreadArray)([], hl, true) } : {})), (hg.length > 0 ? { hideGroups: (0, tslib_1.__spreadArray)([], hg, true) } : {}));
                    var newMapState = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, exports.MAP_STATE_INITIAL_SUB_STATE), { generic: mgeneric }), { externalBaseLayers: maps[mapName].externalBaseLayers }), { initialExternalLayers: maps[mapName].initialExternalLayers }), { initialView: maps[mapName].initialView }), (cv || {})), { mapguide: newMgSubState });
                    // As INIT_APP does not establish a currentView, if a currentView was
                    // somehow established as part of the initial app state, we will keep
                    // it instead of it being discarded
                    if ((_e = state === null || state === void 0 ? void 0 : state[mapName]) === null || _e === void 0 ? void 0 : _e.currentView) {
                        newMapState.currentView = state[mapName].currentView;
                    }
                    newState[mapName] = newMapState;
                }
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), newState);
            }
        case actions_1.ActionType.MAP_PREVIOUS_VIEW:
            {
                var payload = action.payload;
                var subState = state[payload.mapName];
                if (subState) {
                    var index = subState.historyIndex - 1;
                    if (index >= 0) {
                        var state1 = {
                            historyIndex: index,
                            currentView: subState.history[index]
                        };
                        return mergeSubState(state, payload.mapName, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, subState), state1));
                    }
                }
                return state;
            }
        case actions_1.ActionType.MAP_NEXT_VIEW:
            {
                var payload = action.payload;
                var subState = state[payload.mapName];
                if (subState) {
                    var index = subState.historyIndex + 1;
                    if (index < subState.history.length) {
                        var state1 = {
                            historyIndex: index,
                            currentView: subState.history[index]
                        };
                        return mergeSubState(state, payload.mapName, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, subState), state1));
                    }
                }
                return state;
            }
        case actions_1.ActionType.MAP_SET_SCALE:
            {
                var payload = action.payload;
                var subState = state[payload.mapName];
                if (subState) {
                    var view = subState.currentView;
                    var scale = payload.scale;
                    if (typeof view === 'object' && typeof scale === 'number') {
                        var view1 = { scale: scale, resolution: payload.resolution };
                        view = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, view), view1);
                    }
                    var state1 = {
                        currentView: view
                    };
                    var newSubState = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state1), { historyIndex: subState.historyIndex });
                    newSubState.history = (0, tslib_1.__spreadArray)([], subState.history, true);
                    if (view && newSubState.history && newSubState.historyIndex != null) {
                        newSubState.historyIndex++;
                        newSubState.history[newSubState.historyIndex] = view;
                        //If we slotted at a position that is not the end of the array
                        //remove everything after it
                        if (newSubState.history.length > newSubState.historyIndex + 1) {
                            newSubState.history.splice(newSubState.historyIndex + 1);
                        }
                    }
                    return mergeSubState(state, payload.mapName, newSubState);
                }
                return state;
            }
        case actions_1.ActionType.MAP_SET_VIEW:
            {
                var payload = action.payload;
                var subState = state[payload.mapName];
                if (subState) {
                    var data = payload.view;
                    if ((0, type_guards_1.isMapView)(data)) {
                        var state1 = {
                            currentView: data
                        };
                        var newSubState = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state1), { historyIndex: subState.historyIndex });
                        newSubState.history = (0, tslib_1.__spreadArray)([], subState.history, true);
                        if (newSubState.history && newSubState.historyIndex != null) {
                            newSubState.historyIndex++;
                            newSubState.history[newSubState.historyIndex] = data;
                            //If we slotted at a position that is not the end of the array
                            //remove everything after it
                            if (newSubState.history.length > newSubState.historyIndex + 1) {
                                newSubState.history.splice(newSubState.historyIndex + 1);
                            }
                        }
                        return mergeSubState(state, payload.mapName, newSubState);
                    }
                }
                return state;
            }
        case actions_1.ActionType.MAP_SET_LAYER_TRANSPARENCY:
            {
                //TODO: Move state to non-MG branch for next major release
                var payload_2 = action.payload;
                return applyMapGuideSubState(state, payload_2.mapName, function (mgSubState) {
                    var trans = (0, tslib_1.__assign)({}, mgSubState.layerTransparency);
                    trans[payload_2.layerName] = payload_2.opacity;
                    return {
                        layerTransparency: trans
                    };
                });
            }
        case actions_1.ActionType.LEGEND_SET_LAYER_SELECTABLE:
            {
                var payload_3 = action.payload;
                return applyMapGuideSubState(state, payload_3.mapName, function (mgSubState) {
                    var layers = (0, tslib_1.__assign)({}, mgSubState.selectableLayers);
                    layers[payload_3.id] = payload_3.value;
                    return {
                        selectableLayers: layers
                    };
                });
            }
        case actions_1.ActionType.LEGEND_SET_GROUP_EXPANDABLE:
            {
                var payload_4 = action.payload;
                return applyMapGuideSubState(state, payload_4.mapName, function (mgSubState) {
                    var groups = (0, tslib_1.__assign)({}, mgSubState.expandedGroups);
                    groups[payload_4.id] = payload_4.value;
                    return {
                        expandedGroups: groups
                    };
                });
            }
        case actions_1.ActionType.LEGEND_SET_GROUP_VISIBILITY:
            {
                var payload_5 = action.payload;
                return applyMapGuideSubState(state, payload_5.mapName, function (mgSubState) {
                    var showGroups = (0, tslib_1.__spreadArray)([], mgSubState.showGroups, true);
                    var hideGroups = (0, tslib_1.__spreadArray)([], mgSubState.hideGroups, true);
                    if (payload_5.value === true) { //Show it
                        showGroups.push(payload_5.id);
                        showGroups = (0, array_1.makeUnique)(showGroups);
                        hideGroups = hideGroups.filter(function (g) { return g != payload_5.id; });
                    }
                    else { //Hide it
                        hideGroups.push(payload_5.id);
                        hideGroups = (0, array_1.makeUnique)(hideGroups);
                        showGroups = showGroups.filter(function (g) { return g != payload_5.id; });
                    }
                    return {
                        showLayers: mgSubState.showLayers,
                        showGroups: showGroups,
                        hideLayers: mgSubState.hideLayers,
                        hideGroups: hideGroups
                    };
                });
            }
        case actions_1.ActionType.LEGEND_SET_LAYER_VISIBILITY:
            {
                var payload_6 = action.payload;
                return applyMapGuideSubState(state, payload_6.mapName, function (mgSubState) {
                    var showLayers = (0, tslib_1.__spreadArray)([], mgSubState.showLayers, true);
                    var hideLayers = (0, tslib_1.__spreadArray)([], mgSubState.hideLayers, true);
                    if (payload_6.value === true) { //Show it
                        showLayers.push(payload_6.id);
                        showLayers = (0, array_1.makeUnique)(showLayers);
                        hideLayers = hideLayers.filter(function (g) { return g != payload_6.id; });
                    }
                    else { //Hide it
                        hideLayers.push(payload_6.id);
                        hideLayers = (0, array_1.makeUnique)(hideLayers);
                        showLayers = showLayers.filter(function (g) { return g != payload_6.id; });
                    }
                    return {
                        showLayers: showLayers,
                        showGroups: mgSubState.showGroups,
                        hideLayers: hideLayers,
                        hideGroups: mgSubState.hideGroups
                    };
                });
            }
        case actions_1.ActionType.MAP_SET_SELECTION:
            {
                var payload_7 = action.payload;
                return applyMapGuideSubState(state, payload_7.mapName, function (_) { return ({
                    selectionSet: payload_7.selection,
                    layerIndex: -1,
                    featureIndex: -1,
                    activeSelectedFeature: undefined
                }); });
            }
        case actions_1.ActionType.MAP_ADD_CLIENT_SELECTED_FEATURE:
            {
                var payload_8 = action.payload;
                var subState = state[payload_8.mapName];
                if (subState) {
                    var cs = (_f = subState.clientSelection) !== null && _f !== void 0 ? _f : {
                        layers: []
                    };
                    var lyr = cs.layers.find(function (l) { return l.name == payload_8.layerName; });
                    if (!lyr) {
                        lyr = {
                            name: payload_8.layerName,
                            features: []
                        };
                        cs.layers.push(lyr);
                    }
                    lyr.features.push(payload_8.feature);
                    return mergeSubState(state, payload_8.mapName, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, subState), { clientSelection: cs }));
                }
                return state;
            }
        case actions_1.ActionType.MAP_CLEAR_CLIENT_SELECTION:
            {
                var payload = action.payload;
                var subState = state[payload.mapName];
                if (subState) {
                    return mergeSubState(state, payload.mapName, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, subState), { clientSelection: undefined }));
                }
                return state;
            }
        case actions_1.ActionType.MAP_SHOW_SELECTED_FEATURE:
            {
                var payload_9 = action.payload;
                return applyMapGuideSubState(state, payload_9.mapName, function (_) { return ({
                    activeSelectedFeature: {
                        layerId: payload_9.layerId,
                        selectionKey: payload_9.selectionKey
                    }
                }); });
            }
        case actions_1.ActionType.MAP_SET_BASE_LAYER:
            {
                var payload_10 = action.payload;
                var subState = state[payload_10.mapName];
                if (subState) {
                    var layers = (subState.externalBaseLayers || []);
                    var baseLayers = layers.map(function (layer) {
                        // Non-visual base layers like UTFGrid will always stay visible
                        if (layer.kind != "UTFGrid") {
                            layer.visible = false;
                        }
                        if (layer.name == payload_10.layerName) {
                            layer.visible = true;
                        }
                        return layer;
                    });
                    var state1 = {
                        externalBaseLayers: baseLayers
                    };
                    return mergeSubState(state, payload_10.mapName, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, subState), state1));
                }
                return state;
            }
        case actions_1.ActionType.EXTERNAL_LAYERS_READY:
            {
                var payload = action.payload;
                var subState = state[payload.mapName];
                if (subState) {
                    var layers = (_g = subState.layers) !== null && _g !== void 0 ? _g : [];
                    var state1 = {
                        layers: layers
                    };
                    return mergeSubState(state, payload.mapName, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, subState), state1));
                }
                return state;
            }
        case actions_1.ActionType.LAYER_ADDED:
            {
                var payload_11 = action.payload;
                var subState = state[payload_11.mapName];
                if (subState) {
                    var layers = (0, tslib_1.__spreadArray)([payload_11.layer], ((_h = subState.layers) !== null && _h !== void 0 ? _h : []), true);
                    var state1 = {
                        layers: layers
                    };
                    var ss = mergeSubState(state, payload_11.mapName, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, subState), state1));
                    if (payload_11.defaultStyle) {
                        var ss1 = setLayerAction(ss, payload_11.mapName, payload_11.layer.name, function () { return ({ vectorStyle: payload_11.defaultStyle }); });
                        return ss1;
                    }
                    return ss;
                }
                return state;
            }
        case actions_1.ActionType.REMOVE_LAYER:
            {
                var payload = action.payload;
                var subState = state[payload.mapName];
                if (subState && subState.layers) {
                    var layers = subState.layers.filter(function (l) { return l.name != action.payload.layerName; });
                    var state1 = {
                        layers: layers
                    };
                    return mergeSubState(state, payload.mapName, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, subState), state1));
                }
                return state;
            }
        case actions_1.ActionType.SET_LAYER_VISIBILITY:
            {
                var _o = action.payload, mapName = _o.mapName, layerName = _o.layerName, visible_1 = _o.visible;
                var state1 = setLayerAction(state, mapName, layerName, function () { return ({ visible: visible_1 }); });
                return state1;
            }
        case actions_1.ActionType.SET_LAYER_OPACITY:
            {
                var _p = action.payload, mapName = _p.mapName, layerName = _p.layerName, opacity_1 = _p.opacity;
                var state1 = setLayerAction(state, mapName, layerName, function () { return ({ opacity: opacity_1 }); });
                return state1;
            }
        case actions_1.ActionType.SET_HEATMAP_LAYER_BLUR:
            {
                var _q = action.payload, mapName = _q.mapName, layerName = _q.layerName, blur_1 = _q.blur;
                var state1 = setLayerAction(state, mapName, layerName, function (layer) {
                    var _a;
                    return ({
                        heatmap: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, ((_a = layer.heatmap) !== null && _a !== void 0 ? _a : { blur: 15, radius: 5 })), { blur: blur_1 })
                    });
                });
                return state1;
            }
        case actions_1.ActionType.SET_HEATMAP_LAYER_RADIUS:
            {
                var _r = action.payload, mapName = _r.mapName, layerName = _r.layerName, radius_1 = _r.radius;
                var state1 = setLayerAction(state, mapName, layerName, function (layer) {
                    var _a;
                    return ({
                        heatmap: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, ((_a = layer.heatmap) !== null && _a !== void 0 ? _a : { blur: 15, radius: 5 })), { radius: radius_1 })
                    });
                });
                return state1;
            }
        case actions_1.ActionType.SET_LAYER_INDEX:
            {
                var _s = action.payload, mapName = _s.mapName, index = _s.index, layerName = _s.layerName;
                var subState = state[mapName];
                if (subState && subState.layers) {
                    var layers = (0, tslib_1.__spreadArray)([], subState.layers, true);
                    var currentIdx = -1;
                    for (var i = 0; i < layers.length; i++) {
                        if (layers[i].name == layerName) {
                            currentIdx = i;
                            break;
                        }
                    }
                    if (currentIdx >= 0 && currentIdx != index && index < layers.length && index >= 0) {
                        var theLayer = layers[currentIdx];
                        layers.splice(currentIdx, 1);
                        layers.splice(index, 0, theLayer);
                        var state1 = {
                            layers: layers
                        };
                        return mergeSubState(state, mapName, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, subState), state1));
                    }
                }
                return state;
            }
        case actions_1.ActionType.SET_LAYER_VECTOR_STYLE:
            {
                var _t = action.payload, mapName = _t.mapName, layerName = _t.layerName, style_1 = _t.style, which_1 = _t.which;
                var state1 = setLayerAction(state, mapName, layerName, function (current) {
                    if (which_1 == ol_style_contracts_1.VectorStyleSource.Base) {
                        return { vectorStyle: style_1 };
                    }
                    else if (which_1 == ol_style_contracts_1.VectorStyleSource.Cluster) {
                        return {
                            cluster: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, current.cluster), { style: (0, tslib_1.__assign)({}, style_1) })
                        };
                    }
                    else {
                        return {};
                    }
                });
                return state1;
            }
        case actions_1.ActionType.ADD_LAYER_BUSY_WORKER:
            {
                var _u = action.payload, mapName = _u.mapName, layerName = _u.layerName;
                var state1 = setLayerAction(state, mapName, layerName, function (l) { return ({ busyWorkerCount: l.busyWorkerCount + 1 }); });
                return state1;
            }
        case actions_1.ActionType.REMOVE_LAYER_BUSY_WORKER:
            {
                var _v = action.payload, mapName = _v.mapName, layerName = _v.layerName;
                var state1 = setLayerAction(state, mapName, layerName, function (l) { return ({ busyWorkerCount: l.busyWorkerCount - 1 }); });
                return state1;
            }
    }
    return state;
}
exports.mapStateReducer = mapStateReducer;


/***/ }),

/***/ "./src/reducers/modal.ts":
/*!*******************************!*\
  !*** ./src/reducers/modal.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.modalReducer = exports.MODAL_INITIAL_STATE = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
exports.MODAL_INITIAL_STATE = {};
function modalReducer(state, action) {
    if (state === void 0) { state = exports.MODAL_INITIAL_STATE; }
    switch (action.type) {
        case actions_1.ActionType.MODAL_SHOW_COMPONENT:
            {
                var newData = {};
                newData[action.payload.name] = {
                    modal: action.payload.modal,
                    component: action.payload.component,
                    componentProps: action.payload.componentProps
                };
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), newData);
            }
        case actions_1.ActionType.MODAL_SHOW_URL:
            {
                var newData = {};
                newData[action.payload.name] = (0, tslib_1.__assign)({}, action.payload);
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), newData);
            }
        case actions_1.ActionType.MODAL_CLOSE:
            {
                var newState = (0, tslib_1.__assign)({}, state);
                delete newState[action.payload];
                return newState;
            }
    }
    return state;
}
exports.modalReducer = modalReducer;


/***/ }),

/***/ "./src/reducers/mouse.ts":
/*!*******************************!*\
  !*** ./src/reducers/mouse.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mouseReducer = exports.MOUSE_INITIAL_STATE = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var type_guards_1 = __webpack_require__(/*! ../utils/type-guards */ "./src/utils/type-guards.ts");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
exports.MOUSE_INITIAL_STATE = {
    coords: undefined
};
function mouseReducer(state, action) {
    if (state === void 0) { state = exports.MOUSE_INITIAL_STATE; }
    switch (action.type) {
        case actions_1.ActionType.UPDATE_MOUSE_COORDINATES:
            {
                var data = action.payload.coord;
                if ((0, type_guards_1.isCoordinate)(data)) {
                    var state1 = { coords: data };
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
            }
    }
    return state;
}
exports.mouseReducer = mouseReducer;


/***/ }),

/***/ "./src/reducers/root.ts":
/*!******************************!*\
  !*** ./src/reducers/root.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rootReducer = void 0;
var config_1 = __webpack_require__(/*! ./config */ "./src/reducers/config.ts");
var toolbar_1 = __webpack_require__(/*! ./toolbar */ "./src/reducers/toolbar.ts");
var taskpane_1 = __webpack_require__(/*! ./taskpane */ "./src/reducers/taskpane.ts");
var last_action_1 = __webpack_require__(/*! ./last-action */ "./src/reducers/last-action.ts");
var modal_1 = __webpack_require__(/*! ./modal */ "./src/reducers/modal.ts");
var init_error_1 = __webpack_require__(/*! ./init-error */ "./src/reducers/init-error.ts");
var map_state_1 = __webpack_require__(/*! ./map-state */ "./src/reducers/map-state.ts");
var viewer_1 = __webpack_require__(/*! ./viewer */ "./src/reducers/viewer.ts");
var mouse_1 = __webpack_require__(/*! ./mouse */ "./src/reducers/mouse.ts");
var template_1 = __webpack_require__(/*! ./template */ "./src/reducers/template.ts");
exports.rootReducer = {
    initError: init_error_1.initErrorReducer,
    config: config_1.configReducer,
    template: template_1.templateReducer,
    mapState: map_state_1.mapStateReducer,
    viewer: viewer_1.viewerReducer,
    toolbar: toolbar_1.toolbarReducer,
    taskpane: taskpane_1.taskPaneReducer,
    modal: modal_1.modalReducer,
    mouse: mouse_1.mouseReducer,
    lastaction: last_action_1.lastAction
};


/***/ }),

/***/ "./src/reducers/taskpane.ts":
/*!**********************************!*\
  !*** ./src/reducers/taskpane.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.taskPaneReducer = exports.TASK_PANE_INITIAL_STATE = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
exports.TASK_PANE_INITIAL_STATE = {
    navIndex: -1,
    navigation: [],
    initialUrl: undefined,
    //Having this state sounds extremely hacky, but we need a way to signal to the "dumb" task pane that
    //the url its about to receive was pushed and should not be reloaded into the internal iframe
    lastUrlPushed: false
};
function mergeNavigatedUrl(state, url) {
    var index = state.navIndex;
    var nav = state.navigation;
    index++;
    nav[index] = url;
    //If we slotted at a position that is not the end of the array
    //remove everything after it
    if (nav.length > index + 1) {
        nav.splice(index + 1);
    }
    var newState = {
        navIndex: index,
        navigation: nav,
        lastUrlPushed: false
    };
    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), newState);
}
function taskPaneReducer(state, action) {
    if (state === void 0) { state = exports.TASK_PANE_INITIAL_STATE; }
    switch (action.type) {
        case actions_1.ActionType.INIT_APP:
            {
                var payload = action.payload;
                var newState = {
                    initialUrl: payload.initialUrl,
                    navIndex: 0,
                    navigation: [payload.initialUrl]
                };
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), newState);
            }
        case actions_1.ActionType.TASK_PANE_HOME:
            {
                if (state.initialUrl != null) {
                    return mergeNavigatedUrl(state, state.initialUrl);
                }
                return state;
            }
        case actions_1.ActionType.TASK_PANE_BACK:
            {
                var index = state.navIndex;
                var nav = state.navigation;
                index--;
                var newState = {
                    navIndex: index,
                    navigation: nav,
                    lastUrlPushed: false
                };
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), newState);
            }
        case actions_1.ActionType.TASK_PANE_FORWARD:
            {
                var index = state.navIndex;
                var nav = state.navigation;
                index++;
                var newState = {
                    navIndex: index,
                    navigation: nav,
                    lastUrlPushed: false
                };
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), newState);
            }
        case actions_1.ActionType.TASK_PANE_PUSH_URL:
            {
                var payload = action.payload;
                var index = state.navIndex;
                var nav = state.navigation;
                //if (areUrlsSame(nav[index], action.payload.url)) {
                //    return state;
                //}
                nav[index + 1] = payload.url;
                //If we slotted at a position that is not the end of the array
                //remove everything after it
                if (nav.length > index + 2) {
                    nav.splice(index + 2);
                }
                if (payload.silent === true) {
                    var newState = {
                        navigation: nav
                    };
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), newState);
                }
                else {
                    var newState = {
                        navIndex: index + 1,
                        navigation: nav,
                        lastUrlPushed: true
                    };
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), newState);
                }
            }
        case actions_1.ActionType.TASK_INVOKE_URL:
            {
                return mergeNavigatedUrl(state, action.payload.url);
            }
    }
    return state;
}
exports.taskPaneReducer = taskPaneReducer;


/***/ }),

/***/ "./src/reducers/template.ts":
/*!**********************************!*\
  !*** ./src/reducers/template.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.templateReducer = exports.setCustomTemplateReducer = exports.isElementState = exports.TEMPLATE_INITIAL_STATE = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
exports.TEMPLATE_INITIAL_STATE = {
    initialInfoPaneWidth: 250,
    initialTaskPaneWidth: 300,
    taskPaneVisible: true,
    selectionPanelVisible: true,
    legendVisible: true,
    autoDisplaySelectionPanelOnSelection: true
};
/**
 * Checks if the given payload is an element state
 *
 * @export
 * @param {*} args
 * @returns {args is IElementState}
 */
function isElementState(args) {
    return args != null
        && typeof (args.legendVisible) != 'undefined'
        && typeof (args.selectionPanelVisible) != 'undefined'
        && typeof (args.taskPaneVisible) != 'undefined';
}
exports.isElementState = isElementState;
var _ovReducer;
/**
 * Installs a custom template reducer function. This is generally used by viewer templates
 * which need to respond to template-related actions in a way that is unique to the template
 *
 * @export
 * @param {ReducerFunction<ITemplateReducerState>} func
 */
function setCustomTemplateReducer(func) {
    _ovReducer = func;
}
exports.setCustomTemplateReducer = setCustomTemplateReducer;
function templateReducer(origState, action) {
    if (origState === void 0) { origState = exports.TEMPLATE_INITIAL_STATE; }
    var state = origState;
    //Whether this reducer has been overridden or not, service the MAP_SET_SELECTION action and
    //if we get modified state, pass that down to the rest of the reducer
    if (action.type == actions_1.ActionType.MAP_SET_SELECTION) {
        var selection = action.payload.selection;
        if (selection && selection.SelectedFeatures) {
            if (selection.SelectedFeatures.SelectedLayer.length && origState.autoDisplaySelectionPanelOnSelection) {
                state = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, origState), { selectionPanelVisible: true, legendVisible: false, taskPaneVisible: false });
            }
        }
    }
    if (action.type == actions_1.ActionType.MAP_ADD_CLIENT_SELECTED_FEATURE) {
        var feature = action.payload.feature;
        if (feature === null || feature === void 0 ? void 0 : feature.properties) {
            state = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, origState), { selectionPanelVisible: true, legendVisible: false, taskPaneVisible: false });
        }
    }
    if (typeof (_ovReducer) == 'function') {
        return _ovReducer(origState, state, action);
    }
    else {
        //If no template present (they would've overridden this reducer), at least service the actions we know affect this
        //particular state branch
        switch (action.type) {
            case actions_1.ActionType.FUSION_SET_ELEMENT_STATE:
                {
                    if (isElementState(action.payload)) {
                        return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), action.payload);
                    }
                    return state;
                }
            case actions_1.ActionType.INIT_APP:
                {
                    var state1 = {};
                    if (action.payload.initialTaskPaneWidth) {
                        state1.initialTaskPaneWidth = action.payload.initialTaskPaneWidth;
                    }
                    if (action.payload.initialInfoPaneWidth) {
                        state1.initialInfoPaneWidth = action.payload.initialInfoPaneWidth;
                    }
                    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
                }
        }
    }
    return state;
}
exports.templateReducer = templateReducer;


/***/ }),

/***/ "./src/reducers/toolbar.ts":
/*!*********************************!*\
  !*** ./src/reducers/toolbar.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toolbarReducer = exports.TOOLBAR_INITIAL_STATE = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var immutability_helper_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! immutability-helper */ "./node_modules/immutability-helper/index.js"));
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
var template_1 = __webpack_require__(/*! ./template */ "./src/reducers/template.ts");
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
function mergeFlyoutState(flyoutId, state, flyoutPayload, flyoutUpdateAction, closeOtherFlyouts, bSettingStates) {
    if (closeOtherFlyouts === void 0) { closeOtherFlyouts = false; }
    if (bSettingStates === void 0) { bSettingStates = false; }
    var updateSpec = {
        flyouts: {}
    };
    if (!state.flyouts[flyoutId] && bSettingStates) {
        return state;
    }
    var flyoutUpdateSpec = {};
    flyoutUpdateSpec[flyoutUpdateAction] = flyoutPayload;
    updateSpec.flyouts[flyoutId] = flyoutUpdateSpec;
    if (closeOtherFlyouts) {
        //Close others
        for (var key in state.flyouts) {
            if (key != flyoutId) {
                updateSpec.flyouts[key] = {
                    "$merge": {
                        open: false
                    }
                };
            }
        }
    }
    var newState = (0, immutability_helper_1.default)(state, updateSpec);
    return newState;
}
function mergeFlyoutCloseState(flyoutId, state, bSettingStates) {
    if (bSettingStates === void 0) { bSettingStates = false; }
    return mergeFlyoutState(flyoutId, state, {
        open: false,
        metrics: null
    }, "$merge", false, bSettingStates);
}
exports.TOOLBAR_INITIAL_STATE = {
    toolbars: {},
    flyouts: {}
};
function toolbarReducer(state, action) {
    if (state === void 0) { state = exports.TOOLBAR_INITIAL_STATE; }
    switch (action.type) {
        case actions_1.ActionType.INIT_APP:
            {
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), action.payload.toolbars);
            }
        case actions_1.ActionType.COMPONENT_OPEN:
            {
                var payload = action.payload;
                var flyoutId = payload.flyoutId;
                if (flyoutId) {
                    return mergeFlyoutState(flyoutId, state, {
                        open: true,
                        metrics: payload.metrics,
                        componentName: payload.name,
                        componentProps: payload.props
                    }, "$set", //Need to use $set instead of $merge as the tree won't have component flyout info initially
                    true);
                }
                return state;
            }
        case actions_1.ActionType.COMPONENT_CLOSE:
            {
                if (!state.flyouts[constants_1.WEBLAYOUT_CONTEXTMENU]) {
                    return state;
                }
                var flyoutId = action.payload.flyoutId;
                if (flyoutId) {
                    return mergeFlyoutState(flyoutId, state, {
                        open: false,
                        metrics: null,
                        componentName: null,
                        componentProps: null
                    }, "$set"); //Need to use $set instead of $merge as the tree won't have component flyout info initially
                }
                return state;
            }
        case actions_1.ActionType.CONTEXT_MENU_OPEN:
            {
                if (!state.flyouts[constants_1.WEBLAYOUT_CONTEXTMENU]) {
                    return state;
                }
                return mergeFlyoutState(constants_1.WEBLAYOUT_CONTEXTMENU, state, {
                    open: true,
                    metrics: {
                        posX: action.payload.x,
                        posY: action.payload.y
                    }
                }, "$merge", true);
            }
        case actions_1.ActionType.FLYOUT_OPEN:
            {
                var flyoutId = action.payload.flyoutId;
                if (flyoutId) {
                    return mergeFlyoutState(flyoutId, state, {
                        open: true,
                        metrics: action.payload.metrics
                    }, "$merge", true);
                }
                return state;
            }
        case actions_1.ActionType.FUSION_SET_ELEMENT_STATE:
            {
                if ((0, template_1.isElementState)(action.payload) && !action.payload.taskPaneVisible) {
                    return mergeFlyoutCloseState(constants_1.WEBLAYOUT_TASKMENU, state, true);
                }
                return state;
            }
        case actions_1.ActionType.FUSION_SET_TASK_PANE_VISIBILITY:
            {
                if (!action.payload) {
                    return mergeFlyoutCloseState(constants_1.WEBLAYOUT_TASKMENU, state);
                }
                return state;
            }
        case actions_1.ActionType.FLYOUT_CLOSE:
            {
                var flyoutId = action.payload.flyoutId;
                if (flyoutId) {
                    return mergeFlyoutCloseState(flyoutId, state);
                }
            }
        case actions_1.ActionType.CONTEXT_MENU_CLOSE:
            {
                return mergeFlyoutCloseState(constants_1.WEBLAYOUT_CONTEXTMENU, state);
            }
    }
    return state;
}
exports.toolbarReducer = toolbarReducer;


/***/ }),

/***/ "./src/reducers/viewer.ts":
/*!********************************!*\
  !*** ./src/reducers/viewer.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.viewerReducer = exports.VIEWER_INITIAL_STATE = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
exports.VIEWER_INITIAL_STATE = {
    busyCount: 0,
    size: undefined,
    tool: common_1.ActiveMapTool.None,
    featureTooltipsEnabled: true
};
function viewerReducer(state, action) {
    if (state === void 0) { state = exports.VIEWER_INITIAL_STATE; }
    switch (action.type) {
        case actions_1.ActionType.INIT_APP:
            {
                var tool = action.payload.initialActiveTool;
                var ft = action.payload.featureTooltipsEnabled;
                var state1 = void 0;
                if (tool != null) {
                    state1 = {
                        tool: tool
                    };
                }
                var state2 = void 0;
                if (typeof (ft) != 'undefined') {
                    state2 = {
                        featureTooltipsEnabled: ft
                    };
                }
                return (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1), state2);
            }
        case actions_1.ActionType.MAP_SET_ACTIVE_TOOL:
            {
                var state1 = {
                    tool: action.payload
                };
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
            }
        case actions_1.ActionType.MAP_SET_MAPTIP:
            {
                var state1 = {
                    featureTooltipsEnabled: action.payload
                };
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
            }
        case actions_1.ActionType.MAP_ENABLE_SELECT_DRAGPAN:
            {
                var state1 = {
                    selectCanDragPan: action.payload
                };
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
            }
        case actions_1.ActionType.MAP_SET_BUSY_COUNT:
            {
                var state1 = {
                    busyCount: action.payload
                };
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
            }
        case actions_1.ActionType.MAP_RESIZED:
            {
                var state1 = {
                    size: [action.payload.width, action.payload.height]
                };
                return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, state), state1);
            }
    }
    return state;
}
exports.viewerReducer = viewerReducer;


/***/ }),

/***/ "./src/store/configure-store.ts":
/*!**************************************!*\
  !*** ./src/store/configure-store.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configureStore = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var redux_1 = __webpack_require__(/*! redux */ "./node_modules/redux/es/redux.js");
var redux_thunk_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! redux-thunk */ "./node_modules/redux-thunk/es/index.js"));
var promise_middleware_1 = __webpack_require__(/*! ./promise-middleware */ "./src/store/promise-middleware.ts");
var logger_1 = __webpack_require__(/*! ./logger */ "./src/store/logger.ts");
var root_1 = __webpack_require__(/*! ../reducers/root */ "./src/reducers/root.ts");
function configureStore(initialState, extraReducers) {
    var root = extraReducers ? (0, redux_1.combineReducers)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, root_1.rootReducer), extraReducers)) : (0, redux_1.combineReducers)(root_1.rootReducer);
    var store = redux_1.compose.apply(void 0, (0, tslib_1.__spreadArray)([//HACK: Something bogus about the compose() declaration
        _getMiddleware()], _getEnhancers(), false))(redux_1.createStore)(root, initialState);
    return store;
}
exports.configureStore = configureStore;
function _getMiddleware() {
    var middleware = [
        promise_middleware_1.promiseMiddleware,
        redux_thunk_1.default,
    ];
    if (true) {
        middleware = (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], middleware, true), [logger_1.logger], false);
    }
    return redux_1.applyMiddleware.apply(void 0, middleware);
}
function _getEnhancers() {
    var enhancers = [];
    if ( true && window.__REDUX_DEVTOOLS_EXTENSION__) {
        enhancers = (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], enhancers, true), [window.__REDUX_DEVTOOLS_EXTENSION__()], false);
    }
    return enhancers;
}


/***/ }),

/***/ "./src/store/logger.ts":
/*!*****************************!*\
  !*** ./src/store/logger.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logger = void 0;
var actions_1 = __webpack_require__(/*! ../constants/actions */ "./src/constants/actions.ts");
var createLogger = __webpack_require__(/*! redux-logger */ "./node_modules/redux-logger/dist/redux-logger.es.js").createLogger;
exports.logger = createLogger({
    collapsed: true,
    stateTransformer: function (state) {
        return state;
    },
    //Note the { type } syntax: https://github.com/Microsoft/TypeScript/issues/9657
    predicate: function (getState, _a) {
        var type = _a.type;
        return type !== 'redux-form/BLUR' &&
            type !== 'redux-form/CHANGE' &&
            type !== 'redux-form/FOCUS' &&
            type !== 'redux-form/TOUCH' &&
            type !== actions_1.ActionType.MAP_RESIZED &&
            type !== actions_1.ActionType.UPDATE_MOUSE_COORDINATES &&
            type !== actions_1.ActionType.MAP_SET_BUSY_COUNT &&
            type !== actions_1.ActionType.ADD_LAYER_BUSY_WORKER &&
            type !== actions_1.ActionType.REMOVE_LAYER_BUSY_WORKER;
    },
});


/***/ }),

/***/ "./src/store/promise-middleware.ts":
/*!*****************************************!*\
  !*** ./src/store/promise-middleware.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.promiseMiddleware = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/**
 * Returns whether the provided value is a promise
 *
 * @hidden
 * @param {object} value Potential promise
 * @return {Boolean}
 */
function isPromise(value) {
    if (value !== null && typeof value === 'object') {
        return value.promise && typeof value.promise.then === 'function';
    }
}
/**
 * @hidden
 */
function promiseMiddleware(_a) {
    var dispatch = _a.dispatch;
    return function (next) { return function (action) {
        if (!isPromise(action.payload)) {
            return next(action);
        }
        var types = action.types, payload = action.payload, meta = action.meta;
        var promise = payload.promise, data = payload.data;
        var PENDING = types[0], FULFILLED = types[1], REJECTED = types[2];
        var p1 = { type: PENDING };
        var p2 = data ? { payload: data } : {};
        var p3 = meta ? { meta: meta } : {};
        /**
         * Dispatch the pending action
         */
        dispatch((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, p1), p2), p3));
        /**
         * If successful, dispatch the fulfilled action, otherwise dispatch
         * rejected action.
         */
        return promise.then(function (result) {
            dispatch({
                type: FULFILLED,
                payload: result,
                meta: meta,
            });
        }, function (error) {
            dispatch({
                type: REJECTED,
                payload: error,
                meta: meta,
            });
        });
    }; };
}
exports.promiseMiddleware = promiseMiddleware;


/***/ }),

/***/ "./src/strings/en.ts":
/*!***************************!*\
  !*** ./src/strings/en.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.STRINGS_EN = void 0;
var constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");
exports.STRINGS_EN = {
    "OK": "OK",
    "NONE": "NONE",
    "ERROR": "Error",
    "WARNING": "Warning",
    "PBMG": "Powered by <a href='https://mapguide.osgeo.org' target='_blank'>MapGuide</a>",
    "INIT_WARNINGS_FOUND": "The following warnings were encountered loading the viewer",
    "INIT_WARNING_BING_API_KEY_REQD": "A Bing Maps API key is required. Sign up for an API key at http://www.bingmapsportal.com/",
    "INIT_WARNING_BING_UNKNOWN_LAYER": "Unknown bing maps layer type {type}. This layer was skipped",
    "INIT_WARNING_UNSUPPORTED_GOOGLE_MAPS": "This viewer does not support Google Maps base layers",
    "INIT_WARNING_NO_CONTEXT_MENU": "Could not find the context menu configuration. Right-clicking the map will show an empty context menu. If you are loading from a Flexible Layout, it must have a container named '{containerName}'",
    "LAYER_TRANSPARENCY": "Layer Transparency",
    "LAYER_ID_BASE": "Base Layers",
    "LAYER_ID_MG_BASE": "MapGuide Map",
    "LAYER_ID_SUBJECT": "Subject Layer",
    "LAYER_ID_MG_SEL_OVERLAY": "MapGuide Selection Overlay",
    "UNKNOWN_WIDGET": "This button references an unknown or unsupported widget: {widget}",
    "UNKNOWN_COMMAND_REFERENCE": "This button references an unknown command or unsupported: {command}",
    "INIT": "Initializing",
    "INIT_DESC": "Please wait while the viewer is loading required assets ...",
    "INIT_ERROR_TITLE": "An error occurred during startup",
    "INIT_ERROR_UNKNOWN_RESOURCE_TYPE": "<p>Unknown or unsupported resource type for resource: <strong>{resourceId}</strong></p>",
    "INIT_ERROR_MISSING_RESOURCE_PARAM": "<p>No <strong>resource</strong> parameter found. This viewer assumes this parameter to be set in the query string and must refer to a valid Web Layout or Application Definition. If not specified, it will try to init from a Application Definition document at <strong>appdef.json</strong></p>",
    "INIT_ERROR_UNSUPPORTED_COORD_SYS": "<p>The Map Definition <strong>{mapDefinition}</strong>, uses a coordinate system that does not resolve to a valid EPSG code and cannot be loaded in this viewer</p><p>Solution:</p><ul><li>Change the coordinate system of this Map Definition to one that resolves to an EPSG code</li><li>Please note: There will be a small performance overhead for server-side re-projection as a result of doing this</li></ul>",
    "INIT_ERROR_UNREGISTERED_EPSG_CODE": "<p>The Map Definition <strong>{mapDefinition}</strong>, uses a coordinate system that resolves to a valid EPSG code (<strong>EPSG:{epsg}</strong>), but no projection for this EPSG code has been registered</p><p>Solution:</p><ol><li>Search for the matching proj4js definition at <a href='http://epsg.io/'>http://epsg.io/</a></li><li>Register this projection to the viewer before mounting it</li></ol>",
    "INIT_ERROR_EXPIRED_SESSION": "<p>The session id given has expired: <strong>{sessionId}</strong></p><p>Reload the viewer without the <strong>session</strong> parameter, or supply a valid session id for the <strong>session</strong> parameter</p>",
    "INIT_ERROR_RESOURCE_NOT_FOUND": "Attempted to load the following resource, but it was not found: <strong>{resourceId}</strong>",
    "INIT_ERROR_NO_CONNECTION": "<p>There is no connection between the MapGuide Web Tier and the MapGuide Server.</p><p>Possible causes:</p><ul><li>MapGuide Server is not running or is no longer responding</li><li>Internet connection problems</li></ul><p>Possible solutions:</p><ul><li>Restart the MapGuide Server Service</li><li>Contact your server administrator</li></ul>",
    "TPL_SIDEBAR_OPEN_TASKPANE": "Open Task Pane",
    "TPL_SIDEBAR_OPEN_LEGEND": "Open Legend",
    "TPL_SIDEBAR_OPEN_SELECTION_PANEL": "Open Selection Panel",
    "TPL_TITLE_TASKPANE": "Task Pane",
    "TPL_TITLE_LEGEND": "Legend",
    "TPL_TITLE_SELECTION_PANEL": "Selection",
    "TT_GO_HOME": "Go home",
    "TT_GO_BACK": "Go back",
    "TT_GO_FORWARD": "Go forward",
    "SESSION_EXPIRED": "Session Expired",
    "SESSION_EXPIRED_DETAILED": "Your current MapGuide session has expired",
    "SESSION_EXPIRED_AVAILABLE_ACTIONS": "Available Actions:",
    "SESSION_EXPIRED_RELOAD_VIEWER": "Reload the viewer",
    "ERR_UNREGISTERED_LAYOUT": "ERROR: No layout named ({layout}) registered",
    "ERR_UNREGISTERED_COMPONENT": "ERROR: No such registered component ({componentId}). Ensure the component has been registered in the component registry with an id of: {componentId}",
    "ERR_NO_COMPONENT_ID": "No component id specified",
    "LOADING_MSG": "Loading ...",
    "MENU_TASKS": "Tasks",
    "NO_SELECTED_FEATURES": "No selected features",
    "FMT_SCALE_DISPLAY": "Scale - 1:{scale}",
    "FMT_SELECTION_COUNT": "Selected {total} feature(s) in {layerCount} layer(s)",
    "DIGITIZE_POINT_PROMPT": "Click to finish and draw a point at this location<br/><br/>Press ESC to cancel",
    "DIGITIZE_LINE_PROMPT": "Click to set this position as the start.<br/>Click again to finish the line at this position<br/><br/>Press ESC to cancel",
    "DIGITIZE_LINESTRING_PROMPT": "Click to set this position as the start.<br/>Click again to add a vertex at this position.<br/>If you drew a vertex at the wrong spot, you can press {key} to undo.<br/>Hold SHIFT and drag while digitizing to draw in freehand mode<br/></br>Double click to finish<br/>Press ESC to cancel",
    "DIGITIZE_CIRCLE_PROMPT": "Click to set this position as the center.<br/>Move out to the desired radius and click again to finish<br/><br/>Press ESC to cancel",
    "DIGITIZE_RECT_PROMPT": "Click to set this position as one corner.<br/>Click again to finish and set this position as the other corner<br/><br/>Press ESC to cancel",
    "DIGITIZE_POLYGON_PROMPT": "Click to set this positon as the start.<br/>Click again to add a vertex at this position.<br/>If you drew a vertex at the wrong spot, you can press {key} to undo<br/>Hold SHIFT and drag while digitizing to draw in freehand mode<br/><br/>Double click to finish and close the polygon<br/>Press ESC to cancel",
    "MEASURE": "Measure",
    "MEASURE_SEGMENT": "Segment",
    "MEASURE_LENGTH": "Length",
    "MEASURE_SEGMENT_PART": "Segment {segment}",
    "MEASURE_TOTAL_AREA": "Total Area",
    "MEASURE_TOTAL_LENGTH": "Total Length",
    "MEASURING": "Measuring",
    "MEASURING_MESSAGE": "You are currently measuring",
    "MEASUREMENT": "Measurement",
    "MEASUREMENT_TYPE": "Measurement Type",
    "MEASUREMENT_TYPE_LENGTH": "Length (LineString)",
    "MEASUREMENT_TYPE_AREA": "Area (Polygon)",
    "MEASUREMENT_CLEAR": "Clear",
    "MEASUREMENT_CONTINUE_POLYGON": "Click to continue drawing the polygon. Double-click to finish.",
    "MEASUREMENT_CONTINUE_LINE": "Click to continue drawing the line. Double-click to finish.",
    "MEASUREMENT_START_DRAWING": "Click to start drawing",
    "MEASUREMENT_START": "Start",
    "MEASUREMENT_END": "End",
    "NAVIGATOR_PAN_EAST": "Pan East",
    "NAVIGATOR_PAN_WEST": "Pan West",
    "NAVIGATOR_PAN_SOUTH": "Pan South",
    "NAVIGATOR_PAN_NORTH": "Pan North",
    "NAVIGATOR_ZOOM_OUT": "Zoom Out",
    "NAVIGATOR_ZOOM_IN": "Zoom In",
    "FMT_NAVIGATOR_ZOOM_TO_SCALE": "Zoom to 1:{scale}",
    "EXTERNAL_BASE_LAYERS": "External Base Layers",
    "SELECTION_PROPERTY": "Property",
    "SELECTION_VALUE": "Value",
    "SELECTION_PREV_FEATURE": "Previous Feature",
    "SELECTION_NEXT_FEATURE": "Next Feature",
    "SELECTION_ZOOMTO_FEATURE": "Zoom to selected feature",
    "VIEWER_OPTIONS": "Viewer Options",
    "ABOUT": "About",
    "HELP": "Help",
    "QUICKPLOT_HEADER": "Quick Plot",
    "QUICKPLOT_TITLE": "Title",
    "QUICKPLOT_SUBTITLE": "Sub-Title",
    "QUICKPLOT_PAPER_SIZE": "Paper Size",
    "QUICKPLOT_ORIENTATION": "Orientation",
    "QUICKPLOT_ORIENTATION_P": "Portrait",
    "QUICKPLOT_ORIENTATION_L": "Landscape",
    "QUICKPLOT_SHOWELEMENTS": "Show Elements",
    "QUICKPLOT_SHOWLEGEND": "Show Legend",
    "QUICKPLOT_SHOWNORTHARROW": "Show North Arrow",
    "QUICKPLOT_SHOWCOORDINTES": "Show Coordinates",
    "QUICKPLOT_SHOWSCALEBAR": "Show Scalebar",
    "QUICKPLOT_SHOWDISCLAIMER": "Show Disclaimer",
    "QUICKPLOT_ADVANCED_OPTIONS": "Advanced Options",
    "QUICKPLOT_SCALING": "Scale",
    "QUICKPLOT_DPI": "DPI",
    "QUICKPLOT_BOX_INFO": "Quick Plot Map Capture box is active. Map rotation is disabled while box is active",
    "QUICKPLOT_BOX_ROTATION": "Capture Box Rotation",
    "QUICKPLOT_GENERATE": "Generate Plot",
    "QUICKPLOT_COMMERCIAL_LAYER_WARNING": "Quick Plot will NOT include any visible commercial map layers",
    "FEATURE_TOOLTIPS": "Feature Tooltips",
    "MANUAL_FEATURE_TOOLTIPS": "Manual Feature Tooltips (click to show)",
    "GEOLOCATION_SUCCESS": "Zoomed to your position",
    "GEOLOCATION_WARN_OUTSIDE_MAP": "Zoomed to your position. It is outside the extents of your map",
    "GEOLOCATION_ERROR": "Geolocation error: {message} ({code})",
    "TASK_PANE_RESIZING": "Task Pane is resizing ...",
    "TASK_PANE_LOADING": "Loading",
    "TASK_PANE_LOADING_DESC": "Task Pane content is loading ...",
    "COORDTRACKER": "Coordinate Tracker",
    "COORDTRACKER_NO_PROJECTIONS": "You have no projections configured for this component",
    "MAP_SIZE_DISPLAY_UNITS": "Map view size display units",
    "ADD_MANAGE_LAYERS": "Add/Manage Layers",
    "ADD_LAYER": "Add Layer",
    "ADD_LAYER_TILED": "Add Tiled Layer",
    "MANAGE_LAYERS": "Manage Layers",
    "LAYER_TYPE": "Layer Type",
    "SELECT_LAYER_TYPE": "Select Layer Type ...",
    "ADD_WMS_LAYER_URL": "WMS Service URL",
    "ADD_WMS_LAYER_LOADING": "Loading",
    "ADD_WMS_LAYER_LOADING_DESC": "Loading WMS Capabilities",
    "ADD_WMS_LAYER_NO_LAYERS": "No WMS Layers",
    "WMS_VERSION": "WMS Version: {version}",
    "ADD_WFS_LAYER_URL": "WFS Service URL",
    "ADD_WFS_LAYER_LOADING": "Loading",
    "ADD_WFS_LAYER_LOADING_DESC": "Loading WFS Capabilities",
    "ADD_WFS_LAYER_NO_LAYERS": "No WFS Layers",
    "WFS_NO_LAYER_DESCRIPTION": "Enter a WFS Service URL above and click the button beside it to load available layers",
    "WFS_VERSION": "WFS Version: {version}",
    "OWS_SERVICE_NAME": "Name: {name}",
    "OWS_SERVICE_TITLE": "Title: {title}",
    "OWS_SERVICE_ABSTRACT": "Abstract: {abstract}",
    "WMS_LAYERS": "WMS Layers",
    "WFS_LAYERS": "WFS Layers",
    "OWS_LAYER_NAME": "Name: {name}",
    "OWS_LAYER_TITLE": "Title: {title}",
    "OWS_LAYER_ABSTRACT": "Abstract: {abstract}",
    "OWS_LAYER_CRS": "CRS: {crs}",
    "OWS_ADD_LAYER_PROMPT": "Click this layer to add it to the map",
    "ADDED_LAYER": "Added layer: {name}",
    "REMOVED_LAYER": "Removed layer: {name}",
    "ADD_WFS_LAYER": "Add WFS Layer",
    "SHARE_LINK_COPY_CLIPBOARD": "Copy Link",
    "SHARE_LINK_COPIED": "Link copied",
    "WMS_NO_LAYER_DESCRIPTION": "Enter a WMS Service URL above and click the button beside it to load available layers",
    "UNIT_UNKNOWN": "Unknown",
    "UNIT_INCHES": "Inches",
    "UNIT_FEET": "Feet",
    "UNIT_YARDS": "Yards",
    "UNIT_MILES": "Miles",
    "UNIT_NAUT_MILES": "Nautical Miles",
    "UNIT_MILLIMETERS": "Millimeters",
    "UNIT_CENTIMETERS": "Centimeters",
    "UNIT_METERS": "Meters",
    "UNIT_KILOMETERS": "Kilometers",
    "UNIT_DEGREES": "Degrees",
    "UNIT_DEC_DEGREES": "Decimal Degrees",
    "UNIT_DMS": "Degrees Minutes Seconds",
    "UNIT_PIXELS": "Pixels",
    "UNIT_ABBR_UNKNOWN": "unk",
    "UNIT_ABBR_INCHES": "in",
    "UNIT_ABBR_FEET": "ft",
    "UNIT_ABBR_YARDS": "yd",
    "UNIT_ABBR_MILES": "mi",
    "UNIT_ABBR_NAUT_MILES": "nm",
    "UNIT_ABBR_MILLIMETERS": "mm",
    "UNIT_ABBR_CENTIMETERS": "cm",
    "UNIT_ABBR_METERS": "m",
    "UNIT_ABBR_KILOMETERS": "km",
    "UNIT_ABBR_DEGREES": constants_1.DEG,
    "UNIT_ABBR_DEC_DEGREES": constants_1.DEG,
    "UNIT_ABBR_DMS": constants_1.DEG,
    "UNIT_ABBR_PIXELS": "px",
    "UNIT_FMT_M": "{value} m",
    "UNIT_FMT_KM": "{value} km",
    "UNIT_FMT_SQM": "{value} m<sup>2</sup>",
    "UNIT_FMT_SQKM": "{value} km<sup>2</sup>",
    "OL_ATTRIBUTION_TIP": "Attributions",
    "OL_OVERVIEWMAP_TIP": "Overview Map",
    "OL_RESET_ROTATION_TIP": "Reset Rotation",
    "FEATURE_TOOLTIP_URL_HELP_TEXT": "Click for more information",
    "SHARE_LINK_INCLUDE_SESSION": "Include Session ID",
    "WINDOW_RESIZING": "Resizing Window",
    "WINDOW_MOVING": "Moving Window",
    "OTHER_THEME_RULE_COUNT": "... ({count} other theme rules)",
    "LEGEND_FILTER_LAYERS": "Filter/search for layers or groups",
    "ADD_LAYER_KIND_PROMPT": "What kind of layer do you want to add?",
    "LAYER_KIND_FILE": "A local file-based layer",
    "LAYER_KIND_URL": "A remote url-based layer",
    "ADD_FILE": "Add Local File",
    "ADD_FILE_INSTRUCTIONS": "Browse and select a file to view it locally on the map (it won't be saved or uploaded to the internet)",
    "FMT_UPLOADED_FILE": "(size: {size} bytes, type: {type})",
    "ADD_LOCAL_FILE_LAYER_FAILURE_NOT_TEXT": "Could not read text content from this file",
    "ADD_LOCAL_FILE_LAYER_FAILURE": "Failed to load file as layer. It is probably an unsupported file format",
    "WMS_UNSUPPORTED_VERSION": "Unsupported WMS version: {version}",
    "NO_EXTERNAL_LAYERS": "No Layers",
    "NO_EXTERNAL_LAYERS_DESC": "Add layers via the {tabName} tab above",
    "LAYER_OPACITY": "Opacity",
    "LAYER_HEATMAP_BLUR": "Heatmap Blur Size",
    "LAYER_HEATMAP_RADIUS": "Heatmap Radius Size",
    "LAYER_NAME_EXISTS": "A layer named {name} already exists",
    "LAYER_MANAGER_TT_MOVE_UP": "Move this layer up the draw order",
    "LAYER_MANAGER_TT_MOVE_DOWN": "Move this layer down the draw order",
    "LAYER_MANAGER_TT_ZOOM_EXTENTS": "Zoom to the extents of this layer",
    "LAYER_MANAGER_TT_REMOVE": "Remove this layer",
    "LAYER_MANAGER_TT_EDIT_STYLE": "Edit style",
    "LAYER_MANAGER_TT_MORE_OPTIONS": "Show more layer options",
    "CANCEL": "Cancel",
    "UNKNOWN_FILE_TYPE": "Unknown",
    "WMS_SERVICE_INFO": "WMS Service Info",
    "WFS_SERVICE_INFO": "WFS Service Info",
    "WMS_AVAILABLE_LAYERS": "Available WMS Layers",
    "WFS_AVAILABLE_LAYERS": "Available WFS Layers",
    "ADD_LAYER_WITH_WMS_STYLE": "Add layer ({style})",
    "ADD_LAYER_WITH_WMS_STYLE_TILED": "Add tiled layer ({style})",
    "WMS_LEGEND": "WMS Legend",
    "VSED_NO_STYLES_TITLE": "No Styles",
    "VSED_NO_STYLES_DESC": "This editor is not configured to edit any styles",
    "VECTOR_LAYER_STYLE": "Vector Layer Style",
    "VSED_PT_FILL_COLOR": "Point Fill Color",
    "VSED_PT_FILL_COLOR_ALPHA": "Point Fill Color Alpha",
    "VSED_PT_RADIUS": "Point Radius",
    "VSED_PT_OUTLINE_COLOR": "Point Outline Color",
    "VSED_PT_OUTLINE_COLOR_ALPHA": "Point Outline Color Alpha",
    "VSED_PT_OUTLINE_WIDTH": "Point Outline Thickness",
    "VSED_LN_OUTLINE_COLOR": "Line Color",
    "VSED_LN_OUTLINE_COLOR_ALPHA": "Line Color Alpha",
    "VSED_LN_OUTLINE_THICKNESS": "Line Thickness",
    "VSED_PL_FILL_COLOR": "Fill Color",
    "VSED_PL_FILL_COLOR_ALPHA": "Fill Color Alpha",
    "VSED_PL_OUTLINE_COLOR": "Outline Color",
    "VSED_PL_OUTLINE_COLOR_ALPHA": "Outline Color Alpha",
    "VSED_PL_OUTLINE_THICKNESS": "Outline Thickness",
    "VSED_TAB_POINT": "Point",
    "VSED_TAB_LINE": "Line",
    "VSED_TAB_POLY": "Polygon",
    "VSED_PT_TYPE": "Point Style Type",
    "VSED_PT_TYPE_CIRCLE": "Circle",
    "VSED_PT_TYPE_ICON": "Icon",
    "VSED_PT_ICON_ANCHOR": "Anchor",
    "VSED_PT_ICON_ANCHOR_H": "Horizontal",
    "VSED_PT_ICON_ANCHOR_V": "Vertical",
    "VSED_PT_ICON_SRC": "Image URL",
    "VSED_PT_ICON_ROTATE_WITH_VIEW": "Rotate with view",
    "VSED_PT_ICON_ROTATION": "Rotation",
    "VSED_PT_ICON_SCALE": "Scale",
    "ADD_LAYER_PROJECTION": "Projection of this layer",
    "ADDING_LAYER_ERROR": "Error adding layer",
    "LOADING_LAYER": "Loading layer: {name}",
    "ACTION_CLOSE": "Close",
    "MORE_LAYER_OPTIONS": "More Layer Options",
    "CHOOSE_FILE": "Choose file ...",
    "BROWSE": "Browse",
    "SEL_FEATURE_PROPERTIES": "Feature Properties",
    "SEL_FEATURE_PROPERTIES_NONE": "No properties",
    "SEL_CLUSTER_PROPERTIES": "Cluster Properties (size: {size})",
    "ADD_LOCAL_FILE_LAYER_FAILURE_NO_FORMATS": "Failed to add layer. No format drivers registered",
    "ENABLE_CLUSTERING": "Enable Clustering",
    "POINT_CLUSTER_DISTANCE": "Point Cluster Distance",
    "EXPR_NOT_SET": "(Not set)",
    "ENABLE_LABELS": "Enable Labels",
    "LABEL_TEXT": "Label Text",
    "LABEL_SIZE": "Label Size",
    "LABEL_COLOR": "Label Color",
    "LABEL_OUTLINE_COLOR": "Label Outline Color",
    "LABEL_OUTLINE_THICKNESS": "Label Outline Thickness",
    "LABEL_BOLD": "Bold",
    "LABEL_ITALIC": "Italic",
    "LABEL_LINE_PLACEMENT": "Line Placement",
    "ADD_FILE_PROCESSING": "Processing file ...",
    "GENERATE_THEMABLE_LAYER": "Generate Themable Layer",
    "THEME_ON_PROPERTY": "Theme On Property",
    "COLORBREWER_THEME": "<a href='https://colorbrewer2.org/' target='_blank'>ColorBrewer</a> theme",
    "LABEL_USING_PROPERTY": "Label Using Property",
    "CLUSTER_CLICK_ACTION": "Action to perform when cluster is clicked",
    "CLUSTER_CLICK_ACTION_SHOW_POPUP": "Display attributes of points in a popup",
    "CLUSTER_CLICK_ACTION_ZOOM_EXTENTS": "Zoom into selected cluster",
    "EXTERNAL_LAYERS": "External Layers",
    "CREATE_VECTOR_LAYER": "Vector Layer",
    "CREATE_VECTOR_THEMED": "Themed Vector Layer",
    "CREATE_VECTOR_CLUSTERED": "Clustered Point Layer",
    "CREATE_VECTOR_HEATMAP": "Heatmap Layer",
    "ENABLE_SELECT_DRAGPAN": "Enable pan dragging for select tool",
    "INIT_WARNING_ARBITRARY_COORDSYS_INCOMPATIBLE_LAYER": "This viewer refers to a map ({mapId}) with an arbitrary coordinate system, which is incompatible with this layer type ({type})",
    "INIT_WARNING_ARBITRARY_COORDSYS_UNSUPPORTED_WIDGET": "This viewer refers to a map ({mapId}) with an arbitrary coordinate system, which is incompatible with this widget ({widget})",
};


/***/ }),

/***/ "./src/utils/array.ts":
/*!****************************!*\
  !*** ./src/utils/array.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.areArraysDifferent = exports.makeUnique = void 0;
/**
 * Returns a unique array of strings from the given array
 * @param items The array of strings to make unique
 * @since 0.13
 */
function makeUnique(arr) {
    var a = [];
    for (var i = 0, l = arr.length; i < l; i++) {
        if (a.indexOf(arr[i]) === -1 && arr[i] !== '')
            a.push(arr[i]);
    }
    return a;
}
exports.makeUnique = makeUnique;
/**
 * Indicates if the given arrays are different (content-wise)
 * @param arr
 * @param other
 * @since 0.13
 */
function areArraysDifferent(arr, other, equalityFn) {
    if (arr && other) {
        if (arr.length != other.length) {
            return true;
        }
        else {
            for (var i = 0; i < arr.length; i++) {
                if (equalityFn) {
                    if (!equalityFn(arr[i], other[i])) {
                        return true;
                    }
                }
                else if (arr[i] !== other[i]) {
                    return true;
                }
            }
            return false;
        }
    }
    else {
        return true;
    }
}
exports.areArraysDifferent = areArraysDifferent;


/***/ }),

/***/ "./src/utils/assert.ts":
/*!*****************************!*\
  !*** ./src/utils/assert.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertIsDefined = void 0;
function assertIsDefined(val) {
    if (val === undefined || val === null) {
        throw new Error("Expected 'val' to be defined, but received " + val);
    }
}
exports.assertIsDefined = assertIsDefined;


/***/ }),

/***/ "./src/utils/asset.ts":
/*!****************************!*\
  !*** ./src/utils/asset.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRelativeIconPath = exports.setAssetRoot = exports.getAssetRoot = exports.getAssetPath = void 0;
function getAssetPath(url) {
    return url;
}
exports.getAssetPath = getAssetPath;
var assets_1 = __webpack_require__(/*! ../constants/assets */ "./src/constants/assets.ts");
//HACK: url-loader has done some breaking things to how our icon asset imports are handled
//while this has been addressed for the main bundle build, this import is still undefined in
//the context of our jest tests. Since nothing in our jest test suite cares that this value
//be set at the moment, just use ?. as a workaround ($DEITY bless TS 3.7 for this wonderful
//syntactic addition!)
var mRoot = assets_1.ICON_ZOOM_OUT_FIXED === null || assets_1.ICON_ZOOM_OUT_FIXED === void 0 ? void 0 : assets_1.ICON_ZOOM_OUT_FIXED.replace("/zoom-out-fixed.png", "/../../");
function getAssetRoot() {
    return mRoot;
}
exports.getAssetRoot = getAssetRoot;
function setAssetRoot(root) {
    mRoot = root;
}
exports.setAssetRoot = setAssetRoot;
function getRelativeIconPath(iconName) {
    return "images/icons/" + iconName + ".png";
}
exports.getRelativeIconPath = getRelativeIconPath;


/***/ }),

/***/ "./src/utils/logger.ts":
/*!*****************************!*\
  !*** ./src/utils/logger.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

// Console wrappers that are only active in development mode
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.debug = exports.error = exports.warn = exports.info = void 0;
/**
 * Log an informational message. Does nothing in a production build
 *
 * @export
 * @param {*} [message]
 * @param {...any[]} optionalParams
 */
function info(message) {
    var optionalParams = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        optionalParams[_i - 1] = arguments[_i];
    }
    if (true) {
        console.info(message, optionalParams);
    }
}
exports.info = info;
/**
 * Log a warning message. Does nothing in a production build
 *
 * @export
 * @param {*} [message]
 * @param {...any[]} optionalParams
 */
function warn(message) {
    var optionalParams = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        optionalParams[_i - 1] = arguments[_i];
    }
    if (true) {
        console.warn(message, optionalParams);
    }
}
exports.warn = warn;
/**
 * Log an error message. Does nothing in a production build
 *
 * @export
 * @param {*} [message]
 * @param {...any[]} optionalParams
 */
function error(message) {
    var optionalParams = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        optionalParams[_i - 1] = arguments[_i];
    }
    if (true) {
        console.error(message, optionalParams);
    }
}
exports.error = error;
/**
 * Log a debug message. Does nothing in a production build
 *
 * @export
 * @param {*} [message]
 * @param {...any[]} optionalParams
 */
function debug(message) {
    var optionalParams = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        optionalParams[_i - 1] = arguments[_i];
    }
    if (true) {
        console.debug(message, optionalParams);
    }
}
exports.debug = debug;


/***/ }),

/***/ "./src/utils/menu.ts":
/*!***************************!*\
  !*** ./src/utils/menu.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processMenuItems = void 0;
// This is a "band-aid" function to work around bogus TypeScript compiler errors
// when webpack is live-reloading
//
// https://github.com/jumpinjackie/mapguide-react-layout/issues/61
/**
 * @hidden
 */
function processMenuItems(items) {
    var processed = [];
    if (items != null) {
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
            var i = items_1[_i];
            if (i != null) {
                processed.push(i);
            }
        }
    }
    return processed;
}
exports.processMenuItems = processMenuItems;


/***/ }),

/***/ "./src/utils/never.ts":
/*!****************************!*\
  !*** ./src/utils/never.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertNever = void 0;
/**
 * Asserts that this function should never be called. The common usage is to call this as the
 * "else" case in a series of if/else blocks or the default case in a switch statement when
 * testing cases of an enum or union type. This is a compile-time way to ensure that your code properly
 * tests for all possible cases of a given enum or union type
 *
 * @export
 * @param {never} value
 */
function assertNever(value) {
    throw new Error("Should never get here");
}
exports.assertNever = assertNever;


/***/ }),

/***/ "./src/utils/number.ts":
/*!*****************************!*\
  !*** ./src/utils/number.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.roundTo = exports.sum = exports.rad2deg = exports.deg2rad = exports.getFiniteScaleIndexForScale = exports.getClosestScaleIndex = exports.scaleRangeBetween = exports.areNumbersEqual = exports.restrictToRange = void 0;
var SHIM_EPSILON = Math.pow(2, -52);
function epsilon() {
    var num = Number;
    return num.EPSILON || SHIM_EPSILON;
}
/**
 * Restricts the given number to the given range
 *
 * @export
 * @param {number} val
 * @param {number} lower
 * @param {number} upper
 */
function restrictToRange(val, lower, upper) {
    return Math.min(Math.max(val, lower), upper);
}
exports.restrictToRange = restrictToRange;
/**
 * Indicates if the given numbers are equal
 *
 * @export
 * @param {number} a
 * @param {number} b
 * @returns {boolean}
 */
function areNumbersEqual(a, b) {
    return Math.abs(a - b) < epsilon();
}
exports.areNumbersEqual = areNumbersEqual;
/**
 * Indicates if the given scale is within the specified range
 *
 * @export
 * @param {number} scale
 * @param {number} minScale
 * @param {number} maxScale
 * @returns {boolean}
 */
function scaleRangeBetween(scale, minScale, maxScale) {
    //Note the '<'. This is the same range check used in MapGuide Server
    return scale >= minScale && scale < maxScale;
}
exports.scaleRangeBetween = scaleRangeBetween;
/**
 * Gets the closest scale index for the given scale and scale array pair
 *
 * @export
 * @param {[number, number]} scales
 * @param {number} scale
 * @returns {number}
 */
function getClosestScaleIndex(scales, scale) {
    var d1 = Math.abs(scales[0] - scale);
    var d2 = Math.abs(scales[1] - scale);
    if (d1 < d2)
        return 0;
    else
        return 1;
}
exports.getClosestScaleIndex = getClosestScaleIndex;
/**
 * Gets the applicable finite scale index for the given scale and finite scale array
 *
 * @export
 * @param {number[]} finiteScaleList
 * @param {number} scale
 * @returns {number}
 */
function getFiniteScaleIndexForScale(finiteScaleList, scale) {
    for (var i = 0; i < finiteScaleList.length; i++) {
        if (scale >= finiteScaleList[i]) { //Found the lower bound
            if ((i + 1) < finiteScaleList.length) { //There is a possible upper bound
                if (scale <= finiteScaleList[i + 1]) { //It is the upper bound
                    var test_1 = [finiteScaleList[i], finiteScaleList[i + 1]];
                    //Snap to the scale with lowest difference
                    var testIndex = getClosestScaleIndex(test_1, scale);
                    if (testIndex == 0) {
                        return i;
                    }
                    else {
                        return i + 1;
                    }
                }
            }
            else { //There is no upper bound (we're at the end), snap to it
                return i;
            }
        }
        else if (scale <= finiteScaleList[i]) {
            if (i > 0) {
                var test_2 = [finiteScaleList[i - 1], finiteScaleList[i]];
                var testIndex = getClosestScaleIndex(test_2, scale);
                if (testIndex == 0) {
                    return i - 1;
                }
                else {
                    return i;
                }
            }
            else {
                return i;
            }
        }
    }
    return 0;
}
exports.getFiniteScaleIndexForScale = getFiniteScaleIndexForScale;
/**
 * Converts the given angle in degrees to radians
 * @param deg The angle in degrees
 */
function deg2rad(deg) {
    return deg * (Math.PI / 180);
}
exports.deg2rad = deg2rad;
/**
 * Converts the given angle in radians to degrees
 * @param radians
 * @since 0.13
 */
function rad2deg(radians) {
    return radians * (180 / Math.PI);
}
exports.rad2deg = rad2deg;
/**
 * Computes the sum of the given array
 *
 * @since 0.11
 * @export
 * @template T
 * @param {T[]} array
 * @param {(item: T) => number} numSelector
 * @returns {number}
 */
function sum(array, numSelector) {
    var total = 0;
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var item = array_1[_i];
        total += numSelector(item);
    }
    return total;
}
exports.sum = sum;
/**
 * Rounds the given number to the specified number of decimals
 *
 * @since 0.11
 * @export
 * @param {number} num
 * @param {number} [decimals=2]
 * @returns {number}
 */
function roundTo(num, decimals) {
    if (decimals === void 0) { decimals = 2; }
    var a = Math.pow(10, decimals);
    return Math.round(num * a) / a;
}
exports.roundTo = roundTo;


/***/ }),

/***/ "./src/utils/site-version.ts":
/*!***********************************!*\
  !*** ./src/utils/site-version.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.canUseQueryMapFeaturesV4 = exports.getSiteVersion = void 0;
/**
 * Gets the MapGuide site version from the runtime map response
 * @param map
 * @since 0.12
 */
function getSiteVersion(map) {
    var _a = map.SiteVersion.split("."), sMaj = _a[0], sMin = _a[1], sPatch = _a[2], sRev = _a[3];
    var vMaj = parseInt(sMaj, 10);
    var vMin = parseInt(sMin, 10);
    var vPatch = parseInt(sPatch, 10);
    var vRev = parseInt(sRev, 10);
    return [vMaj, vMin, vPatch, vRev];
}
exports.getSiteVersion = getSiteVersion;
/**
 * Tests if QUERYMAPFEATURES 4.0.0 API can be used with this version of MapGuide
 * @param version The site version
 * @since 0.12.1
 */
function canUseQueryMapFeaturesV4(version) {
    var vMaj = version[0], vMin = version[1], vPatch = version[2], vRev = version[3];
    if (vMaj >= 4) {
        //Allow a 4.0 trunk/branch build
        if (vMaj == 4 && vMin == 0 && vPatch == 0 && vRev == 0) {
            return true;
        }
        //Test for > 4.0 preview 1
        if (vMaj == 4 && vMin == 0 && vPatch == 0) {
            return vRev > 9592; //This is the rev of preview 1
        }
        return true;
    }
    return false;
}
exports.canUseQueryMapFeaturesV4 = canUseQueryMapFeaturesV4;


/***/ }),

/***/ "./src/utils/string.ts":
/*!*****************************!*\
  !*** ./src/utils/string.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isResourceId = exports.extractPlaceholderTokens = exports.strTrim = exports.strIsNullOrEmpty = exports.STR_EMPTY = exports.strReplaceAll = exports.strStartsWith = exports.strEndsWith = void 0;
/**
 * Indicates if the given string ends with the given suffix
 *
 * @export
 * @param {string} str
 * @param {string} suffix
 * @returns {boolean}
 */
function strEndsWith(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
}
exports.strEndsWith = strEndsWith;
/**
 * Indicates if the given string starts with the given string
 *
 * @param {string} str
 * @param {string} word
 * @returns {boolean}
 * @since 0.14
 */
function strStartsWith(str, word) {
    return str.lastIndexOf(word, 0) === 0;
}
exports.strStartsWith = strStartsWith;
/**
 * Replaces all occurrences of the given string with the specified replacement in the target
 * string
 *
 * @param str
 * @param find
 * @param replace
 * @since 0.12
 */
function strReplaceAll(str, find, replace) {
    return str.split(find).join(replace);
}
exports.strReplaceAll = strReplaceAll;
/**
 * Empty string constant
 */
exports.STR_EMPTY = "";
/**
 * Indicates if the given string is null or empty
 *
 * @export
 * @param {(string | null | undefined)} str
 * @returns {boolean}
 */
function strIsNullOrEmpty(str) {
    return null == str || "" === str;
}
exports.strIsNullOrEmpty = strIsNullOrEmpty;
/**
 * Returns a trimmed version of the given string
 *
 * @param str The string to trim
 * @since 0.12.5
 */
function strTrim(str) {
    if (!String.prototype.trim) {
        return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
    }
    return str.trim();
}
exports.strTrim = strTrim;
/**
 *
 *
 * @export
 * @param {string} expr
 * @param {string} delimBegin
 * @param {string} delimEnd
 * @returns
 * @since 0.14
 */
function extractPlaceholderTokens(expr, delimBegin, delimEnd) {
    var _a;
    var regex = new RegExp(delimBegin + "(.*?)" + delimEnd, "g");
    var matches = expr.match(regex);
    return (_a = matches === null || matches === void 0 ? void 0 : matches.map(function (m) { return m.replace(delimBegin, "").replace(delimEnd, ""); })) !== null && _a !== void 0 ? _a : [];
}
exports.extractPlaceholderTokens = extractPlaceholderTokens;
/**
 * Gets whether the given string is a resource identifier
 *
 * @param str The string to test
 * @since 0.14
 */
function isResourceId(str) {
    return strStartsWith(str, "Library://");
}
exports.isResourceId = isResourceId;


/***/ }),

/***/ "./src/utils/type-guards.ts":
/*!**********************************!*\
  !*** ./src/utils/type-guards.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isRuntimeMap = exports.isAction = exports.isCoordinate = exports.isMapView = exports.isLayer = exports.isMenu = exports.isComponentFlyout = exports.isMenuRef = exports.isInitError = exports.isError = exports.isModalComponentDisplayOptions = exports.isModalDisplayOptions = void 0;
/**
 * Indicates if the given argument is an IModalDisplayOptions
 *
 * @export
 * @param {*} arg
 * @returns {arg is IModalDisplayOptions}
 */
function isModalDisplayOptions(arg) {
    return typeof (arg.url) != 'undefined';
}
exports.isModalDisplayOptions = isModalDisplayOptions;
/**
 * Indicates if the given argument is an IModalComponentDisplayOptions
 *
 * @export
 * @param {*} arg
 * @returns {arg is IModalComponentDisplayOptions}
 */
function isModalComponentDisplayOptions(arg) {
    return typeof (arg.component) != 'undefined';
}
exports.isModalComponentDisplayOptions = isModalComponentDisplayOptions;
/**
 * Indicates if the given argument is an Error object
 *
 * @export
 * @param {*} err
 * @returns {err is Error}
 */
function isError(err) {
    return err instanceof Error;
}
exports.isError = isError;
/**
 * Indicates if the given argument is an InitError object
 *
 * @export
 * @param {*} item
 * @returns {item is InitError}
 */
function isInitError(item) {
    return typeof (item.message) != 'undefined' && typeof (item.stack) != undefined;
}
exports.isInitError = isInitError;
/**
 * Indicates if the given arguemnt has the shape of an IFlyoutMenu
 *
 * @export
 * @param {*} item
 * @returns {item is IFlyoutMenu}
 */
function isMenuRef(item) {
    return typeof (item.flyoutId) != 'undefined';
}
exports.isMenuRef = isMenuRef;
/**
 * Indicates if the given argument has the shape of an IComponentFlyoutItem
 *
 * @export
 * @param {*} item
 * @returns {item is IComponentFlyoutItem}
 */
function isComponentFlyout(item) {
    return typeof (item.componentName) != 'undefined';
}
exports.isComponentFlyout = isComponentFlyout;
/**
 * Indicates if the given argument has the shape of an IInlineMenu
 *
 * @export
 * @param {*} item
 * @returns {item is IInlineMenu}
 */
function isMenu(item) {
    return typeof (item.childItems) != 'undefined';
}
exports.isMenu = isMenu;
/**
 * Indicates if the given argument is a MapLayer object
 *
 * @export
 * @param {*} layer
 * @returns {layer is MapLayer}
 */
function isLayer(layer) {
    return layer.LayerDefinition !== undefined;
}
exports.isLayer = isLayer;
/**
 * Indicates if the given argument has the shape of an IMapView
 *
 * @export
 * @param {*} view
 * @returns {view is IMapView}
 */
function isMapView(view) {
    return typeof (view.x) == 'number'
        && typeof (view.y) == 'number'
        && typeof (view.scale) == 'number';
}
exports.isMapView = isMapView;
/**
 * Indicates if the given argument is a coordinate pair
 *
 * @export
 * @param {*} coord
 * @returns {coord is [number, number]}
 */
function isCoordinate(coord) {
    return coord instanceof Array
        && coord.length == 2
        && typeof (coord[0]) == 'number'
        && typeof (coord[1]) == 'number';
}
exports.isCoordinate = isCoordinate;
/**
 * Indicates if the given argument has the shape of a ViewerAction
 *
 * @export
 * @param {*} action
 * @returns {action is ViewerAction}
 */
function isAction(action) {
    return typeof (action.type) != 'undefined'
        && typeof (action.payload) != 'undefined';
}
exports.isAction = isAction;
/**
 * Indicates if the given argument is a RuntimeMap
 *
 * @param arg
 * @returns
 * @since 0.14
 */
function isRuntimeMap(arg) {
    return arg.Extents != null
        && arg.BackgroundColor != null
        && arg.CoordinateSystem != null
        && arg.MapDefinition != null
        && arg.DisplayDpi != null;
}
exports.isRuntimeMap = isRuntimeMap;


/***/ }),

/***/ "./src/utils/units.tsx":
/*!*****************************!*\
  !*** ./src/utils/units.tsx ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tryParseArbitraryCs = exports.getMapSize = exports.getUnitOfMeasure = exports.getUnits = exports.getUnitsOfMeasure = void 0;
var i18n_1 = __webpack_require__(/*! ../api/i18n */ "./src/api/i18n.ts");
var common_1 = __webpack_require__(/*! ../api/common */ "./src/api/common.ts");
var string_1 = __webpack_require__(/*! ./string */ "./src/utils/string.ts");
var mUnits = [
    { name: "Unknown", localizedName: function (locale) { return (0, i18n_1.tr)("UNIT_UNKNOWN", locale); }, abbreviation: function (locale) { return (0, i18n_1.tr)("UNIT_ABBR_UNKNOWN", locale); }, unitsPerMeter: 1.0, metersPerUnit: 1.0 },
    { name: "Inches", localizedName: function (locale) { return (0, i18n_1.tr)("UNIT_INCHES", locale); }, abbreviation: function (locale) { return (0, i18n_1.tr)("UNIT_ABBR_INCHES", locale); }, unitsPerMeter: 39.370079, metersPerUnit: 0.0254 },
    { name: "Feet", localizedName: function (locale) { return (0, i18n_1.tr)("UNIT_FEET", locale); }, abbreviation: function (locale) { return (0, i18n_1.tr)("UNIT_ABBR_FEET", locale); }, unitsPerMeter: 3.2808, metersPerUnit: 0.3048 },
    { name: "Yards", localizedName: function (locale) { return (0, i18n_1.tr)("UNIT_YARDS", locale); }, abbreviation: function (locale) { return (0, i18n_1.tr)("UNIT_ABBR_YARDS", locale); }, unitsPerMeter: 1.0936133, metersPerUnit: 0.9144 },
    { name: "Miles", localizedName: function (locale) { return (0, i18n_1.tr)("UNIT_MILES", locale); }, abbreviation: function (locale) { return (0, i18n_1.tr)("UNIT_ABBR_MILES", locale); }, unitsPerMeter: 0.00062137, metersPerUnit: 1609.344 },
    { name: "Nautical Miles", localizedName: function (locale) { return (0, i18n_1.tr)("UNIT_NAUT_MILES", locale); }, abbreviation: function (locale) { return (0, i18n_1.tr)("UNIT_ABBR_NAUT_MILES", locale); }, unitsPerMeter: 0.000539956803, metersPerUnit: 1852 },
    { name: "Millimeters", localizedName: function (locale) { return (0, i18n_1.tr)("UNIT_MILLIMETERS", locale); }, abbreviation: function (locale) { return (0, i18n_1.tr)("UNIT_ABBR_MILLIMETERS", locale); }, unitsPerMeter: 1000.0, metersPerUnit: 0.001 },
    { name: "Centimeters", localizedName: function (locale) { return (0, i18n_1.tr)("UNIT_CENTIMETERS", locale); }, abbreviation: function (locale) { return (0, i18n_1.tr)("UNIT_ABBR_CENTIMETERS", locale); }, unitsPerMeter: 100.0, metersPerUnit: 0.01 },
    { name: "Meters", localizedName: function (locale) { return (0, i18n_1.tr)("UNIT_METERS", locale); }, abbreviation: function (locale) { return (0, i18n_1.tr)("UNIT_ABBR_METERS", locale); }, unitsPerMeter: 1.0, metersPerUnit: 1.0 },
    { name: "Kilometers", localizedName: function (locale) { return (0, i18n_1.tr)("UNIT_KILOMETERS", locale); }, abbreviation: function (locale) { return (0, i18n_1.tr)("UNIT_ABBR_KILOMETERS", locale); }, unitsPerMeter: 0.001, metersPerUnit: 1000.0 },
    { name: "Degrees", localizedName: function (locale) { return (0, i18n_1.tr)("UNIT_DEGREES", locale); }, abbreviation: function (locale) { return (0, i18n_1.tr)("UNIT_ABBR_DEGREES", locale); }, unitsPerMeter: 0.000009044, metersPerUnit: 111061.75033 },
    { name: "Decimal Degrees", localizedName: function (locale) { return (0, i18n_1.tr)("UNIT_DEC_DEGREES", locale); }, abbreviation: function (locale) { return (0, i18n_1.tr)("UNIT_ABBR_DEC_DEGREES", locale); }, unitsPerMeter: 0.000009044, metersPerUnit: 111061.75033 },
    { name: "Degrees Minutes Seconds", localizedName: function (locale) { return (0, i18n_1.tr)("UNIT_DMS", locale); }, abbreviation: function (locale) { return (0, i18n_1.tr)("UNIT_ABBR_DMS", locale); }, unitsPerMeter: 0.000009044, metersPerUnit: 111061.75033 },
    { name: "Pixels", localizedName: function (locale) { return (0, i18n_1.tr)("UNIT_PIXELS", locale); }, abbreviation: function (locale) { return (0, i18n_1.tr)("UNIT_ABBR_PIXELS", locale); }, unitsPerMeter: 1.0, metersPerUnit: 1.0 }
];
/**
 * Gets all available units of measure
 * @since 0.12.2
 */
function getUnitsOfMeasure() {
    return [
        common_1.UnitOfMeasure.Centimeters,
        common_1.UnitOfMeasure.DecimalDegrees,
        common_1.UnitOfMeasure.Degrees,
        common_1.UnitOfMeasure.DMS,
        common_1.UnitOfMeasure.Feet,
        common_1.UnitOfMeasure.Inches,
        common_1.UnitOfMeasure.Kilometers,
        common_1.UnitOfMeasure.Meters,
        common_1.UnitOfMeasure.Miles,
        common_1.UnitOfMeasure.Millimeters,
        common_1.UnitOfMeasure.NauticalMiles,
        common_1.UnitOfMeasure.Pixels,
        common_1.UnitOfMeasure.Unknown,
        common_1.UnitOfMeasure.Yards
    ];
}
exports.getUnitsOfMeasure = getUnitsOfMeasure;
/**
 * @deprecated Use getUnitsOfMeasure() instead
 */
function getUnits() {
    return [
        [common_1.UnitOfMeasure.Centimeters, "Centimeters"],
        [common_1.UnitOfMeasure.DecimalDegrees, "Decimal Degrees"],
        [common_1.UnitOfMeasure.Degrees, "Degrees"],
        [common_1.UnitOfMeasure.DMS, "Degrees Minutes Seconds"],
        [common_1.UnitOfMeasure.Feet, "Feet"],
        [common_1.UnitOfMeasure.Inches, "Inches"],
        [common_1.UnitOfMeasure.Kilometers, "Kilometers"],
        [common_1.UnitOfMeasure.Meters, "Meters"],
        [common_1.UnitOfMeasure.Miles, "Miles"],
        [common_1.UnitOfMeasure.Millimeters, "Millimeters"],
        [common_1.UnitOfMeasure.NauticalMiles, "Nautical Miles"],
        [common_1.UnitOfMeasure.Pixels, "Pixels"],
        [common_1.UnitOfMeasure.Unknown, "Unknown"],
        [common_1.UnitOfMeasure.Yards, "Yards"]
    ];
}
exports.getUnits = getUnits;
function getUnitOfMeasure(unit) {
    var u = mUnits[unit];
    return u || mUnits[0]; //The unknown unit
}
exports.getUnitOfMeasure = getUnitOfMeasure;
/**
 * Utility function to compute the physical map size based on the given display size and various display settings
 *
 * @since 0.11
 * @export
 * @param {[number, number]} displaySize
 * @param {number} metersPerUnit
 * @param {UnitOfMeasure} units
 * @param {number} [resolution]
 * @param {number} [precision]
 * @returns {[number, number]}
 */
function getMapSize(displaySize, metersPerUnit, units, resolution, precision) {
    var width = displaySize[0], height = displaySize[1];
    var gw = width;
    var gh = height;
    var uom = getUnitOfMeasure(units);
    if (resolution && units != common_1.UnitOfMeasure.Pixels) {
        gw = resolution * width;
        gh = resolution * height;
        if (units != common_1.UnitOfMeasure.Unknown) {
            gw = uom.unitsPerMeter * gw * metersPerUnit;
            gh = uom.unitsPerMeter * gh * metersPerUnit;
        }
        var prec = precision || 2;
        if (prec >= 0) {
            var factor = Math.pow(10, prec);
            gw = Math.round(gw * factor) / factor;
            gh = Math.round(gh * factor) / factor;
        }
    }
    return [gw, gh];
}
exports.getMapSize = getMapSize;
/**
 * Attempts to be parse unit information for the given mentor CS code
 *
 * @param csCode
 * @since 0.14.3
 * @returns
 */
function tryParseArbitraryCs(csCode) {
    if (!(0, string_1.strIsNullOrEmpty)(csCode) && (0, string_1.strStartsWith)(csCode, "XY-")) {
        // We'll only cover arbitrary CSes that are clearly mappable to our UOM set
        var suffix = csCode.substring(3);
        switch (suffix) {
            case "M":
                return { code: csCode, units: common_1.UnitOfMeasure.Meters };
            case "FT":
                return { code: csCode, units: common_1.UnitOfMeasure.Feet };
            case "IN":
                return { code: csCode, units: common_1.UnitOfMeasure.Inches };
            case "CM":
                return { code: csCode, units: common_1.UnitOfMeasure.Centimeters };
            case "KM":
                return { code: csCode, units: common_1.UnitOfMeasure.Kilometers };
            case "YD":
                return { code: csCode, units: common_1.UnitOfMeasure.Yards };
            case "MM":
                return { code: csCode, units: common_1.UnitOfMeasure.Millimeters };
            case "MI":
                return { code: csCode, units: common_1.UnitOfMeasure.Miles };
            case "NM":
                return { code: csCode, units: common_1.UnitOfMeasure.NauticalMiles };
            case "PX": //Not supported by MapGuide, but our own defn to support static images
                return { code: csCode, units: common_1.UnitOfMeasure.Pixels };
        }
    }
    return undefined;
}
exports.tryParseArbitraryCs = tryParseArbitraryCs;


/***/ }),

/***/ "./src/utils/url.ts":
/*!**************************!*\
  !*** ./src/utils/url.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseUrlParameters = exports.appendParameters = exports.stringifyQuery = exports.parseUrl = exports.ensureParameters = exports.parseComponentUri = exports.isComponentUri = exports.areUrlsSame = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var qs_1 = (0, tslib_1.__importDefault)(__webpack_require__(/*! qs */ "./node_modules/qs/lib/index.js"));
var string_1 = __webpack_require__(/*! ./string */ "./src/utils/string.ts");
var parse = __webpack_require__(/*! url-parse */ "./node_modules/url-parse/index.js");
var DEFAULT_PARSE_OPTIONS = { ignoreQueryPrefix: true };
/**
 * Indicates if the given arrays are equal
 *
 * @param {(string[]|null)} a
 * @param {(string[]|null)} b
 * @returns {boolean}
 */
function arraysEqual(a, b) {
    if (a === b)
        return true;
    if (a == null || b == null)
        return false;
    if (a.length != b.length)
        return false;
    // If you don't care about the order of the elements inside
    // the array, you should sort both arrays here.
    for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Indicates if the given sets of parameterse are the same
 *
 * @param {*} params1
 * @param {*} params2
 * @returns {boolean}
 */
function areParamsEqual(params1, params2) {
    //HACK: locale is an optional part of the mapname/session/locale triplet
    //For the purpose of the same url test, the presence (or lack thereof) of
    //this parameter should not break the url equality test
    var keys1 = Object.keys(params1).filter(function (k) { return k.toLowerCase() != "locale"; }).sort();
    var keys2 = Object.keys(params2).filter(function (k) { return k.toLowerCase() != "locale"; }).sort();
    if (arraysEqual(keys1, keys2)) {
        for (var _i = 0, keys1_1 = keys1; _i < keys1_1.length; _i++) {
            var key = keys1_1[_i];
            if (params1[key] != params2[key]) {
                return false;
            }
        }
        return true;
    }
    return false;
}
/**
 * Indicates if the given URLs are the same
 *
 * @export
 * @param {string} url1
 * @param {string} url2
 * @returns {boolean}
 */
function areUrlsSame(url1, url2) {
    var parsed1 = parse(url1);
    var parsed2 = parse(url2);
    var params1 = qs_1.default.parse(parsed1.query, DEFAULT_PARSE_OPTIONS);
    var params2 = qs_1.default.parse(parsed2.query, DEFAULT_PARSE_OPTIONS);
    var same = parsed1.protocol == parsed2.protocol
        && parsed1.slashes == parsed2.slashes
        && parsed1.auth == parsed2.auth
        && parsed1.username == parsed2.username
        && parsed1.password == parsed2.password
        && parsed1.host == parsed2.host
        && parsed1.hostname == parsed2.hostname
        && parsed1.port == parsed2.port
        && parsed1.pathname == parsed2.pathname
        && parsed1.hash == parsed2.hash
        && parsed1.host == parsed2.host
        && areParamsEqual(params1, params2);
    return same;
}
exports.areUrlsSame = areUrlsSame;
/**
 * Indicates if the given URI is a component URI
 *
 * @export
 * @param {string} uri
 * @returns {boolean}
 */
function isComponentUri(uri) {
    return uri.indexOf("component://") >= 0;
}
exports.isComponentUri = isComponentUri;
/**
 * Parses the given component URI. If it not a valid component URI returns undefined
 *
 * @export
 * @param {string} uri
 * @returns {(ParsedComponentUri | undefined)}
 */
function parseComponentUri(uri) {
    if (isComponentUri(uri)) {
        var qi = uri.lastIndexOf("?");
        var name_1 = qi < 0 ? uri.substring(12) : uri.substring(12, qi);
        var props = qi < 0 ? {} : qs_1.default.parse(uri.substring(qi), DEFAULT_PARSE_OPTIONS);
        return {
            name: name_1,
            props: props
        };
    }
}
exports.parseComponentUri = parseComponentUri;
/**
 * Normalizes the given URL to ensure it has the baseline set of required parameters for invoking any server-side script that uses the MapGuide Web API
 *
 * @export
 * @param {string} url The url to normalize
 * @param {(string | undefined)} mapName The name of the current runtime map
 * @param {(string | undefined)} session The current session id
 * @param {string} [locale] An optional locale
 * @param {boolean} [uppercase=true] If true, will uppercase all parameter names
 * @param {IInvokeUrlCommandParameter[]} [extraParameters=[]] Any extra parameters to append to the URL
 * @returns {string}
 */
function ensureParameters(url, mapName, session, locale, uppercase, extraParameters) {
    if (uppercase === void 0) { uppercase = true; }
    if (extraParameters === void 0) { extraParameters = []; }
    //If this is a component URL, let it be
    if (isComponentUri(url)) {
        return url;
    }
    var parsed = parseUrl(url);
    var params = parsed.query != null ? qs_1.default.parse(parsed.query, DEFAULT_PARSE_OPTIONS) : {};
    var bNeedMapName = true;
    var bNeedSession = true;
    var bNeedLocale = true;
    for (var key in params) {
        var name_2 = key.toLowerCase();
        switch (name_2) {
            case "session":
                bNeedSession = false;
                break;
            case "mapname":
                bNeedMapName = false;
                break;
            case "locale":
                bNeedLocale = false;
                break;
        }
    }
    if (bNeedMapName && !(0, string_1.strIsNullOrEmpty)(mapName)) {
        if (uppercase) {
            params.MAPNAME = mapName;
        }
        else {
            params.mapname = mapName;
        }
    }
    if (bNeedSession && !(0, string_1.strIsNullOrEmpty)(session)) {
        if (uppercase) {
            params.SESSION = session;
        }
        else {
            params.session = session;
        }
    }
    if (bNeedLocale) {
        if (uppercase) {
            params.LOCALE = locale;
        }
        else {
            params.locale = locale;
        }
    }
    for (var _i = 0, extraParameters_1 = extraParameters; _i < extraParameters_1.length; _i++) {
        var p = extraParameters_1[_i];
        params[p.name] = p.value;
    }
    /*
    parsed.query = queryString.stringify(params);
    const result = parsed.toString();

    if (url.indexOf(parsed.protocol) >= 0 || url.indexOf("/") == 0) {
        return result;
    }

    return result;
    */
    //Don't uppercase the parameters here if true, uppercasing is only for filling in
    //missing parameters
    return appendParameters(url, params, true, false /*uppercase*/);
}
exports.ensureParameters = ensureParameters;
/**
 * Parses the given URL and separates out the query string parameters
 *
 * @export
 * @param {string} url The URL to parse
 * @returns {IParsedUrl}
 * @since 0.12
 */
function parseUrl(url) {
    //return queryString.parseUrl(url);
    var qi = url.lastIndexOf("?");
    var parsedUrl = qi < 0 ? url : url.substring(0, qi);
    var query = qi < 0 ? {} : qs_1.default.parse(url.substring(qi), DEFAULT_PARSE_OPTIONS);
    return {
        url: parsedUrl,
        query: query
    };
}
exports.parseUrl = parseUrl;
/**
 * Converts the given object to a query string fragment
 *
 * @export
 * @param {*} parameters The object to stringify
 * @returns {string} The query string fragment
 */
function stringifyQuery(parameters) {
    return qs_1.default.stringify(parameters);
}
exports.stringifyQuery = stringifyQuery;
/**
 * Appends the specified parameters to the given URL
 *
 * @export
 * @param {string} url The URL to append parameters to
 * @param {*} parameters The parameters to append
 * @param {boolean} [bOverwriteExisting=true] If true, will overwrite any existing parameters if the URL already has them
 * @param {boolean} [bConvertToUppercase=false] If true, will ensure all parameter names are uppercase
 * @param {boolean} [bDiscardExistingParams=false] If true, will discard existing query string params before appending
 * @since 0.12
 */
function appendParameters(url, parameters, bOverwriteExisting, bConvertToUppercase, bDiscardExistingParams) {
    if (bOverwriteExisting === void 0) { bOverwriteExisting = true; }
    if (bConvertToUppercase === void 0) { bConvertToUppercase = false; }
    if (bDiscardExistingParams === void 0) { bDiscardExistingParams = false; }
    var parsed = parse(url);
    var currentParams;
    if (!bDiscardExistingParams) {
        currentParams = parsed.query != null ? qs_1.default.parse(parsed.query, DEFAULT_PARSE_OPTIONS) : {};
    }
    else {
        currentParams = {};
    }
    var paramNames = {};
    for (var key in currentParams) {
        paramNames[key.toUpperCase()] = key;
    }
    for (var name_3 in parameters) {
        //See if this parameter name was normalized
        var key = paramNames[name_3.toUpperCase()] || name_3;
        //If it was and we've got an existing value there, skip if not overwriting
        if (key && currentParams[key] && !bOverwriteExisting) {
            continue;
        }
        //Put the parameter value
        currentParams[key] = parameters[name_3];
    }
    if (bConvertToUppercase) {
        var params2 = {};
        for (var name_4 in currentParams) {
            params2[name_4.toUpperCase()] = currentParams[name_4];
        }
        currentParams = params2;
    }
    parsed.query = qs_1.default.stringify(currentParams);
    var result = parsed.toString();
    if (url.indexOf(parsed.protocol) >= 0 || url.indexOf("/") == 0) {
        return result;
    }
    return result;
}
exports.appendParameters = appendParameters;
/**
 * Parses the query string section of the given URL and returns the parsed
 * parameters as an object
 * @param url The URL to parse
 * @since 0.13
 */
function parseUrlParameters(url) {
    var parsed = parse(url);
    var currentParams = parsed.query != null ? qs_1.default.parse(parsed.query, DEFAULT_PARSE_OPTIONS) : {};
    return currentParams;
}
exports.parseUrlParameters = parseUrlParameters;


/***/ }),

/***/ "./src/utils/viewer-state.ts":
/*!***********************************!*\
  !*** ./src/utils/viewer-state.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.layerTransparencyChanged = exports.areMapsSame = exports.areViewsCloseToEqual = void 0;
var number_1 = __webpack_require__(/*! ./number */ "./src/utils/number.ts");
var array_1 = __webpack_require__(/*! ./array */ "./src/utils/array.ts");
/**
 * Determines if the given IMapView instances are equal or close to it
 *
 * @export
 * @param {(IMapView | undefined)} view
 * @param {(IMapView | undefined)} otherView
 * @returns {boolean}
 */
function areViewsCloseToEqual(view, otherView) {
    if (view && otherView) {
        var basePartsEqual = (0, number_1.areNumbersEqual)(view.x, otherView.x) &&
            (0, number_1.areNumbersEqual)(view.y, otherView.y) &&
            (0, number_1.areNumbersEqual)(view.scale, otherView.scale);
        if (view.resolution != null && otherView.resolution != null) {
            return basePartsEqual && (0, number_1.areNumbersEqual)(view.resolution, otherView.resolution);
        }
        else {
            if ((view.resolution == null && otherView.resolution != null) || (view.resolution != null && otherView.resolution == null)) {
                return false;
            }
            else {
                return basePartsEqual;
            }
        }
    }
    else {
        return false;
    }
}
exports.areViewsCloseToEqual = areViewsCloseToEqual;
/**
 * Indicates if the given runtime map instances are the same or have the same name
 *
 * @export
 * @param {RuntimeMap} map
 * @param {RuntimeMap} other
 * @returns {boolean}
 */
function areMapsSame(map, other) {
    if (map != other) {
        return map.Name == other.Name;
    }
    return true;
}
exports.areMapsSame = areMapsSame;
/**
 * Indicates if the given layer transparency sets are different
 * @param set
 * @param other
 */
function layerTransparencyChanged(set, other) {
    if ((!set && other) || (set && !other)) {
        return true;
    }
    var s = set !== null && set !== void 0 ? set : {};
    var o = other !== null && other !== void 0 ? other : {};
    var setLayers = Object.keys(s);
    var otherLayers = Object.keys(o);
    if ((0, array_1.areArraysDifferent)(setLayers, otherLayers))
        return true;
    for (var _i = 0, setLayers_1 = setLayers; _i < setLayers_1.length; _i++) {
        var name_1 = setLayers_1[_i];
        if (s[name_1] != o[name_1]) {
            return true;
        }
    }
    return false;
}
exports.layerTransparencyChanged = layerTransparencyChanged;


/***/ }),

/***/ "./stdassets/bp-icons.js":
/*!*******************************!*\
  !*** ./stdassets/bp-icons.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IconSvgPaths16": function() { return /* binding */ IconSvgPaths16; },
/* harmony export */   "IconSvgPaths20": function() { return /* binding */ IconSvgPaths20; }
/* harmony export */ });
/**
 * bp-icons.js
 * 
 * A verbatim subset of the Blueprint.js SVG icon set that we actually use
 * 
 * All usages of the BP icon set will be replaced with this via 
 * NormalModuleReplacementPlugin in the webpack config
 * 
 * When adding icons, copy the relevant icon path definitions from
 * node_modules/@blueprintjs/icons/src/generated/iconSvgPaths.ts
 */

//TODO/FIXME: This module is not used directly by sources, so changes to
//this file does not trigger a webpack rebuild. If making changes, you'll
//have to stop webpack and restart it again.

const IconSvgPaths16 = {
    "arrow-left": ["M13.99 6.99H4.41L7.7 3.7a1.003 1.003 0 00-1.42-1.42l-5 5a1.014 1.014 0 000 1.42l5 5a1.003 1.003 0 001.42-1.42L4.41 8.99H14c.55 0 1-.45 1-1s-.46-1-1.01-1z"],
    "arrow-right": ["M14.7 7.29l-5-5a.965.965 0 00-.71-.3 1.003 1.003 0 00-.71 1.71l3.29 3.29H1.99c-.55 0-1 .45-1 1s.45 1 1 1h9.59l-3.29 3.29a1.003 1.003 0 001.42 1.42l5-5c.18-.18.29-.43.29-.71s-.12-.52-.3-.7z"],
    "arrows-horizontal": ["M15.7 7.3l-4-4c-.2-.2-.4-.3-.7-.3-.6 0-1 .5-1 1 0 .3.1.5.3.7L12.6 7H3.4l2.3-2.3c.2-.2.3-.4.3-.7 0-.5-.4-1-1-1-.3 0-.5.1-.7.3l-4 4c-.2.2-.3.4-.3.7s.1.5.3.7l4 4c.2.2.4.3.7.3.6 0 1-.4 1-1 0-.3-.1-.5-.3-.7L3.4 9h9.2l-2.3 2.3c-.2.2-.3.4-.3.7 0 .6.4 1 1 1 .3 0 .5-.1.7-.3l4-4c.2-.2.3-.4.3-.7s-.1-.5-.3-.7z"],
    "application": ["M3.5 7h7c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-7c-.28 0-.5.22-.5.5s.22.5.5.5zM15 1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zm-1 12H2V5h12v8zM3.5 9h4c.28 0 .5-.22.5-.5S7.78 8 7.5 8h-4c-.28 0-.5.22-.5.5s.22.5.5.5zm0 2h5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-5c-.28 0-.5.22-.5.5s.22.5.5.5z"],
    "caret-down": ["M12 6.5c0-.28-.22-.5-.5-.5h-7a.495.495 0 00-.37.83l3.5 4c.09.1.22.17.37.17s.28-.07.37-.17l3.5-4c.08-.09.13-.2.13-.33z"],
    "caret-up": ["M11.87 9.17s.01 0 0 0l-3.5-4C8.28 5.07 8.15 5 8 5s-.28.07-.37.17l-3.5 4a.495.495 0 00.37.83h7a.495.495 0 00.37-.83z"],
    "chevron-down": ["M12 5c-.28 0-.53.11-.71.29L8 8.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42l4 4c.18.18.43.29.71.29s.53-.11.71-.29l4-4A1.003 1.003 0 0012 5z"],
    "chevron-right": ["M10.71 7.29l-4-4a1.003 1.003 0 00-1.42 1.42L8.59 8 5.3 11.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l4-4c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z"],
    "chevron-up": ["M12.71 9.29l-4-4C8.53 5.11 8.28 5 8 5s-.53.11-.71.29l-4 4a1.003 1.003 0 001.42 1.42L8 7.41l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71z"],
    "cross": ["M9.41 8l3.29-3.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L8 6.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42L6.59 8 3.3 11.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L8 9.41l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L9.41 8z"],
    "cog": ["M15.19 6.39h-1.85c-.11-.37-.27-.71-.45-1.04l1.36-1.36c.31-.31.31-.82 0-1.13l-1.13-1.13a.803.803 0 00-1.13 0l-1.36 1.36c-.33-.17-.67-.33-1.04-.44V.79c0-.44-.36-.8-.8-.8h-1.6c-.44 0-.8.36-.8.8v1.86c-.39.12-.75.28-1.1.47l-1.3-1.3c-.3-.3-.79-.3-1.09 0L1.82 2.91c-.3.3-.3.79 0 1.09l1.3 1.3c-.2.34-.36.7-.48 1.09H.79c-.44 0-.8.36-.8.8v1.6c0 .44.36.8.8.8h1.85c.11.37.27.71.45 1.04l-1.36 1.36c-.31.31-.31.82 0 1.13l1.13 1.13c.31.31.82.31 1.13 0l1.36-1.36c.33.18.67.33 1.04.44v1.86c0 .44.36.8.8.8h1.6c.44 0 .8-.36.8-.8v-1.86c.39-.12.75-.28 1.1-.47l1.3 1.3c.3.3.79.3 1.09 0l1.09-1.09c.3-.3.3-.79 0-1.09l-1.3-1.3c.19-.35.36-.71.48-1.1h1.85c.44 0 .8-.36.8-.8v-1.6a.816.816 0 00-.81-.79zm-7.2 4.6c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"],
    "comment": ["M14 1H1c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h2v3a1.003 1.003 0 001.71.71L8.41 12H14c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zM3.5 8C2.67 8 2 7.33 2 6.5S2.67 5 3.5 5 5 5.67 5 6.5 4.33 8 3.5 8zm4 0C6.67 8 6 7.33 6 6.5S6.67 5 7.5 5 9 5.67 9 6.5 8.33 8 7.5 8zm4 0c-.83 0-1.5-.67-1.5-1.5S10.67 5 11.5 5s1.5.67 1.5 1.5S12.33 8 11.5 8z"],
    "delete": ["M11.99 4.99a1.003 1.003 0 00-1.71-.71l-2.29 2.3L5.7 4.29a.965.965 0 00-.71-.3 1.003 1.003 0 00-.71 1.71l2.29 2.29-2.29 2.29A1.003 1.003 0 005.7 11.7l2.29-2.29 2.29 2.29a1.003 1.003 0 001.42-1.42L9.41 7.99 11.7 5.7c.18-.18.29-.43.29-.71zm-4-5c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.68 6-6 6z"],
    "disable": ["M7.99-.01c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm-6 8c0-3.31 2.69-6 6-6 1.3 0 2.49.42 3.47 1.12l-8.35 8.35c-.7-.98-1.12-2.17-1.12-3.47zm6 6c-1.3 0-2.49-.42-3.47-1.12l8.35-8.35c.7.98 1.12 2.17 1.12 3.47 0 3.32-2.68 6-6 6z"],
    "double-caret-vertical": ["M5 7h6a1.003 1.003 0 00.71-1.71l-3-3C8.53 2.11 8.28 2 8 2s-.53.11-.71.29l-3 3A1.003 1.003 0 005 7zm6 2H5a1.003 1.003 0 00-.71 1.71l3 3c.18.18.43.29.71.29s.53-.11.71-.29l3-3A1.003 1.003 0 0011 9z"],
    "edit": ["M3.25 10.26l2.47 2.47 6.69-6.69-2.46-2.48-6.7 6.7zM.99 14.99l3.86-1.39-2.46-2.44-1.4 3.83zm12.25-14c-.48 0-.92.2-1.24.51l-1.44 1.44 2.47 2.47 1.44-1.44c.32-.32.51-.75.51-1.24.01-.95-.77-1.74-1.74-1.74z"],
    "error": ["M7.99-.01c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm1 13h-2v-2h2v2zm0-3h-2v-7h2v7z"],
    "folder-close": ["M-.01 14c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V7h-16v7zm15-10H7.41L5.7 2.3a.965.965 0 00-.71-.3h-4c-.55 0-1 .45-1 1v3h16V5c0-.55-.45-1-1-1z"],
    "geosearch": ["M8.82 12.4h.66c.23 0 .36-.17.36-.4v-1.48l.19-.18c-.27.03-.55.06-.83.06-.28 0-.56-.03-.84-.07.02.04.05.08.07.13V12c0 .23.15.4.39.4zM6.4 15.1A5.51 5.51 0 01.9 9.6c0-.49.06-.98.18-1.43.03 0 .05-.01.08-.01h.08v.44c0 .19.17.34.36.34.03 0 .07-.01.1-.01l.71.7c.07.07.19.07.26 0s.07-.19 0-.26l-.7-.72c0-.02.03-.03.03-.05v-.11c0-.15.08-.2.23-.33h.42c.08 0 .15-.01.22-.04h.02c.02-.02.03-.02.04-.04.01-.01.01-.01.02-.01l.02-.01.9-.9c-.13-.26-.24-.52-.34-.8h-.5v-.43c0-.01.05.05.04-.08h.31c-.03-.13-.06-.26-.08-.39h-.57c.16-.12.34-.24.51-.36-.02-.23-.04-.46-.04-.7 0-.12.01-.23.02-.34A6.385 6.385 0 000 9.6C0 13.13 2.87 16 6.4 16c3.1 0 5.67-2.22 6.26-5.15l-.78-.88c-.21 2.85-2.58 5.13-5.48 5.13zm-1.7-2.93v-.28h.12c.23 0 .39-.19.39-.42v-.54s.01-.01 0-.01L3.77 9.45h-.62c-.23 0-.38.19-.38.42v1.6c0 .23.14.42.38.42h.26v1.61c0 .23.22.41.45.41s.45-.18.45-.41v-.97H4.3c.24 0 .4-.13.4-.36zm11.07-2.34l-2.94-2.94c.11-.17.21-.34.3-.52.01-.03.03-.06.04-.09.08-.18.16-.36.22-.55v-.01c.06-.19.1-.38.14-.58.01-.05.01-.09.02-.14.03-.2.05-.4.05-.61a4.4 4.4 0 00-4.4-4.4C6.77 0 4.8 1.97 4.8 4.4s1.97 4.4 4.4 4.4c.21 0 .41-.02.61-.05.04 0 .09-.01.14-.02.2-.03.39-.08.58-.14h.01c.19-.06.37-.14.55-.22.03-.01.06-.03.09-.04.18-.09.35-.19.52-.3l2.94 2.94a.8.8 0 00.57.23c.44 0 .8-.36.8-.8a.895.895 0 00-.24-.57zM9.2 7.6C7.43 7.6 6 6.17 6 4.4c0-1.77 1.43-3.2 3.2-3.2s3.2 1.43 3.2 3.2c0 1.77-1.43 3.2-3.2 3.2zm1.54 4.26v-.52c0-.09-.1-.17-.19-.17s-.19.07-.19.17v.52c0 .09.1.17.19.17s.19-.07.19-.17z"],
    "hand": ["M15 5c0-.55-.45-1-1-1-.41 0-.76.24-.91.59v.01s0 .01-.01.01L11.57 8h-.36l.78-4.84C12 3.11 12 3.05 12 3a1 1 0 00-1.99-.16v.01L9.18 8H9V1c0-.55-.45-1-1-1S7 .45 7 1v7h-.09l-.93-5.18A1 1 0 005 2c-.55 0-1 .45-1 1 0 .05 0 .11.01.16L5.26 11h-.04L2.83 7.44C2.65 7.18 2.35 7 2 7c-.55 0-1 .45-1 1 0 .17.04.33.12.47l3 5.69h.01v.01A5.002 5.002 0 0013 11v-.59l1.93-5.05c.05-.11.07-.23.07-.36z"],
    "home": ["M2 10v5c0 .55.45 1 1 1h3v-5h4v5h3c.55 0 1-.45 1-1v-5L8 4l-6 6zm13.71-2.71L14 5.59V2c0-.55-.45-1-1-1s-1 .45-1 1v1.59L8.71.29C8.53.11 8.28 0 8 0s-.53.11-.71.29l-7 7a1.003 1.003 0 001.42 1.42L8 2.41l6.29 6.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71z"],
    "info-sign": ["M8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zM7 3h2v2H7V3zm3 10H6v-1h1V7H6V6h3v6h1v1z"],
    "issue": ["M8 16A8 8 0 118 0a8 8 0 010 16zm0-2A6 6 0 108 2a6 6 0 000 12zm1-2H7v-2h2v2zm0-3H7V4h2v5z"],
    "layer": ["M16 8c0-.37-.21-.68-.51-.85l.01-.01-7-4-.01.01C8.34 3.06 8.18 3 8 3s-.34.06-.49.15l-.01-.02-7 4 .01.01C.21 7.32 0 7.63 0 8s.21.68.51.85l-.01.01 7 4 .01-.01c.15.09.31.15.49.15s.34-.06.49-.15l.01.01 7-4-.01-.01c.3-.17.51-.48.51-.85z"],
    "layers": ["M.55 4.89l7 3.5c.14.07.29.11.45.11s.31-.04.45-.11l7-3.5a.998.998 0 00-.06-1.81L8.4.08a1.006 1.006 0 00-.79 0l-6.99 3a.992.992 0 00-.07 1.81zM15 10c-.16 0-.31.04-.45.11L8 13.38 1.45 10.1c-.14-.06-.29-.1-.45-.1-.55 0-1 .45-1 1 0 .39.23.73.55.89l7 3.5c.14.07.29.11.45.11s.31-.04.45-.11l7-3.5c.32-.16.55-.5.55-.89 0-.55-.45-1-1-1zm0-3.5c-.16 0-.31.04-.45.11L8 9.88 1.45 6.61A.997.997 0 001 6.5c-.55 0-1 .45-1 1 0 .39.23.73.55.89l7 3.5c.14.07.29.11.45.11s.31-.04.45-.11l7-3.5c.32-.16.55-.5.55-.89 0-.55-.45-1-1-1z"],
    "map": ["M15.55 3.17l-4.49-3A.975.975 0 009.99.15L5.53 2.82 1.56.17A1.003 1.003 0 000 1v11c0 .35.18.65.45.83l4.49 3a.975.975 0 001.07.02l4.46-2.67 3.97 2.65A1.003 1.003 0 0016 15V4c0-.35-.18-.65-.45-.83zM5 13.46l-3-2v-8.6l2.94 1.96c.02.02.04.03.06.04v8.6zm5-2.32s-.01 0-.01.01L6 13.53V4.86s.01 0 .01-.01L10 2.47v8.67zm4 1.99l-2.94-1.96c-.02-.01-.04-.02-.05-.03v-8.6l3 2v8.59z"],
    "media": ["M11.99 6.99c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm3-5h-14c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1v-10c0-.55-.45-1-1-1zm-1 9l-5-3-1 2-3-4-3 5v-7h12v7z"],
    "menu-closed": ["M14.99 6.99h-9c-.55 0-1 .45-1 1s.45 1 1 1h9c.55 0 1-.45 1-1s-.45-1-1-1zm-12-2c-.28 0-.53.11-.71.29l-2 2a1.014 1.014 0 000 1.42l2 2a1.003 1.003 0 001.71-.71v-4c0-.55-.45-1-1-1zm3-1h9c.55 0 1-.45 1-1s-.45-1-1-1h-9c-.55 0-1 .45-1 1s.45 1 1 1zm9 8h-9c-.55 0-1 .45-1 1s.45 1 1 1h9c.55 0 1-.45 1-1s-.45-1-1-1z"],
    "menu-open": ["M9.99 11.99h-9c-.55 0-1 .45-1 1s.45 1 1 1h9c.55 0 1-.45 1-1s-.45-1-1-1zm0-5h-9c-.55 0-1 .45-1 1s.45 1 1 1h9c.55 0 1-.45 1-1s-.45-1-1-1zm0-5h-9c-.55 0-1 .45-1 1s.45 1 1 1h9c.55 0 1-.45 1-1s-.45-1-1-1zm5.71 5.3l-2-2a1.003 1.003 0 00-1.71.71v4a1.003 1.003 0 001.71.71l2-2c.18-.18.29-.43.29-.71s-.11-.53-.29-.71z"],
    "minus": ["M13 7H3c-.55 0-1 .45-1 1s.45 1 1 1h10c.55 0 1-.45 1-1s-.45-1-1-1z"],
    "multi-select": ["M12 3.98H4c-.55 0-1 .45-1 1v1h8v5h1c.55 0 1-.45 1-1v-5c0-.55-.45-1-1-1zm3-3H7c-.55 0-1 .45-1 1v1h8v5h1c.55 0 1-.45 1-1v-5c0-.55-.45-1-1-1zm-6 6H1c-.55 0-1 .45-1 1v5c0 .55.45 1 1 1h8c.55 0 1-.45 1-1v-5c0-.55-.45-1-1-1zm-1 5H2v-3h6v3z"],
    "new-layer": ["M13.982 6.272l1.518.868-.01.01c.3.17.51.48.51.85s-.21.68-.51.85l.01.01-7 4-.01-.01A.94.94 0 018 13a.94.94 0 01-.49-.15l-.01.01-7-4 .01-.01A.977.977 0 010 8c0-.37.21-.68.51-.86L.5 7.13l7-4 .01.02A.94.94 0 018 3c.086 0 .168.014.246.038a2 2 0 105.736 3.234zM14 3c.55 0 1 .45 1 1s-.45 1-1 1h-1v1c0 .55-.45 1-1 1s-1-.45-1-1V5h-1c-.55 0-1-.45-1-1s.45-1 1-1h1V2c0-.55.45-1 1-1s1 .45 1 1v1h1z"],
    "path-search": ["M15 14.62l-4-2.4V9.77c-.32.09-.66.15-1 .18v2.27l-4 2.4V8.71c-.38-.31-.72-.66-1-1.06v6.97l-4-2.4V8c.55 0 1-.45 1-1s-.45-1-1-1V1.38l3.15 1.89c.08-.34.18-.66.32-.97L.76.07v.01A.496.496 0 00.5 0C.22 0 0 .22 0 .5v12c0 .18.1.33.25.42v.01l5 3v-.01c.07.05.16.08.25.08s.18-.03.25-.08v.01l4.74-2.85 4.74 2.85v-.01c.09.05.18.08.27.08.28 0 .5-.22.5-.5v-3.78c-.3.17-.63.28-1 .28v2.62zM2 5c0 .55.45 1 1 1s1-.45 1-1-.45-1-1-1-1 .45-1 1zm6-1c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm7.75-.92l-1.19-.72c.18.43.29.9.36 1.38l.08.04v3.39l1 1V3.5c0-.18-.1-.33-.25-.42zM10 2c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm3.3 4.89c.44-.7.7-1.51.7-2.39C14 2.01 11.99 0 9.5 0S5 2.01 5 4.5 7.01 9 9.5 9c.88 0 1.69-.26 2.39-.7l2.41 2.41c.17.18.42.29.7.29a1.003 1.003 0 00.71-1.71l-2.41-2.4zM9.5 8C7.57 8 6 6.43 6 4.5S7.57 1 9.5 1 13 2.57 13 4.5 11.43 8 9.5 8z"],
    "play": ["M12 8c0-.35-.19-.64-.46-.82l.01-.02-6-4-.01.02A.969.969 0 005 3c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1 .21 0 .39-.08.54-.18l.01.02 6-4-.01-.02c.27-.18.46-.47.46-.82z"],
    "plus": ["M13 7H9V3c0-.55-.45-1-1-1s-1 .45-1 1v4H3c-.55 0-1 .45-1 1s.45 1 1 1h4v4c0 .55.45 1 1 1s1-.45 1-1V9h4c.55 0 1-.45 1-1s-.45-1-1-1z"],
    "print": ["M12 2.02c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1v1h8v-1zm3 2H1c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h1v-3h12v3h1c.55 0 1-.45 1-1v-6c0-.56-.45-1-1-1zm-1 3h-2v-1h2v1zm-3 6H5v-3H3v4c0 .55.45 1 1 1h8c.55 0 1-.45 1-1v-4h-2v3z"],
    "properties": ["M2 6C.9 6 0 6.9 0 8s.9 2 2 2 2-.9 2-2-.9-2-2-2zm4-3h9c.55 0 1-.45 1-1s-.45-1-1-1H6c-.55 0-1 .45-1 1s.45 1 1 1zm-4 9c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm13-5H6c-.55 0-1 .45-1 1s.45 1 1 1h9c.55 0 1-.45 1-1s-.45-1-1-1zm0 6H6c-.55 0-1 .45-1 1s.45 1 1 1h9c.55 0 1-.45 1-1s-.45-1-1-1zM2 0C.9 0 0 .9 0 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"],
    "search": ["M15.55 13.43l-2.67-2.68a6.94 6.94 0 001.11-3.76c0-3.87-3.13-7-7-7s-7 3.13-7 7 3.13 7 7 7c1.39 0 2.68-.42 3.76-1.11l2.68 2.67a1.498 1.498 0 102.12-2.12zm-8.56-1.44c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"],
    "select": ["M16 15c0-.28-.12-.52-.31-.69l.02-.02-3.12-3.12 3.41-.84-8.05-2.86c.03-.09.05-.17.05-.27V2c0-.55-.45-1-1-1H3c0-.55-.45-1-1-1S1 .45 1 1c-.55 0-1 .45-1 1s.45 1 1 1v4c0 .55.45 1 1 1h5.2c.1 0 .18-.02.27-.05L10.33 16l.85-3.41 3.12 3.12.02-.02c.16.19.4.31.68.31.04 0 .07-.02.1-.02s.06.02.1.02c.44 0 .8-.36.8-.8 0-.04-.02-.07-.02-.1s.02-.06.02-.1zM6 6H3V3h3v3z"],
    "small-cross": ["M9.41 8l2.29-2.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L8 6.59l-2.29-2.3a1.003 1.003 0 00-1.42 1.42L6.59 8 4.3 10.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L8 9.41l2.29 2.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L9.41 8z"],
    "stop": ["M12 3H4c-.55 0-1 .45-1 1v8c0 .55.45 1 1 1h8c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"],
    "tag": ["M1 3a2 2 0 012-2h4.584a2 2 0 011.414.586l5.413 5.412a2 2 0 010 2.829L9.827 14.41a2 2 0 01-2.829 0L1.586 8.998A2 2 0 011 7.584V3zm3.487-.007a1.494 1.494 0 100 2.988 1.494 1.494 0 000-2.988z"],
    "th": ["M15 1H1c-.6 0-1 .5-1 1v12c0 .6.4 1 1 1h14c.6 0 1-.4 1-1V2c0-.5-.4-1-1-1zM6 13H2v-2h4v2zm0-3H2V8h4v2zm0-3H2V5h4v2zm8 6H7v-2h7v2zm0-3H7V8h7v2zm0-3H7V5h7v2z"],
    "tick": ["M14 3c-.28 0-.53.11-.71.29L6 10.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42l4 4c.18.18.43.29.71.29s.53-.11.71-.29l8-8A1.003 1.003 0 0014 3z"],
    "trash": ["M14.49 3.99h-13c-.28 0-.5.22-.5.5s.22.5.5.5h.5v10c0 .55.45 1 1 1h10c.55 0 1-.45 1-1v-10h.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5zm-8.5 9c0 .55-.45 1-1 1s-1-.45-1-1v-6c0-.55.45-1 1-1s1 .45 1 1v6zm3 0c0 .55-.45 1-1 1s-1-.45-1-1v-6c0-.55.45-1 1-1s1 .45 1 1v6zm3 0c0 .55-.45 1-1 1s-1-.45-1-1v-6c0-.55.45-1 1-1s1 .45 1 1v6zm2-12h-4c0-.55-.45-1-1-1h-2c-.55 0-1 .45-1 1h-4c-.55 0-1 .45-1 1v1h14v-1c0-.55-.45-1-1-1z"],
    "upload": ["M8 0C3.58 0 0 3.58 0 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm3 8c-.28 0-.53-.11-.71-.29L9 6.41V12c0 .55-.45 1-1 1s-1-.45-1-1V6.41l-1.29 1.3a1.003 1.003 0 01-1.42-1.42l3-3C7.47 3.11 7.72 3 8 3s.53.11.71.29l3 3A1.003 1.003 0 0111 8z"],
    "warning-sign": ["M15.84 13.5l.01-.01-7-12-.01.01c-.17-.3-.48-.5-.85-.5s-.67.2-.85.5l-.01-.01-7 12 .01.01c-.09.15-.15.31-.15.5 0 .55.45 1 1 1h14c.55 0 1-.45 1-1 0-.19-.06-.35-.15-.5zm-6.85-.51h-2v-2h2v2zm0-3h-2v-5h2v5z"],
    "zoom-to-fit": ["M11 10a1.003 1.003 0 001.71.71l2-2c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-2-2a1.003 1.003 0 00-1.42 1.42L12.59 8 11.3 9.29c-.19.18-.3.43-.3.71zM1 5c.55 0 1-.45 1-1V2h2c.55 0 1-.45 1-1s-.45-1-1-1H1C.45 0 0 .45 0 1v3c0 .55.45 1 1 1zm4 1a1.003 1.003 0 00-1.71-.71l-2 2C1.11 7.47 1 7.72 1 8c0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42L3.41 8 4.7 6.71c.19-.18.3-.43.3-.71zm1-1c.28 0 .53-.11.71-.29L8 3.41 9.29 4.7c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-2-2C8.53 1.11 8.28 1 8 1s-.53.11-.71.29l-2 2A1.003 1.003 0 006 5zm9 6c-.55 0-1 .45-1 1v2h-2c-.55 0-1 .45-1 1s.45 1 1 1h3c.55 0 1-.45 1-1v-3c0-.55-.45-1-1-1zm0-11h-3c-.55 0-1 .45-1 1s.45 1 1 1h2v2c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1zM4 14H2v-2c0-.55-.45-1-1-1s-1 .45-1 1v3c0 .55.45 1 1 1h3c.55 0 1-.45 1-1s-.45-1-1-1zm6-3c-.28 0-.53.11-.71.29L8 12.59 6.71 11.3A.965.965 0 006 11a1.003 1.003 0 00-.71 1.71l2 2c.18.18.43.29.71.29s.53-.11.71-.29l2-2A1.003 1.003 0 0010 11z"]
}

const IconSvgPaths20 = {
    "arrow-left": ["M18 9H4.41L8.7 4.71c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71l-6 6c-.18.18-.29.43-.29.71 0 .28.11.53.29.71l6 6a1.003 1.003 0 001.42-1.42L4.41 11H18c.55 0 1-.45 1-1s-.45-1-1-1z"],
    "arrow-right": ["M18.71 9.29l-6-6a1.003 1.003 0 00-1.42 1.42L15.59 9H2c-.55 0-1 .45-1 1s.45 1 1 1h13.59l-4.29 4.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l6-6c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z"],
    "arrows-horizontal": ["M19.7 9.3l-5-5c-.2-.2-.4-.3-.7-.3-.6 0-1 .4-1 1 0 .3.1.5.3.7L16.6 9H3.4l3.3-3.3c.2-.2.3-.4.3-.7 0-.6-.4-1-1-1-.3 0-.5.1-.7.3l-5 5c-.2.2-.3.4-.3.7s.1.5.3.7l5 5c.2.2.4.3.7.3.6 0 1-.4 1-1 0-.3-.1-.5-.3-.7L3.4 11h13.2l-3.3 3.3c-.2.2-.3.4-.3.7 0 .6.4 1 1 1 .3 0 .5-.1.7-.3l5-5c.2-.2.3-.4.3-.7s-.1-.5-.3-.7z"],
    "application": ["M3.5 9h9c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-9c-.28 0-.5.22-.5.5s.22.5.5.5zm0 2h5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-5c-.28 0-.5.22-.5.5s.22.5.5.5zM19 1H1c-.55 0-1 .45-1 1v16c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zm-1 16H2V6h16v11zM3.5 13h7c.28 0 .5-.22.5-.5s-.22-.5-.5-.5h-7c-.28 0-.5.22-.5.5s.22.5.5.5z"],
    "caret-down": ["M16 7c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1 0 .24.1.46.24.63l-.01.01 5 6 .01-.01c.19.22.45.37.76.37s.57-.15.76-.37l.01.01 5-6-.01-.01c.14-.17.24-.39.24-.63z"],
    "caret-up": ["M15.76 12.37l.01-.01-5-6-.01.01C10.57 6.15 10.31 6 10 6s-.57.15-.76.37l-.01-.01-5 6 .01.01c-.14.17-.24.39-.24.63 0 .55.45 1 1 1h10c.55 0 1-.45 1-1 0-.24-.1-.46-.24-.63z"],
    "chevron-down": ["M16 6c-.28 0-.53.11-.71.29L10 11.59l-5.29-5.3a1.003 1.003 0 00-1.42 1.42l6 6c.18.18.43.29.71.29s.53-.11.71-.29l6-6A1.003 1.003 0 0016 6z"],
    "chevron-right": ["M13.71 9.29l-6-6a1.003 1.003 0 00-1.42 1.42l5.3 5.29-5.29 5.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l6-6c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z"],
    "chevron-up": ["M16.71 12.29l-6-6C10.53 6.11 10.28 6 10 6s-.53.11-.71.29l-6 6a1.003 1.003 0 001.42 1.42L10 8.41l5.29 5.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71z"],
    "cross": ["M11.41 10l4.29-4.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L10 8.59l-4.29-4.3a1.003 1.003 0 00-1.42 1.42L8.59 10 4.3 14.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l4.29-4.3 4.29 4.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L11.41 10z"],
    "cog": ["M19 8h-2.31c-.14-.46-.33-.89-.56-1.3l1.7-1.7a.996.996 0 000-1.41l-1.41-1.41a.996.996 0 00-1.41 0l-1.7 1.7c-.41-.22-.84-.41-1.3-.55V1c0-.55-.45-1-1-1H9c-.55 0-1 .45-1 1v2.33c-.48.14-.94.34-1.37.58L5 2.28a.972.972 0 00-1.36 0L2.28 3.64c-.37.38-.37.99 0 1.36L3.9 6.62c-.24.44-.44.89-.59 1.38H1c-.55 0-1 .45-1 1v2c0 .55.45 1 1 1h2.31c.14.46.33.89.56 1.3L2.17 15a.996.996 0 000 1.41l1.41 1.41c.39.39 1.02.39 1.41 0l1.7-1.7c.41.22.84.41 1.3.55V19c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-2.33c.48-.14.94-.35 1.37-.59L15 17.72c.37.37.98.37 1.36 0l1.36-1.36c.37-.37.37-.98 0-1.36l-1.62-1.62c.24-.43.45-.89.6-1.38H19c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1zm-9 6c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"],
    "comment": ["M19 1H1c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3v4a1.003 1.003 0 001.71.71l4.7-4.71H19c.55 0 1-.45 1-1V2c0-.55-.45-1-1-1zM4 10c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm6 0c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm6 0c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"],
    "delete": ["M15 6a1.003 1.003 0 00-1.71-.71L10 8.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42L8.59 10 5.3 13.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l3.29-3.3 3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L11.41 10l3.29-3.29c.19-.18.3-.43.3-.71zm-5-6C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"],
    "disable": ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zM2 10c0-4.42 3.58-8 8-8 1.85 0 3.55.63 4.9 1.69L3.69 14.9A7.902 7.902 0 012 10zm8 8c-1.85 0-3.55-.63-4.9-1.69L16.31 5.1A7.902 7.902 0 0118 10c0 4.42-3.58 8-8 8z"],
    "double-caret-vertical": ["M5 9h10c.55 0 1-.45 1-1 0-.24-.1-.46-.24-.63l.01-.01-5-6-.01.01C10.57 1.15 10.31 1 10 1s-.57.15-.76.37l-.01-.01-5 6 .01.01C4.1 7.54 4 7.76 4 8c0 .55.45 1 1 1zm10 2H5c-.55 0-1 .45-1 1 0 .24.1.46.24.63l-.01.01 5 6 .01-.01c.19.22.45.37.76.37s.57-.15.76-.37l.01.01 5-6-.01-.01c.14-.17.24-.39.24-.63 0-.55-.45-1-1-1z"],
    "edit": ["M4.59 12.59l2.83 2.83 7.65-7.65-2.83-2.83-7.65 7.65zM2 18l4.41-1.59-2.81-2.79L2 18zM16 2c-.55 0-1.05.22-1.41.59l-1.65 1.65 2.83 2.83 1.65-1.65A2.006 2.006 0 0016 2z"],
    "error": ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm1 16H9v-2h2v2zm0-3H9V4h2v9z"],
    "folder-close": ["M0 17c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V7H0v10zM19 4H9.41l-1.7-1.71A.997.997 0 007 2H1c-.55 0-1 .45-1 1v3h20V5c0-.55-.45-1-1-1z"],
    "geosearch": ["M8 18.88c-3.79 0-6.88-3.09-6.88-6.88 0-.61.08-1.22.23-1.79.03.01.06-.01.1-.01h.09v.55c0 .23.21.42.44.42.04 0 .09-.01.12-.02l.9.88c.09.09.23.09.32 0s.09-.23 0-.32l-.86-.9c0-.02.05-.04.05-.07v-.13c0-.18.1-.25.29-.41h.53c.1 0 .19-.01.27-.05.01-.01.02 0 .03-.01.02-.01.03-.02.05-.04.01-.01.02-.01.02-.02l.02-.02 1.13-1.13c-.16-.32-.3-.65-.42-.99h-.64v-.53c0-.01.06.06.06-.1h.38c-.04-.16-.08-.32-.1-.48h-.71c.2-.16.42-.31.64-.45C4.02 6.09 4 5.8 4 5.5c0-.14.01-.28.02-.43C1.62 6.46 0 9.04 0 12c0 4.41 3.59 8 8 8 3.87 0 7.09-2.77 7.82-6.44l-.97-1.1c-.26 3.57-3.23 6.42-6.85 6.42zm-2.12-3.67v-.35h.15c.29 0 .49-.23.49-.53v-.68c0-.01.01-.01 0-.02L4.71 11.8h-.77c-.29 0-.47.24-.47.53v2c0 .29.18.53.47.53h.33v2.02c0 .28.28.51.56.51s.56-.23.56-.51v-1.22h-.01c.29 0 .5-.16.5-.45zm13.83-2.92l-3.68-3.68c.14-.21.27-.42.38-.65.02-.04.04-.07.05-.11.11-.22.2-.45.28-.69v-.01c.07-.24.13-.48.17-.73l.03-.17c.04-.24.06-.49.06-.75C17 2.46 14.54 0 11.5 0S6 2.46 6 5.5 8.46 11 11.5 11c.26 0 .51-.02.76-.06l.17-.03c.25-.04.49-.1.73-.17h.01c.24-.08.47-.17.69-.28.04-.02.07-.04.11-.05.23-.11.44-.24.65-.38l3.68 3.68c.17.18.42.29.7.29a1.003 1.003 0 00.71-1.71zM11.5 9.5c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4zm1.93 5.33v-.65c0-.11-.13-.21-.24-.21-.11 0-.24.09-.24.21v.65c0 .11.13.21.24.21.11 0 .24-.1.24-.21zm-2.41.67h.83c.29 0 .46-.21.46-.5v-1.86l.23-.22c-.34.05-.69.08-1.04.08-.36 0-.7-.03-1.05-.08.03.05.06.1.08.16V15c.01.29.2.5.49.5z"],
    "hand": ["M17 5c-.42 0-.79.27-.93.64L14.38 10h-.77l1.34-6.67c.03-.1.05-.21.05-.33a.998.998 0 00-1.98-.19h-.01L11.57 10H11V1c0-.55-.45-1-1-1S9 .45 9 1v9h-.2L6.97 2.76a.997.997 0 00-1.73-.41l-.03.03c-.01.02-.02.03-.03.04-.01.02-.01.03-.02.04v.01c-.01.01-.02.02-.02.03v.01c-.02.01-.02.02-.03.03 0 0 0 .01-.01.01 0 .01 0 .02-.01.03 0 0 0 .01-.01.01 0 .01-.01.02-.01.03 0 0 0 .01-.01.01 0 .01-.01.02-.01.03 0 .01 0 .01-.01.02 0 .01-.01.02-.01.03 0 .01 0 .01-.01.02 0 .01-.01.02-.01.03v.02c0 .01 0 .02-.01.03V3c0 .05 0 .09.01.14l1.45 10.25L6 12.7v.01L3.84 9.45h-.01A.98.98 0 003 9c-.55 0-1 .45-1 1 0 .2.06.39.17.55L6 18.44C7.06 19.4 8.46 20 10 20c3.31 0 6-2.69 6-6v-1.84l.01-.03v-.06l1.94-5.75A1.003 1.003 0 0017 5z"],
    "home": ["M2 12v7c0 .55.45 1 1 1h5v-7h4v7h5c.55 0 1-.45 1-1v-7l-8-8-8 8zm17.71-2.71L17 6.59V3c0-.55-.45-1-1-1s-1 .45-1 1v1.59L10.71.3C10.53.11 10.28 0 10 0s-.53.11-.71.29l-9 9a1.003 1.003 0 001.42 1.42L10 2.41l8.29 8.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71z"],
    "info-sign": ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zM9 4h2v2H9V4zm4 12H7v-1h2V8H8V7h3v8h2v1z"],
    "issue": ["M10 20C4.477 20 0 15.523 0 10S4.477 0 10 0s10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 100-16 8 8 0 000 16zm1-2H9v-2h2v2zm0-3H9V4h2v9z"],
    "layer": ["M19.5 9.1l-9-5c-.2-.1-.3-.1-.5-.1s-.3 0-.5.1l-9 5c-.3.2-.5.5-.5.9s.2.7.5.9l9 5c.2.1.3.1.5.1s.3 0 .5-.1l9-5c.3-.2.5-.5.5-.9s-.2-.7-.5-.9z"],
    "layers": ["M.5 6.9l9 5c.2.1.3.1.5.1s.3 0 .5-.1l9-5c.3-.2.5-.5.5-.9s-.2-.7-.5-.9l-9-5c-.2-.1-.3-.1-.5-.1s-.3 0-.5.1l-9 5c-.3.2-.5.5-.5.9s.2.7.5.9z",
"M19 9c-.2 0-.3 0-.5.1L10 13.9 1.5 9.1C1.3 9 1.2 9 1 9c-.6 0-1 .4-1 1 0 .4.2.7.5.9l9 5c.2.1.3.1.5.1s.3 0 .5-.1l9-5c.3-.2.5-.5.5-.9 0-.6-.4-1-1-1z",
"M19 13c-.2 0-.3 0-.5.1L10 17.9l-8.5-4.7c-.2-.2-.3-.2-.5-.2-.6 0-1 .4-1 1 0 .4.2.7.5.9l9 5c.2.1.3.1.5.1s.3 0 .5-.1l9-5c.3-.2.5-.5.5-.9 0-.6-.4-1-1-1z"],
    "map": ["M19.54 4.18l.01-.02-6-4-.01.02C13.39.08 13.21 0 13 0s-.39.08-.54.18l-.01-.02L7 3.8 1.55.17l-.01.01A.969.969 0 001 0C.45 0 0 .45 0 1v14c0 .35.19.64.46.82l-.01.02 6 4 .01-.02c.15.1.33.18.54.18s.39-.08.54-.18l.01.02L13 16.2l5.45 3.63.01-.02c.15.11.33.19.54.19.55 0 1-.45 1-1V5c0-.35-.19-.64-.46-.82zM6 17.13l-4-2.67V2.87l4 2.67v11.59zm6-2.67l-4 2.67V5.54l4-2.67v11.59zm6 2.67l-4-2.67V2.87l4 2.67v11.59z"],
    "media": ["M15 9c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm4-7H1c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h18c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zm-1 13l-6-5-2 2-4-5-4 8V4h16v11z"],    
    "menu-closed": ["M8 6h11c.55 0 1-.45 1-1s-.45-1-1-1H8c-.55 0-1 .45-1 1s.45 1 1 1zM4 6c-.28 0-.53.11-.71.29l-3 3C.11 9.47 0 9.72 0 10c0 .28.11.53.29.71l3 3A1.003 1.003 0 005 13V7c0-.55-.45-1-1-1zm15 8H8c-.55 0-1 .45-1 1s.45 1 1 1h11c.55 0 1-.45 1-1s-.45-1-1-1zm0-5H8c-.55 0-1 .45-1 1s.45 1 1 1h11c.55 0 1-.45 1-1s-.45-1-1-1z"],    
    "menu-open": ["M12 9H1c-.55 0-1 .45-1 1s.45 1 1 1h11c.55 0 1-.45 1-1s-.45-1-1-1zm0 5H1c-.55 0-1 .45-1 1s.45 1 1 1h11c.55 0 1-.45 1-1s-.45-1-1-1zm0-10H1c-.55 0-1 .45-1 1s.45 1 1 1h11c.55 0 1-.45 1-1s-.45-1-1-1zm7.71 5.29l-3-3A1.003 1.003 0 0015 7v6a1.003 1.003 0 001.71.71l3-3c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71z"],
    "minus": ["M16 9H4c-.55 0-1 .45-1 1s.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1z"],
    "multi-select": ["M19 3H7c-.55 0-1 .45-1 1v1h12v6h1c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1zm-6 6H1c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zm-1 6H2v-4h10v4zm4-9H4c-.55 0-1 .45-1 1v1h12v6h1c.55 0 1-.45 1-1V7c0-.55-.45-1-1-1z"],
    "new-layer": ["M11.513 2.663A2 2 0 0013 6h1v1a2 2 0 104 0v-.733l1.5.833c.3.2.5.5.5.9s-.2.7-.5.9l-9 5c-.2.1-.3.1-.5.1s-.3 0-.5-.1l-9-5C.2 8.7 0 8.4 0 8s.2-.7.5-.9l9-5c.2-.1.3-.1.5-.1s.3 0 .5.1l1.013.563zM17 3h2a1 1 0 010 2h-2v2a1 1 0 01-2 0V5h-2a1 1 0 010-2h2V1a1 1 0 012 0v2z"],
    "path-search": ["M4 7c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm15 11.69l-5-2.5v-3.63c-.32.11-.66.22-1 .29v3.32l-6 2.57v-7.25c-.36-.27-.69-.57-1-.9v8.1l-5-2.5V10c.55 0 1-.45 1-1s-.45-1-1-1V1.31l3.43 1.71c.11-.31.24-.62.39-.92L.72.05A.545.545 0 00.5 0C.22 0 0 .22 0 .5v16c0 .2.12.36.28.44l6 3c.07.04.14.06.22.06.07 0 .14-.01.2-.04l6.79-2.91 5.79 2.9c.07.03.14.05.22.05.28 0 .5-.22.5-.5v-4.21c-.31.13-.64.21-1 .21v3.19zM10 5c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm3-1c-.55 0-1 .45-1 1s.45 1 1 1 1-.45 1-1-.45-1-1-1zm6.72-.94l-1.43-.72c.2.43.36.89.48 1.36l.23.11V5.5c-.55 0-1 .45-1 1s.45 1 1 1v1.96l1 1V3.5c0-.2-.12-.36-.28-.44zm-3.69 5.56c.14-.21.27-.42.38-.65.02-.04.04-.07.05-.11.11-.22.2-.45.28-.69v-.01c.07-.24.13-.48.17-.73l.03-.17c.04-.25.06-.5.06-.76C17 2.46 14.54 0 11.5 0S6 2.46 6 5.5 8.46 11 11.5 11c.26 0 .51-.02.76-.06l.17-.03c.25-.04.49-.1.73-.17h.01c.24-.08.47-.17.69-.28.04-.02.07-.03.11-.05.23-.11.44-.24.65-.38l.18.18 3.5 3.5c.17.18.42.29.7.29a1.003 1.003 0 00.71-1.71l-3.68-3.67zm-4.53.88c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"],
    "play": ["M16 10c0-.36-.2-.67-.49-.84l.01-.01-10-6-.01.01A.991.991 0 005 3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1 .19 0 .36-.07.51-.16l.01.01 10-6-.01-.01c.29-.17.49-.48.49-.84z"],
    "plus": ["M16 9h-5V4c0-.55-.45-1-1-1s-1 .45-1 1v5H4c-.55 0-1 .45-1 1s.45 1 1 1h5v5c0 .55.45 1 1 1s1-.45 1-1v-5h5c.55 0 1-.45 1-1s-.45-1-1-1z"],
    "print": ["M14 16H6v-4H4v5c0 .55.45 1 1 1h10c.55 0 1-.45 1-1v-5h-2v4zm2-13c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1v1h12V3zm3 2H1c-.55 0-1 .45-1 1v7c0 .55.45 1 1 1h2v-3h14v3h2c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-1 4h-2V7h2v2z"],
    "properties": ["M2 15c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-7c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm5-4h12c.55 0 1-.45 1-1s-.45-1-1-1H7c-.55 0-1 .45-1 1s.45 1 1 1zM2 1C.9 1 0 1.9 0 3s.9 2 2 2 2-.9 2-2-.9-2-2-2zm17 8H7c-.55 0-1 .45-1 1s.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1zm0 7H7c-.55 0-1 .45-1 1s.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1z"],
    "select": ["M19.71 18.29l-4.25-4.25L20 12.91 9.93 9.33c.04-.1.07-.21.07-.33V3c0-.55-.45-1-1-1H4V1c0-.55-.45-1-1-1S2 .45 2 1v1H1c-.55 0-1 .45-1 1s.45 1 1 1h1v5c0 .55.45 1 1 1h6c.12 0 .23-.03.34-.07L12.91 20l1.14-4.54 4.25 4.25c.17.18.42.29.7.29a1.003 1.003 0 00.71-1.71zM8 8H4V4h4v4z"],
    "search": ["M19.56 17.44l-4.94-4.94A8.004 8.004 0 0016 8c0-4.42-3.58-8-8-8S0 3.58 0 8s3.58 8 8 8c1.67 0 3.21-.51 4.5-1.38l4.94 4.94a1.498 1.498 0 102.12-2.12zM8 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"],
    "small-cross": ["M11.41 10l3.29-3.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L10 8.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42L8.59 10 5.3 13.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71l3.29-3.3 3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L11.41 10z"],
    "stop": ["M16 3H4c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"],
    "tag": ["M2 4a2 2 0 012-2h4.588a2 2 0 011.414.586l7.41 7.41a2 2 0 010 2.828l-4.588 4.588a2 2 0 01-2.829 0l-7.41-7.41A2 2 0 012 8.588V4zm3.489-.006a1.495 1.495 0 100 2.99 1.495 1.495 0 000-2.99z"],
    "th": ["M19 1H1c-.6 0-1 .5-1 1v16c0 .5.4 1 1 1h18c.5 0 1-.5 1-1V2c0-.5-.5-1-1-1zM7 17H2v-3h5v3zm0-4H2v-3h5v3zm0-4H2V6h5v3zm11 8H8v-3h10v3zm0-4H8v-3h10v3zm0-4H8V6h10v3z"],
    "tick": ["M17 4c-.28 0-.53.11-.71.29L7 13.59 3.71 10.3A.965.965 0 003 10a1.003 1.003 0 00-.71 1.71l4 4c.18.18.43.29.71.29s.53-.11.71-.29l10-10A1.003 1.003 0 0017 4z"],
    "trash": ["M17 1h-5c0-.55-.45-1-1-1H9c-.55 0-1 .45-1 1H3c-.55 0-1 .45-1 1v1h16V2c0-.55-.45-1-1-1zm.5 3h-15c-.28 0-.5.22-.5.5s.22.5.5.5H3v14c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V5h.5c.28 0 .5-.22.5-.5s-.22-.5-.5-.5zM7 16c0 .55-.45 1-1 1s-1-.45-1-1V8c0-.55.45-1 1-1s1 .45 1 1v8zm4 0c0 .55-.45 1-1 1s-1-.45-1-1V8c0-.55.45-1 1-1s1 .45 1 1v8zm4 0c0 .55-.45 1-1 1s-1-.45-1-1V8c0-.55.45-1 1-1s1 .45 1 1v8z"],
    "upload": ["M10 0C4.48 0 0 4.48 0 10s4.48 10 10 10 10-4.48 10-10S15.52 0 10 0zm4 10c-.28 0-.53-.11-.71-.29L11 7.41V15c0 .55-.45 1-1 1s-1-.45-1-1V7.41l-2.29 2.3a1.003 1.003 0 01-1.42-1.42l4-4c.18-.18.43-.29.71-.29s.53.11.71.29l4 4A1.003 1.003 0 0114 10z"],
    "warning-sign": ["M19.86 17.52l.01-.01-9-16-.01.01C10.69 1.21 10.37 1 10 1s-.69.21-.86.52l-.01-.01-9 16 .01.01c-.08.14-.14.3-.14.48 0 .55.45 1 1 1h18c.55 0 1-.45 1-1 0-.18-.06-.34-.14-.48zM11 17H9v-2h2v2zm0-3H9V6h2v8z"],
    "zoom-to-fit": ["M1 7c.55 0 1-.45 1-1V2h4c.55 0 1-.45 1-1s-.45-1-1-1H1C.45 0 0 .45 0 1v5c0 .55.45 1 1 1zm5 1a1.003 1.003 0 00-1.71-.71l-2 2c-.18.18-.29.43-.29.71 0 .28.11.53.29.71l2 2a1.003 1.003 0 001.42-1.42L4.41 10 5.7 8.71c.19-.18.3-.43.3-.71zm2-2c.28 0 .53-.11.71-.29L10 4.41l1.29 1.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71l-2-2C10.53 2.11 10.28 2 10 2s-.53.11-.71.29l-2 2A1.003 1.003 0 008 6zM6 18H2v-4c0-.55-.45-1-1-1s-1 .45-1 1v5c0 .55.45 1 1 1h5c.55 0 1-.45 1-1s-.45-1-1-1zm8-6a1.003 1.003 0 001.71.71l2-2c.18-.18.29-.43.29-.71 0-.28-.11-.53-.29-.71l-2-2a1.003 1.003 0 00-1.42 1.42l1.3 1.29-1.29 1.29c-.19.18-.3.43-.3.71zm5-12h-5c-.55 0-1 .45-1 1s.45 1 1 1h4v4c0 .55.45 1 1 1s1-.45 1-1V1c0-.55-.45-1-1-1zm-7 14c-.28 0-.53.11-.71.29L10 15.59 8.71 14.3A.965.965 0 008 14a1.003 1.003 0 00-.71 1.71l2 2c.18.18.43.29.71.29s.53-.11.71-.29l2-2A1.003 1.003 0 0012 14zm7-1c-.55 0-1 .45-1 1v4h-4c-.55 0-1 .45-1 1s.45 1 1 1h5c.55 0 1-.45 1-1v-5c0-.55-.45-1-1-1z"]
}

/***/ }),

/***/ "?4f7e":
/*!********************************!*\
  !*** ./util.inspect (ignored) ***!
  \********************************/
/***/ (function() {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	!function() {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = function(result, chunkIds, fn, priority) {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var chunkIds = deferred[i][0];
/******/ 				var fn = deferred[i][1];
/******/ 				var priority = deferred[i][2];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	!function() {
/******/ 		var getProto = Object.getPrototypeOf ? function(obj) { return Object.getPrototypeOf(obj); } : function(obj) { return obj.__proto__; };
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach(function(key) { def[key] = function() { return value[key]; }; });
/******/ 			}
/******/ 			def['default'] = function() { return value; };
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	!function() {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"viewer": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = function(chunkId) { return installedChunks[chunkId] === 0; };
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkMapGuide"] = self["webpackChunkMapGuide"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["vendor"], function() { return __webpack_require__("./src/entries/library.tsx"); })
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	MapGuide = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=viewer-debug.js.map